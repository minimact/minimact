<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FAQ - Minimact | Server-side React with Predictive Rendering</title>
  <meta name="description" content="Frequently asked questions about Minimact - the posthydrationist React framework for ASP.NET Core with predictive rendering">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    .accordion-content.open {
      max-height: 2000px;
      transition: max-height 0.5s ease-in;
    }
    .accordion-arrow {
      transition: transform 0.3s ease;
    }
    .accordion-arrow.open {
      transform: rotate(180deg);
    }
  </style>
</head>
<body class="bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 min-h-screen">

  <!-- Navigation -->
  <nav class="border-b border-slate-800 bg-slate-950/50 backdrop-blur-sm">
    <div class="max-w-7xl mx-auto px-6 py-4 flex items-center justify-between">
      <a href="/" class="flex items-center gap-3 hover:opacity-80 transition-opacity">
        <span class="text-3xl">üåµ</span>
        <h1 class="text-2xl font-bold text-white">Minimact</h1>
      </a>
      <div class="flex items-center gap-6">
        <a href="/" class="text-slate-300 hover:text-white transition-colors">Home</a>
        <a href="/#features" class="text-slate-300 hover:text-white transition-colors">Features</a>
        <a href="/faq.html" class="text-white font-semibold">FAQ</a>
        <a href="https://github.com/minimact/minimact" target="_blank" class="text-slate-300 hover:text-white transition-colors">GitHub</a>
        <a href="/playground" class="px-5 py-2 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-lg font-semibold hover:from-blue-700 hover:to-purple-700 transition-all shadow-lg hover:shadow-xl">
          Try Playground ‚Üí
        </a>
      </div>
    </div>
  </nav>

  <!-- Hero -->
  <section class="max-w-5xl mx-auto px-6 py-16 text-center">
    <h2 class="text-5xl font-bold text-white mb-6">
      Frequently Asked Questions
    </h2>
    <p class="text-xl text-slate-300 max-w-3xl mx-auto">
      Everything you need to know about Minimact, predictive rendering, and the posthydrationist philosophy
    </p>
  </section>

  <!-- FAQ Accordion -->
  <section class="max-w-5xl mx-auto px-6 pb-24">
    <div class="space-y-4" id="faq-container">

      <!-- FAQ Item Template (will be populated by JS) -->

    </div>
  </section>

  <!-- CTA -->
  <section class="max-w-5xl mx-auto px-6 pb-24">
    <div class="bg-gradient-to-r from-blue-600 to-purple-600 rounded-2xl p-12 text-center">
      <h3 class="text-3xl font-bold text-white mb-4">
        Ready to try predictive rendering?
      </h3>
      <p class="text-xl text-blue-100 mb-8">
        Experience the future of server-side React in the interactive playground
      </p>
      <a href="/playground" class="inline-block px-10 py-4 bg-white text-blue-600 rounded-lg font-bold text-lg hover:bg-blue-50 transition-all shadow-2xl hover:scale-105">
        Launch Playground ‚Üí
      </a>
    </div>
  </section>

  <!-- Footer -->
  <footer class="border-t border-slate-800 bg-slate-950/50">
    <div class="max-w-7xl mx-auto px-6 py-8 text-center text-slate-400 text-sm">
      <p>Built with ‚ù§Ô∏è for the .NET and React communities ‚Ä¢ ¬© 2025 Minimact</p>
    </div>
  </footer>

  <script>
    const faqs = [
      {
        emoji: '‚ùì',
        question: 'Why did you build Minimact?',
        answer: `Because I got tired of pretending hydration was acceptable just because it's familiar. I wanted a better model‚Äîone that didn't rely on overburdened clients, giant bundles, and reconciliation cycles happening after the user acts.

Minimact was born from a simple, almost heretical question:

"What if the client didn't need to reconcile anything at all... because it already knew what would happen?"`
      },
      {
        emoji: 'ü§ñ',
        question: 'Where did the idea of prediction come from?',
        answer: `From AI.

Modern AI systems‚Äîparticularly transformers and reinforcement learners‚Äîexcel at one thing: prediction.

Whether it's next tokens, future states, or optimal actions, they all revolve around:
‚Ä¢ Observing patterns
‚Ä¢ Modeling likely outcomes
‚Ä¢ Acting before complete information is available

That inspired me to ask: What if we could apply predictive modeling principles to the UI itself?

And not through neural nets, but through deterministic, cacheable state transitions.`
      },
      {
        emoji: 'üî≠',
        question: 'Did AI play a direct role in the architecture?',
        answer: `Indirectly, yes.

I wasn't trying to stuff machine learning into a web framework. But I was asking questions that are common in AI design:
‚Ä¢ Can we precompute probable futures?
‚Ä¢ Can we reduce latency by betting on the most likely paths?
‚Ä¢ Can we let the system adapt to user behavior?

The answers led to a reconciliation engine in Rust, predictive hints, and the entire stored-procedure-for-the-DOM model.`
      },
      {
        emoji: 'üìú',
        question: 'What inspired the predictive patch system?',
        answer: `Patterns. Repeated patterns. And hours of staring at logs.

I spent a lot of time chasing down weird bugs and performance issues in large-scale cloud-hosted apps. I saw the same actions happening over and over. Same inputs. Same flows. Same timing. But every interaction was treated like a blank slate.

That felt... deeply inefficient.

Why were we reacting in real-time to things we've seen thousands of times?

I wanted to preempt the predictable. That's where the predictive patch cache came from.`
      },
      {
        emoji: 'üõ†Ô∏è',
        question: 'What was the first thing you prototyped?',
        answer: `A counter. The simplest UI on Earth.

But instead of updating the DOM reactively, I had a server compute what the DOM would look like after a click, then send it down ahead of time. The patch was ready before the user clicked.

That tiny moment‚Äîclick ‚Üí instant change ‚Üí no network delay‚Äîfelt electric ‚ö°

I knew then that this wasn't just an optimization. It was a shift in how we think about UI responsiveness.`
      },
      {
        emoji: 'üí°',
        question: 'Where did usePredictHint() come from?',
        answer: `From wanting to empower developers to optimize their own experiences‚Äîwithout writing custom cache logic or prediction models.

Hints are like hooks for the future. Instead of managing complex state transitions, you just say:

"Hey, when they click this, they're probably going to want this state."

And the engine handles the rest‚Äîgenerating and sending the patch ahead of time. It's the dev saying, "Trust me, this is gonna happen." And the system answering, "Cool. I'm on it."`
      },
      {
        emoji: 'üîÑ',
        question: 'Why compile TypeScript into C#?',
        answer: `Because I was already working in .NET environments, where business logic, data access, and deployment were C#-centric. But frontend devs still wanted to write React.

Instead of splitting logic across two universes (with brittle APIs and duplicate types), I thought:

What if React UI code could become first-class citizens in C# land?

So I built a Babel plugin that turns JSX/TSX into C# component classes with preserved structure, hooks, and state.

TypeScript handles the ergonomics. C# handles the execution. Rust handles the prediction. üß†`
      },
      {
        emoji: 'üåê',
        question: 'Why not just use HTMX, Blazor, or RSC?',
        answer: `Because none of them fully solved the core problems I was focused on:

‚Ä¢ Latency: React Server Components still hydrate; Blazor Server does full roundtrips; HTMX requires manual control
‚Ä¢ Prediction: None of them precompute state transitions based on future interactions
‚Ä¢ Developer experience: I wanted React ergonomics, not handcrafted event attributes or Razor code
‚Ä¢ Optimization: I wanted proactive rendering, not reactive patching

Minimact is a response to all of that. It's not "like React but on the server." It's React reimagined through predictive execution.`
      },
      {
        emoji: 'üß†',
        question: 'What philosophy drives Minimact?',
        answer: `Don't hydrate. Anticipate.

Hydration is a patch. Reconciliation is a reaction. Minimact asks: What if the work was done before the user ever clicked?

It's built on:
‚Ä¢ Pattern observation
‚Ä¢ Predictive modeling
‚Ä¢ Latency minimization
‚Ä¢ Developer empowerment
‚Ä¢ Simplicity over cleverness

The cactus metaphor isn't just cute‚Äîit's functional. Cacti thrive by storing what they need before the drought. So should your UI.`
      },
      {
        emoji: 'üó∫Ô∏è',
        question: 'What\'s the long-term vision?',
        answer: `To make web development faster, safer, and smarter by default.

‚Ä¢ Give developers tools to express performance-critical intent
‚Ä¢ Eliminate the burden of hydration, bundles, and client state bugs
‚Ä¢ Use prediction not as a gimmick, but as an architectural pillar
‚Ä¢ Make UIs feel native-speed without shipping 100KB of JS

Eventually? Predictive UI should feel obvious. Hydration should feel like legacy tech. And Minimact will be the friendly cactus that led the way.`
      },
      {
        emoji: 'üöÄ',
        question: 'What is Minimact?',
        answer: `Minimact is a server-side React framework for ASP.NET Core that eliminates client-side hydration using a predictive rendering engine written in Rust.

‚Ä¢ You write JSX/TSX with familiar React hooks
‚Ä¢ It's transpiled into C# components
‚Ä¢ The Rust engine precomputes likely UI state transitions
‚Ä¢ The client caches these transitions (patches) ahead of time
‚Ä¢ On user interaction, patches are applied instantly with 0ms perceived latency
‚Ä¢ The server verifies in the background

No hydration. No VDOM diffing. No nonsense.`
      },
      {
        emoji: 'ü§ñ',
        question: 'How does prediction work in a UI framework?',
        answer: `Prediction is based on state transitions, not user intent guesses.

Minimact precomputes what the DOM would look like if a specific state change occurred. This is similar to speculative execution in CPUs or stored procedures in databases.

If the user performs the predicted action (e.g., clicks a button, opens a dropdown), the corresponding DOM patch is already cached on the client. It gets applied instantly‚Äîwithout roundtrips or reconciliation.`
      },
      {
        emoji: 'üí°',
        question: 'What are usePredictHint() hooks?',
        answer: `usePredictHint() lets you hint to the prediction engine that a certain state change is likely.

Example:
usePredictHint('increment', { count: count + 1 });

This tells the system: "Hey, I'm pretty sure the user's going to increment this counter‚Äîqueue the patch now."

Hints improve prediction accuracy and ensure sub-5ms response for latency-sensitive interactions.`
      },
      {
        emoji: '‚è±Ô∏è',
        question: 'What happens if the prediction is wrong?',
        answer: `No sweat üòÖ

‚Ä¢ The client applies the wrong patch (visually)
‚Ä¢ The server notices and corrects the DOM in the background
‚Ä¢ In most cases, the mismatch is corrected within ~50ms and users don't even notice

Think of it like optimistic UI but grounded in actual compiled transitions.`
      },
      {
        emoji: 'üåê',
        question: 'Does this require JavaScript on the client?',
        answer: `Nope. Minimact works with progressive enhancement in mind.

‚Ä¢ With JS: You get predictive patches, instant UI, and background verification
‚Ä¢ Without JS: You fall back to full server-rendered HTML with standard form posts or link clicks

Either way, you ship ~5KB of client JS. That's less than the average favicon.`
      },
      {
        emoji: 'üõ†Ô∏è',
        question: 'Do I need to learn a new syntax or DSL?',
        answer: `No! You use:

‚Ä¢ JSX/TSX for UI
‚Ä¢ React hooks (useState, useEffect, useRef, etc.)
‚Ä¢ Optional semantic hooks (useToggle, useDropdown, useModal)
‚Ä¢ All your existing ASP.NET Core backend skills

Minimact is more "How you write it stays the same", not "Relearn your tools from scratch."`
      },
      {
        emoji: 'üîÅ',
        question: 'What is hybrid state?',
        answer: `Hybrid state means some state is:

‚Ä¢ Client-local (e.g. search box input)
‚Ä¢ Server-managed (e.g. search results, DB-backed lists)

Example:
const [query, setQuery] = useClientState('');
const [results, setResults] = useState([]);

This keeps the UX snappy and secure. You get instant feedback, but the real work happens server-side.`
      },
      {
        emoji: 'üîê',
        question: 'Is this secure? What about business logic?',
        answer: `Yes. Since all logic and rendering happen server-side:

‚Ä¢ Business logic stays on the server (not exposed to the browser)
‚Ä¢ No API keys or tokens are shipped to the client
‚Ä¢ Predictive patches only affect the DOM, not actual application state

And with SignalR in the loop, you always get a verified source of truth.`
      },
      {
        emoji: '‚öôÔ∏è',
        question: 'What are the platform requirements?',
        answer: `You'll need:

‚Ä¢ Node.js 18+
‚Ä¢ .NET 8.0+
‚Ä¢ Rust (for building the predictive engine from source)`
      },
      {
        emoji: 'üí¨',
        question: 'Why not just use React Server Components (RSC)?',
        answer: `You could‚Ä¶ but:

‚Ä¢ RSC still relies on hydration and client bundles
‚Ä¢ It's tightly coupled to Node/Edge runtimes
‚Ä¢ It doesn't offer precomputed UI patches
‚Ä¢ You have to re-learn a bunch of rules and limitations around where hooks can be used

Minimact says: keep your hooks, keep your mental model, and go faster.`
      },
      {
        emoji: 'üõ£Ô∏è',
        question: 'Why compile TSX into C#?',
        answer: `Because C# + ASP.NET Core gives you:

‚Ä¢ Dependency injection
‚Ä¢ EF Core
‚Ä¢ .NET ecosystem power
‚Ä¢ Compile-time type safety
‚Ä¢ A secure, mature hosting model

You're still writing in TypeScript, but you're compiling into a highly optimized server-native runtime.`
      },
      {
        emoji: 'ü¶Ä',
        question: 'Why is Rust involved?',
        answer: `Because Rust is:

‚Ä¢ Fast: for VDOM diffing and patch computation
‚Ä¢ Safe: memory-safety guarantees
‚Ä¢ Compact: great for precomputed patch payloads

It handles the reconciliation + prediction side with zero GC pauses, and can be compiled to WASM in the future.`
      },
      {
        emoji: 'üîç',
        question: 'What happens during an interaction?',
        answer: `‚Ä¢ The client checks its cache for a predicted patch
‚Ä¢ If found ‚Üí apply patch instantly
‚Ä¢ SignalR sends the event to the server
‚Ä¢ Server verifies or sends correction patch
‚Ä¢ If not found ‚Üí fallback to server-rendered HTML`
      },
      {
        emoji: 'üß™',
        question: 'How accurate are predictions?',
        answer: `On average:

‚Ä¢ Counters, toggles, modals ‚Üí 95%+
‚Ä¢ Lists, dropdowns ‚Üí 70‚Äì85%
‚Ä¢ Complex workflows ‚Üí 60‚Äì75%

Hinting, telemetry, and usage data can raise these numbers further.`
      },
      {
        emoji: 'üß∞',
        question: 'What tools does Minimact come with?',
        answer: `‚Ä¢ CLI for project scaffolding and dev server
‚Ä¢ Babel plugin to compile TSX ‚Üí C#
‚Ä¢ Semantic hooks for common UX patterns
‚Ä¢ Type-safe route generation from your C# API
‚Ä¢ Built-in templates for dashboards, auth, admin, etc.`
      },
      {
        emoji: 'üìä',
        question: 'What are real-world benefits?',
        answer: `üöÄ 2√ó faster interactions vs traditional SSR
üìâ Drastically reduced CPU load on low-end clients
üîê Centralized logic and state = better security
üåê Minimal JS = faster first paint
üí™ React familiarity = low learning curve`
      },
      {
        emoji: 'üß≠',
        question: 'Who is Minimact for?',
        answer: `‚úÖ Teams with .NET backends
‚úÖ React developers tired of hydration hell
‚úÖ Apps where performance, security, and UX matter
‚úÖ Enterprises with regulatory or deployment constraints
‚úÖ Devs who want predictable behavior‚Äînot runtime roulette`
      },
      {
        emoji: 'üôÖ',
        question: 'Who is Minimact not for?',
        answer: `‚ùå Fully offline-first apps
‚ùå Multiplayer collaborative editors
‚ùå Canvas/WebGL-heavy frontends
‚ùå Projects that want bleeding-edge React features (e.g. Suspense streaming)`
      },
      {
        emoji: 'üì¶',
        question: 'How big is the client bundle?',
        answer: `About 5KB, gzipped.

For comparison:
‚Ä¢ React: ~30KB+
‚Ä¢ Vue: ~20KB+
‚Ä¢ HTMX: ~14KB
‚Ä¢ Minimact: tiny cactus mode engaged üåµ`
      },
      {
        emoji: 'üõ£Ô∏è',
        question: 'Is this production-ready?',
        answer: `The core predictor engine is solid. The runtime and Babel tooling are under active development, aiming for alpha Q2 2025.

Follow progress in VISION.md or join the Discord.`
      },
      {
        emoji: 'üåµ',
        question: 'What\'s "posthydrationism"?',
        answer: `A tongue-in-cheek term for rejecting client hydration as the default paradigm. Posthydrationism prefers:

‚Ä¢ Precomputation over runtime diffing
‚Ä¢ Stored state transitions over reconciliation
‚Ä¢ Latency minimalism over JS maximalism

In short: Don't hydrate. Anticipate.`
      }
    ];

    // Render FAQs
    const container = document.getElementById('faq-container');

    faqs.forEach((faq, index) => {
      const item = document.createElement('div');
      item.className = 'bg-slate-900 border border-slate-800 rounded-xl overflow-hidden hover:border-blue-600/50 transition-all';

      item.innerHTML = `
        <button class="accordion-button w-full px-6 py-5 flex items-start gap-4 text-left hover:bg-slate-800/50 transition-colors" data-index="${index}">
          <span class="text-2xl flex-shrink-0">${faq.emoji}</span>
          <div class="flex-1">
            <h3 class="text-lg font-semibold text-white">${faq.question}</h3>
          </div>
          <span class="accordion-arrow text-slate-400 text-xl flex-shrink-0">‚ñº</span>
        </button>
        <div class="accordion-content">
          <div class="px-6 pb-6 pt-2 border-t border-slate-800">
            <div class="text-slate-300 leading-relaxed whitespace-pre-line pl-10">
${faq.answer}
            </div>
          </div>
        </div>
      `;

      container.appendChild(item);
    });

    // Add click handlers
    document.querySelectorAll('.accordion-button').forEach(button => {
      button.addEventListener('click', function() {
        const content = this.nextElementSibling;
        const arrow = this.querySelector('.accordion-arrow');
        const isOpen = content.classList.contains('open');

        // Close all
        document.querySelectorAll('.accordion-content').forEach(c => c.classList.remove('open'));
        document.querySelectorAll('.accordion-arrow').forEach(a => a.classList.remove('open'));

        // Open clicked if it was closed
        if (!isOpen) {
          content.classList.add('open');
          arrow.classList.add('open');
        }
      });
    });
  </script>
</body>
</html>
