<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimact Architecture Diagrams</title>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#3b82f6',
                primaryTextColor: '#e2e8f0',
                primaryBorderColor: '#1e40af',
                lineColor: '#64748b',
                secondaryColor: '#8b5cf6',
                tertiaryColor: '#10b981',
                background: '#0f172a',
                mainBkg: '#1e293b',
                secondBkg: '#334155',
                textColor: '#e2e8f0',
                border1: '#475569',
                border2: '#64748b',
                arrowheadColor: '#3b82f6',
                fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace'
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            color: #e2e8f0;
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            border-bottom: 2px solid #334155;
        }

        h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.25rem;
            color: #94a3b8;
            margin-bottom: 2rem;
        }

        .emoji {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        nav {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 3rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
        }

        nav h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: #3b82f6;
        }

        nav ul {
            list-style: none;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 0.75rem;
        }

        nav a {
            display: block;
            padding: 0.75rem 1rem;
            background: #334155;
            border: 1px solid #475569;
            border-radius: 0.5rem;
            color: #e2e8f0;
            text-decoration: none;
            transition: all 0.2s;
        }

        nav a:hover {
            background: #3b82f6;
            border-color: #2563eb;
            transform: translateX(4px);
        }

        section {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.75rem;
            padding: 2rem;
            margin-bottom: 3rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #3b82f6;
            border-bottom: 2px solid #334155;
            padding-bottom: 0.5rem;
        }

        h3 {
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #8b5cf6;
        }

        p {
            margin-bottom: 1rem;
            color: #cbd5e1;
            font-size: 1.1rem;
        }

        .mermaid {
            background: #0f172a;
            border: 1px solid #475569;
            border-radius: 0.5rem;
            padding: 2rem;
            margin: 2rem 0;
            overflow-x: auto;
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .feature {
            background: #334155;
            border: 1px solid #475569;
            border-radius: 0.5rem;
            padding: 1.5rem;
            transition: all 0.2s;
        }

        .feature:hover {
            border-color: #3b82f6;
            transform: translateY(-4px);
            box-shadow: 0 10px 20px rgba(59, 130, 246, 0.3);
        }

        .feature h4 {
            color: #3b82f6;
            margin-bottom: 0.5rem;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            background: #3b82f6;
            color: white;
            border-radius: 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .badge.new {
            background: #10b981;
        }

        .badge.punch {
            background: #f59e0b;
        }

        code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            background: #334155;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.9em;
        }

        footer {
            text-align: center;
            padding: 2rem 0;
            margin-top: 4rem;
            border-top: 2px solid #334155;
            color: #64748b;
        }

        footer a {
            color: #3b82f6;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .container {
                padding: 1rem;
            }

            nav ul {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="emoji">üåµüìä</div>
            <h1>Minimact Architecture Diagrams</h1>
            <p class="subtitle">Visual documentation for Minimact and Minimact Punch</p>
        </header>

        <nav>
            <h2>üìë Quick Navigation</h2>
            <h3 style="color: #64748b; font-size: 0.875rem; margin-top: 1rem; margin-bottom: 0.5rem;">Core Diagrams</h3>
            <ul>
                <li><a href="#core-architecture">Core Architecture</a></li>
                <li><a href="#data-flow">Data Flow</a></li>
                <li><a href="#predictive-rendering">Predictive Rendering</a></li>
                <li><a href="#state-sync">State Synchronization <span class="badge new">NEW</span></a></li>
                <li><a href="#punch-architecture">Minimact Punch <span class="badge punch">üçπ</span></a></li>
                <li><a href="#integration">Integration Patterns</a></li>
                <li><a href="#system-overview">System Overview</a></li>
                <li><a href="#performance">Performance</a></li>
            </ul>
            <h3 style="color: #64748b; font-size: 0.875rem; margin-top: 1.5rem; margin-bottom: 0.5rem;">Deep Dives <span class="badge new">NEW</span></h3>
            <ul>
                <li><a href="#lifecycle">Component Lifecycle</a></li>
                <li><a href="#prediction-engine">Prediction Engine</a></li>
                <li><a href="#babel">Babel Transformation</a></li>
                <li><a href="#template-patches">üé® Template Patch System <span class="badge new">NEW</span></a></li>
                <li><a href="#plugin-system">üîå Plugin System Architecture <span class="badge new">NEW</span></a></li>
                <li><a href="#security">Security Model</a></li>
            </ul>
            <h3 style="color: #64748b; font-size: 0.875rem; margin-top: 1.5rem; margin-bottom: 0.5rem;">Developer Workflow <span class="badge new">NEW</span></h3>
            <ul>
                <li><a href="#dev-setup">Project Setup</a></li>
                <li><a href="#dev-loop">Development Loop</a></li>
                <li><a href="#hot-reload">Hot Reload System <span class="badge new">NEW</span></a></li>
                <li><a href="#code-behind">Code-Behind Pattern</a></li>
                <li><a href="#debugging">Debugging Tools</a></li>
                <li><a href="#integration-points">Integration Points</a></li>
            </ul>
        </nav>

        <section id="intro">
            <h2>About These Diagrams</h2>
            <p>
                This page contains comprehensive visual documentation for the Minimact architecture,
                showing how components interact, data flows, messaging patterns, and the integration
                of the Minimact Punch extension.
            </p>
            <div class="features">
                <div class="feature">
                    <h4>üéØ Core Architecture</h4>
                    <p>System components from TSX to DOM</p>
                </div>
                <div class="feature">
                    <h4>‚ö° Data Flows</h4>
                    <p>Request/response cycles and messaging</p>
                </div>
                <div class="feature">
                    <h4>üîÆ Predictions</h4>
                    <p>Cache hit/miss logic and hint queues</p>
                </div>
                <div class="feature">
                    <h4>üîÑ State Sync</h4>
                    <p>NEW auto-sync pattern preventing stale data</p>
                </div>
                <div class="feature">
                    <h4>üöÄ Lifecycle <span class="badge new">NEW</span></h4>
                    <p>Initial SSR through SignalR connection</p>
                </div>
                <div class="feature">
                    <h4>üß† Learning <span class="badge new">NEW</span></h4>
                    <p>Pattern detection and confidence scoring</p>
                </div>
                <div class="feature">
                    <h4>üîß Babel <span class="badge new">NEW</span></h4>
                    <p>TSX ‚Üí C# transformation with examples</p>
                </div>
                <div class="feature">
                    <h4>üîí Security <span class="badge new">NEW</span></h4>
                    <p>Multi-layer authorization and validation</p>
                </div>
                <div class="feature">
                    <h4>‚ö° Hot Reload <span class="badge new">NEW</span></h4>
                    <p>Template-based 3-5ms updates, 98% less memory</p>
                </div>
                <div class="feature">
                    <h4>üíª Developer Workflow <span class="badge new">NEW</span></h4>
                    <p>Setup, dev loop, debugging, integrations</p>
                </div>
            </div>
        </section>

        <section id="core-architecture">
            <h2>Minimact Core Architecture</h2>
            <p>
                System components showing all layers from TSX development to DOM rendering,
                including the Babel compilation pipeline, ASP.NET Core runtime, Rust reconciliation engine,
                and client-side SignalR integration.
            </p>
            <div class="mermaid">
graph TB
    subgraph "Developer Layer"
        TSX[TSX/JSX Components]
        TS[TypeScript]
    end

    subgraph "Compilation Layer"
        BABEL[Babel Plugin]
        CODEGEN[Code Generator]
    end

    subgraph "Server Runtime (.NET)"
        COMP[MinimactComponent]
        STATE[State Manager]
        RENDER[Render Engine]
        HUB[MinimactHub SignalR]
        RUST[Rust Reconciler FFI]
    end

    subgraph "Rust Engine"
        RECON[Reconciliation Engine]
        PRED[Prediction Engine]
        DIFF[VNode Differ]
    end

    subgraph "Client Runtime (Browser)"
        SIGNALR[SignalR Manager]
        PATCHER[DOM Patcher]
        HOOKS[Hook System]
        QUEUE[Hint Queue]
        BRIDGE[Playground Bridge]
    end

    subgraph "Client DOM"
        DOM[Browser DOM]
        EVENTS[Event Delegation]
    end

    TSX --> BABEL
    TS --> BABEL
    BABEL --> CODEGEN
    CODEGEN --> COMP

    COMP --> STATE
    STATE --> RENDER
    RENDER --> RUST
    RUST --> RECON
    RECON --> DIFF
    DIFF --> PRED

    PRED --> HUB
    RENDER --> HUB
    HUB --> SIGNALR

    SIGNALR --> PATCHER
    SIGNALR --> QUEUE
    PATCHER --> DOM
    QUEUE --> PATCHER

    HOOKS --> SIGNALR
    DOM --> EVENTS
    EVENTS --> SIGNALR

    PATCHER --> BRIDGE
    QUEUE --> BRIDGE
            </div>
        </section>

        <section id="data-flow">
            <h2>Complete Data Flow</h2>
            <p>
                Sequence diagram showing the complete request/response cycle, from initial render
                through predictive pre-caching to user interactions with both cache hits and misses.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant User
    participant DOM
    participant EventDel as Event Delegation
    participant SignalR as SignalR Manager
    participant Hub as MinimactHub
    participant Comp as Component
    participant Rust as Rust Engine
    participant Predictor
    participant Queue as Hint Queue
    participant Patcher as DOM Patcher

    Note over User,Patcher: Initial Render
    Comp->>Rust: Render() ‚Üí VNode
    Rust->>Rust: Generate patches
    Rust->>Hub: Send patches
    Hub->>SignalR: ApplyPatches
    SignalR->>Patcher: Apply to DOM
    Patcher->>DOM: Update elements

    Note over User,Patcher: Predictive Pre-Caching
    Predictor->>Rust: Predict state changes
    Rust->>Rust: Pre-compute patches
    Rust->>Hub: Send predictions
    Hub->>SignalR: QueueHint
    SignalR->>Queue: Cache patches
    Queue-->>Queue: Ready for instant use

    Note over User,Patcher: User Interaction (Cache Hit)
    User->>DOM: Click button
    DOM->>EventDel: Capture event
    EventDel->>Queue: Check for hint
    Queue-->>Queue: üü¢ CACHE HIT!
    Queue->>Patcher: Apply cached patches
    Patcher->>DOM: Instant update (0ms)
    EventDel->>SignalR: Notify server (background)
    SignalR->>Hub: InvokeComponentMethod
    Hub->>Comp: Call method
    Comp->>Comp: Update state
    Comp->>Rust: Re-render
    Rust->>Hub: Verify patches
    Hub->>SignalR: ApplyCorrection (if needed)

    Note over User,Patcher: User Interaction (Cache Miss)
    User->>DOM: Click button
    DOM->>EventDel: Capture event
    EventDel->>Queue: Check for hint
    Queue-->>Queue: üî¥ CACHE MISS
    EventDel->>SignalR: Invoke method
    SignalR->>Hub: InvokeComponentMethod
    Hub->>Comp: Call method
    Comp->>Comp: Update state
    Comp->>Rust: Re-render
    Rust->>Rust: Compute patches
    Rust->>Hub: Send patches
    Hub->>SignalR: ApplyPatches
    SignalR->>Patcher: Apply to DOM
    Patcher->>DOM: Update (~45ms latency)
            </div>
        </section>

        <section id="predictive-rendering">
            <h2>Predictive Rendering Pipeline</h2>
            <p>
                Flowchart showing how the prediction engine determines whether to send predictions,
                the confidence threshold, and the verification/correction flow.
            </p>
            <div class="mermaid">
flowchart TD
    START[Component State Change] --> PREDICT{Can Predict?}

    PREDICT -->|Yes| CONF{Confidence >= 0.7?}
    PREDICT -->|No| RENDER[Normal Render]

    CONF -->|Yes| SEND_PRED[Send Prediction Immediately]
    CONF -->|No| RENDER

    SEND_PRED --> CLIENT_CACHE[Client Caches Patches]
    CLIENT_CACHE --> APPLY_PRED[Apply Prediction Instantly]

    APPLY_PRED --> BG_RENDER[Background: Server Renders]
    RENDER --> BG_RENDER

    BG_RENDER --> RECON[Rust Reconciliation]
    RECON --> ACTUAL_PATCHES[Actual Patches]

    ACTUAL_PATCHES --> COMPARE{Prediction Match?}

    COMPARE -->|‚úÖ Match| NO_ACTION[No Action Needed]
    COMPARE -->|‚ùå Mismatch| CORRECTION[Send Correction]

    CORRECTION --> CLIENT_FIX[Client Applies Fix]

    style SEND_PRED fill:#90EE90
    style APPLY_PRED fill:#90EE90
    style NO_ACTION fill:#90EE90
    style CORRECTION fill:#FFB6C1
    style CLIENT_FIX fill:#FFB6C1
            </div>
        </section>

        <section id="state-sync">
            <h2>State Synchronization <span class="badge new">NEW</span></h2>
            <p>
                <strong>Critical Update:</strong> The new auto-sync pattern ensures client state changes
                are immediately synchronized to the server, preventing stale data issues that could cause
                the Rust reconciler to overwrite client updates.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant User
    participant Client as Client Hook (useState)
    participant SignalR as SignalR Manager
    participant Hub as MinimactHub
    participant Comp as MinimactComponent
    participant Rust as Rust Reconciler

    Note over User,Rust: NEW: Automatic State Sync

    User->>Client: setCount(5)
    Client->>Client: Update local state

    par Check Hint Queue
        Client->>Client: Check HintQueue
        alt Cache Hit
            Client->>Client: Apply cached patches (instant)
        else Cache Miss
            Client->>Client: No instant feedback
        end
    and Sync to Server
        Client->>SignalR: updateComponentState(componentId, "count", 5)
        SignalR->>Hub: UpdateComponentState
        Hub->>Comp: SetStateFromClient("count", 5)
        Comp->>Comp: Update internal state
        Comp->>Rust: TriggerRender()
        Rust->>Rust: Compute patches
        Rust->>Hub: Patches ready
        Hub->>SignalR: ApplyPatches (verification)
        SignalR->>Client: Patches applied
    end

    Note over User,Rust: Result: Server always has correct state!
            </div>
        </section>

        <section id="punch-architecture">
            <h2>Minimact Punch Architecture <span class="badge punch">üçπ</span></h2>
            <p>
                <code>useDomElementState</code> integration showing how DOM observers
                feed into the reactive state system, enabling DOM-driven predictions.
            </p>
            <div class="mermaid">
graph TB
    subgraph "Client Runtime"
        HOOK[useDomElementState hook]
        STATE[DomElementState class]
        OBSERVERS[Browser Observers]
        SNAPSHOT[State Snapshot]
    end

    subgraph "Observers Layer"
        INTERSECT[IntersectionObserver]
        MUTATION[MutationObserver]
        RESIZE[ResizeObserver]
    end

    subgraph "Reactive Properties"
        PROPS["Properties
        - isIntersecting
        - childrenCount
        - attributes
        - classList"]
        COLLECTION["Collection Methods
        - every
        - some
        - filter"]
        STATS["Statistics
        - vals.avg
        - vals.sum
        - vals.median"]
    end

    subgraph "Integration"
        CONTEXT[ComponentContext]
        HINTQUEUE[HintQueue]
        SIGNALR[SignalR Manager]
        PATCHER[DOM Patcher]
    end

    subgraph "Server Side"
        CSHARP[C# DomElementStateHook]
        HUB[MinimactHub]
        PREDICTOR[Prediction Engine]
    end

    HOOK --> STATE
    STATE --> OBSERVERS

    OBSERVERS --> INTERSECT
    OBSERVERS --> MUTATION
    OBSERVERS --> RESIZE

    INTERSECT --> SNAPSHOT
    MUTATION --> SNAPSHOT
    RESIZE --> SNAPSHOT

    SNAPSHOT --> PROPS
    SNAPSHOT --> COLLECTION
    SNAPSHOT --> STATS

    STATE --> CONTEXT
    CONTEXT --> HINTQUEUE
    CONTEXT --> SIGNALR
    CONTEXT --> PATCHER

    SIGNALR --> HUB
    HUB --> CSHARP
    CSHARP --> PREDICTOR
    PREDICTOR --> HINTQUEUE
            </div>
        </section>

        <section id="integration">
            <h2>Integration Patterns</h2>
            <p>
                Hook integration showing the symmetry between <code>useState</code> and
                <code>useDomElementState</code>, both following the same MES-compliant pattern.
            </p>
            <div class="mermaid">
flowchart LR
    subgraph "Component Context"
        STATE_MAP[state: Map]
        EFFECTS[effects: Array]
        REFS[refs: Map]
        DOM_STATES[domElementStates: Map]
        HINT_QUEUE[hintQueue: HintQueue]
        DOM_PATCHER[domPatcher: DOMPatcher]
        SIGNALR_MGR[signalR: SignalRManager]
    end

    subgraph "Hooks"
        USE_STATE[useState]
        USE_EFFECT[useEffect]
        USE_REF[useRef]
        USE_DOM[useDomElementState]
    end

    subgraph "Symmetry"
        PATTERN[Same Pattern:<br/>1. Index tracking<br/>2. Context integration<br/>3. HintQueue check<br/>4. Server sync<br/>5. Cleanup]
    end

    USE_STATE --> STATE_MAP
    USE_EFFECT --> EFFECTS
    USE_REF --> REFS
    USE_DOM --> DOM_STATES

    USE_STATE --> HINT_QUEUE
    USE_DOM --> HINT_QUEUE

    USE_STATE --> SIGNALR_MGR
    USE_DOM --> SIGNALR_MGR

    STATE_MAP --> PATTERN
    DOM_STATES --> PATTERN

    style USE_DOM fill:#FFD700
    style DOM_STATES fill:#FFD700
    style PATTERN fill:#90EE90
            </div>
        </section>

        <section id="system-overview">
            <h2>Complete System Overview</h2>
            <p>
                End-to-end architecture showing all components from developer experience
                through build-time compilation, server runtime, Rust engine, SignalR layer,
                client runtime, and Minimact Punch extension.
            </p>
            <div class="mermaid">
graph TB
    subgraph "Developer Experience"
        DEV[Developer writes TSX]
        IDE[TypeScript IntelliSense]
    end

    subgraph "Build Time"
        BABEL[Babel Plugin]
        CODEGEN[Code Generator]
        CSHARP[C# Classes]
    end

    subgraph "Server Runtime"
        ASPNET[ASP.NET Core]
        COMPONENT[MinimactComponent]
        STATEMGR[State Manager]
        HOOKS_CS[C# Hook Implementations]
    end

    subgraph "Rust Engine"
        FFI[FFI Bridge]
        RECONCILER[Reconciliation Engine]
        PREDICTOR[Prediction Engine]
        VNODE[VNode Differ]
    end

    subgraph "SignalR Layer"
        HUB[MinimactHub]
        CONNECTION[SignalR Connection]
    end

    subgraph "Client Runtime"
        SIGNALR_CLIENT[SignalR Manager]
        HOOKS_TS[TypeScript Hooks]
        CONTEXT[Component Context]
        HINTQUEUE[Hint Queue]
        PATCHER[DOM Patcher]
        PLAYGROUND[Playground Bridge]
    end

    subgraph "minimact-punch Extension"
        DOM_STATE[DomElementState]
        OBSERVERS[DOM Observers]
        STATS[Statistical Engine]
        INTEGRATION[Integration Layer]
    end

    subgraph "Browser"
        DOM[DOM]
        EVENTS[Event System]
        WEB_APIS[Web APIs]
    end

    DEV --> BABEL
    IDE --> DEV
    BABEL --> CODEGEN
    CODEGEN --> CSHARP
    CSHARP --> COMPONENT

    COMPONENT --> STATEMGR
    COMPONENT --> HOOKS_CS
    STATEMGR --> FFI
    HOOKS_CS --> FFI

    FFI --> RECONCILER
    FFI --> PREDICTOR
    RECONCILER --> VNODE
    PREDICTOR --> VNODE

    VNODE --> HUB
    COMPONENT --> HUB
    HUB --> CONNECTION

    CONNECTION --> SIGNALR_CLIENT
    SIGNALR_CLIENT --> HOOKS_TS
    SIGNALR_CLIENT --> HINTQUEUE

    HOOKS_TS --> CONTEXT
    CONTEXT --> PATCHER
    CONTEXT --> PLAYGROUND

    HINTQUEUE --> PATCHER
    PATCHER --> DOM

    INTEGRATION --> HOOKS_TS
    INTEGRATION --> CONTEXT
    DOM_STATE --> OBSERVERS
    OBSERVERS --> WEB_APIS
    DOM_STATE --> STATS
    STATS --> INTEGRATION

    DOM --> EVENTS
    EVENTS --> SIGNALR_CLIENT
    WEB_APIS --> DOM

    style DOM_STATE fill:#FFD700
    style INTEGRATION fill:#FFD700
    style OBSERVERS fill:#FFD700
    style STATS fill:#FFD700
            </div>
        </section>

        <section id="performance">
            <h2>Performance Characteristics</h2>
            <p>
                Latency comparison showing the performance benefits of cache hits in both
                traditional Minimact and Minimact Punch scenarios.
            </p>
            <div class="features">
                <div class="feature">
                    <h4>Traditional SSR</h4>
                    <p>~52ms total latency (network round-trip + processing)</p>
                </div>
                <div class="feature">
                    <h4>Minimact Cache Hit</h4>
                    <p>~2ms total latency (instant patch application)</p>
                </div>
                <div class="feature">
                    <h4>Minimact Cache Miss</h4>
                    <p>~52ms total latency (falls back to server render)</p>
                </div>
                <div class="feature">
                    <h4>Minimact Punch Hit</h4>
                    <p>~2ms total latency (DOM observer + instant patch)</p>
                </div>
            </div>
        </section>

        <section id="lifecycle">
            <h2>Component Lifecycle & Initial Load</h2>
            <h3>Initial Page Load Flow</h3>
            <p>
                How does the initial page load work? This diagram shows the progression from
                SSR ‚Üí HTML ‚Üí SignalR connection upgrade, demonstrating how the page works
                <strong>without JavaScript</strong> and is progressively enhanced <strong>with JavaScript</strong>.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Browser
    participant Server as ASP.NET Core
    participant Rust as Rust Engine
    participant Component
    participant SignalR as SignalR Hub
    participant Client as Client Runtime

    Note over Browser,Client: 1. Initial SSR (No JavaScript Yet)
    Browser->>Server: HTTP GET /page
    Server->>Component: Create instance
    Component->>Component: OnInitializedAsync()
    Component->>Rust: Render() ‚Üí VNode
    Rust->>Rust: Generate HTML
    Rust->>Server: HTML string
    Server->>Browser: Return HTML page
    Browser->>Browser: Display HTML immediately

    Note over Browser,Client: 2. Progressive Enhancement (JavaScript Loads)
    Browser->>Browser: Parse & execute ~5KB client.js
    Browser->>Client: Initialize Minimact client
    Client->>SignalR: Establish WebSocket connection

    Note over Browser,Client: 3. Component Registration
    SignalR->>Server: Connection established
    Server->>SignalR: Assign ConnectionId
    Client->>Client: Query DOM for [data-component-id]
    Client->>SignalR: RegisterComponent(componentId)
    SignalR->>Server: Store mapping: ConnectionId ‚Üí ComponentId
    Server->>Component: Attach connection to instance

    Note over Browser,Client: 4. Ready State
    Component->>Rust: Generate initial predictions
    Rust->>SignalR: QueueHint messages
    SignalR->>Client: Cache predictions
    Client->>Client: System ready - instant interactions enabled

    Note over Browser,Client: Result: Page works WITHOUT JS, enhanced WITH JS
            </div>

            <h3>Component ID Tracking</h3>
            <p>
                Components are identified and tracked between server and client using GUIDs
                embedded in <code>data-component-id</code> attributes.
            </p>
            <div class="mermaid">
graph LR
    subgraph "Server-Side Rendering"
        COMP[Component Instance]
        ID[Generate GUID]
        HTML[Rendered HTML]
    end

    subgraph "HTML Output"
        ATTR[data-component-id attribute]
    end

    subgraph "Client-Side Discovery"
        DOM[DOM Query]
        MAP[ComponentId ‚Üí Element Map]
    end

    subgraph "Server Registry"
        REGISTRY[Component Registry]
        CONN[ConnectionId ‚Üí Component Map]
    end

    COMP --> ID
    ID --> ATTR
    ATTR --> HTML

    HTML --> DOM
    DOM --> MAP

    MAP --> REGISTRY
    REGISTRY --> CONN

    style ATTR fill:#FFD700
    style MAP fill:#90EE90
            </div>
        </section>

        <section id="prediction-engine">
            <h2>Prediction Engine Deep Dive</h2>
            <h3>Learning & Pattern Detection</h3>
            <p>
                The prediction engine learns patterns through frequency analysis, sequence detection,
                and conditional pattern recognition. It assigns confidence scores and only sends
                predictions with ‚â•70% confidence.
            </p>
            <div class="mermaid">
flowchart TD
    START[User Interaction] --> RECORD[Record to History]

    RECORD --> PATTERN{Pattern Analysis}

    PATTERN -->|Frequency Analysis| FREQ[Track state change frequency]
    PATTERN -->|Sequence Detection| SEQ[Detect interaction sequences]
    PATTERN -->|Conditional Patterns| COND[Learn conditional branches]

    FREQ --> CONFIDENCE[Calculate Confidence Score]
    SEQ --> CONFIDENCE
    COND --> CONFIDENCE

    CONFIDENCE --> THRESHOLD{Confidence >= 0.7?}

    THRESHOLD -->|Yes| GENERATE[Generate Prediction]
    THRESHOLD -->|No| SKIP[Skip prediction]

    GENERATE --> PRECOMPUTE[Pre-compute patches]
    PRECOMPUTE --> QUEUE[Queue to client]

    QUEUE --> MEASURE[Measure accuracy on use]
    MEASURE --> FEEDBACK[Adjust confidence weights]
    FEEDBACK --> PATTERN

    SKIP --> END[End]

    style GENERATE fill:#90EE90
    style QUEUE fill:#90EE90
    style CONFIDENCE fill:#FFD700
            </div>

            <h3>Prediction Triggers</h3>
            <p>
                Three types of triggers: explicit <code>usePredictHint</code>, automatic pattern learning,
                and user behavior patterns (e.g., hover ‚Üí click probability).
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Dev as Developer
    participant Comp as Component
    participant Pred as Prediction Engine
    participant Rust as Rust Reconciler
    participant Queue as Hint Queue

    Note over Dev,Queue: Trigger 1: Explicit usePredictHint
    Dev->>Comp: usePredictHint('increment', {count: count+1})
    Comp->>Pred: Register hint
    Pred->>Rust: Compute patches for predicted state
    Rust->>Pred: Return patches
    Pred->>Queue: QueueHint(hintId, patches, confidence: 1.0)

    Note over Dev,Queue: Trigger 2: Automatic Pattern Learning
    Comp->>Comp: setState(newValue)
    Comp->>Pred: Notify state change
    Pred->>Pred: Analyze historical patterns
    Pred->>Pred: Detect: "count always increments by 1"
    Pred->>Rust: Compute patches for likely next state
    Rust->>Pred: Return patches
    Pred->>Queue: QueueHint(hintId, patches, confidence: 0.85)

    Note over Dev,Queue: Trigger 3: User Behavior Patterns
    Comp->>Pred: Track: User hovered button for 500ms
    Pred->>Pred: Pattern: Hover ‚Üí Click (78% probability)
    Pred->>Rust: Pre-compute click result
    Rust->>Pred: Return patches
    Pred->>Queue: QueueHint(hintId, patches, confidence: 0.78)

    Note over Dev,Queue: Accuracy Feedback Loop
    Queue->>Queue: User clicked ‚Üí Check cache
    Queue->>Pred: Report: Hit/Miss + actual state
    Pred->>Pred: Update pattern weights
            </div>
        </section>

        <section id="babel">
            <h2>Babel Plugin Transformation</h2>
            <h3>TSX to C# Example</h3>
            <p>
                Concrete before/after example showing how TypeScript/JSX transforms into C# with VNode trees.
            </p>
            <div style="background: #0f172a; border: 1px solid #475569; border-radius: 0.5rem; padding: 1.5rem; margin: 1.5rem 0;">
                <h4 style="color: #3b82f6; margin-bottom: 1rem;">Input (Counter.tsx):</h4>
                <pre style="background: #1e293b; padding: 1rem; border-radius: 0.25rem; overflow-x: auto; margin: 0;"><code style="color: #e2e8f0; font-family: monospace; font-size: 0.9rem;">import { useState } from 'minimact';

export function Counter() {
    const [count, setCount] = useState(0);

    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;
                Increment
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
            </div>

            <div style="background: #0f172a; border: 1px solid #475569; border-radius: 0.5rem; padding: 1.5rem; margin: 1.5rem 0;">
                <h4 style="color: #10b981; margin-bottom: 1rem;">Output (Counter.cs):</h4>
                <pre style="background: #1e293b; padding: 1rem; border-radius: 0.25rem; overflow-x: auto; margin: 0;"><code style="color: #e2e8f0; font-family: monospace; font-size: 0.9rem;">using Minimact.AspNetCore.Core;
using Minimact.AspNetCore.VNodes;

namespace MyApp.Components
{
    public partial class Counter : MinimactComponent
    {
        [State]
        private int count = 0;

        protected override VNode Render()
        {
            return new VElement("div",
                new VElement("p", $"Count: {count}"),
                new VElement("button",
                    new VAttribute("onClick", nameof(Increment)),
                    "Increment"
                )
            );
        }

        private void Increment()
        {
            count++;
            SetState(nameof(count), count);
        }
    }
}</code></pre>
            </div>

            <h3>Transformation Pipeline</h3>
            <div class="mermaid">
flowchart TD
    START[Counter.tsx] --> PARSE[Babel Parse AST]

    PARSE --> DETECT[Detect Hooks]
    DETECT --> HOOK_STATE{Hook Type?}

    HOOK_STATE -->|useState| GEN_STATE[Generate State field]
    HOOK_STATE -->|useEffect| GEN_EFFECT[Generate lifecycle method]
    HOOK_STATE -->|useRef| GEN_REF[Generate private field]

    GEN_STATE --> TRACK_DEPS[Track dependencies]
    GEN_EFFECT --> TRACK_DEPS
    GEN_REF --> TRACK_DEPS

    TRACK_DEPS --> JSX[Parse JSX]
    JSX --> BUILD_VNODE[Build VNode tree]

    BUILD_VNODE --> EVENTS{Event Handlers?}
    EVENTS -->|Yes| GEN_METHODS[Generate C# methods]
    EVENTS -->|No| CONTINUE

    GEN_METHODS --> CONTINUE[Continue]
    CONTINUE --> TYPE_MAP[Map TS types to C# types]

    TYPE_MAP --> OUTPUT[Generate Counter.cs]

    style GEN_STATE fill:#90EE90
    style BUILD_VNODE fill:#FFD700
    style OUTPUT fill:#3b82f6
            </div>
        </section>

        <section id="template-patches">
            <h2>üé® Template Patch System <span class="badge new">NEW</span></h2>
            <h3>Build-Time Template Generation</h3>
            <p>
                The Template Patch System revolutionizes predictive rendering by generating parameterized patch templates
                at build time through Babel AST analysis. This provides <strong>100% coverage</strong> of all possible state
                values with <strong>zero learning phase</strong>.
            </p>
            <div class="mermaid">
flowchart TD
    TSX[Counter.tsx] --> BABEL[Babel Plugin]
    BABEL --> AST[Parse JSX AST]

    AST --> ANALYZE[Analyze JSX Expressions]
    ANALYZE --> DETECT{Dynamic Content?}

    DETECT -->|Static| STATIC[Static Template<br/>No bindings]
    DETECT -->|Dynamic| DYNAMIC[Dynamic Template<br/>Extract bindings]

    DYNAMIC --> SLOTS[Identify Slot Positions<br/>'Count: {0}']
    SLOTS --> BINDINGS[Record State Bindings<br/>bindings: ['count']]

    BINDINGS --> COND{Conditional?}
    COND -->|Yes| COND_TEMPLATE[Conditional Template<br/>true: '‚úì', false: '‚óã']
    COND -->|No| SIMPLE_TEMPLATE[Simple Template<br/>template: '{0}']

    STATIC --> TEMPLATE_JSON
    SIMPLE_TEMPLATE --> TEMPLATE_JSON
    COND_TEMPLATE --> TEMPLATE_JSON[Counter.templates.json]

    TEMPLATE_JSON --> CSHARP[Counter.cs with<br/>[LoopTemplate] attributes]

    style BABEL fill:#3b82f6
    style TEMPLATE_JSON fill:#10b981
    style CSHARP fill:#8b5cf6
            </div>

            <h3>Template Types & Examples</h3>
            <div style="background: #0f172a; border: 1px solid #475569; border-radius: 0.5rem; padding: 1.5rem; margin: 1.5rem 0;">
                <h4 style="color: #3b82f6; margin-bottom: 1rem;">1. Static Template (No bindings)</h4>
                <pre style="background: #1e293b; padding: 1rem; border-radius: 0.25rem; overflow-x: auto; margin-bottom: 1rem;"><code style="color: #e2e8f0; font-family: monospace; font-size: 0.9rem;">&lt;h1&gt;Welcome to Minimact&lt;/h1&gt;

// Template:
{
  "type": "static",
  "template": "Welcome to Minimact",
  "bindings": []
}</code></pre>

                <h4 style="color: #10b981; margin-bottom: 1rem;">2. Dynamic Template with Slots</h4>
                <pre style="background: #1e293b; padding: 1rem; border-radius: 0.25rem; overflow-x: auto; margin-bottom: 1rem;"><code style="color: #e2e8f0; font-family: monospace; font-size: 0.9rem;">&lt;p&gt;Count: {count}&lt;/p&gt;

// Template:
{
  "type": "dynamic",
  "template": "Count: {0}",
  "bindings": ["count"],
  "slots": [{ "index": 0, "binding": "count" }]
}</code></pre>

                <h4 style="color: #8b5cf6; margin-bottom: 1rem;">3. Conditional Template</h4>
                <pre style="background: #1e293b; padding: 1rem; border-radius: 0.25rem; overflow-x: auto; margin-bottom: 1rem;"><code style="color: #e2e8f0; font-family: monospace; font-size: 0.9rem;">&lt;span&gt;{todo.done ? '‚úì' : '‚óã'}&lt;/span&gt;

// Template:
{
  "type": "conditional",
  "template": "{0}",
  "bindings": ["item.done"],
  "conditionalTemplates": {
    "true": "‚úì",
    "false": "‚óã"
  }
}</code></pre>

                <h4 style="color: #f59e0b; margin-bottom: 1rem;">4. Loop Template (Most Powerful)</h4>
                <pre style="background: #1e293b; padding: 1rem; border-radius: 0.25rem; overflow-x: auto;"><code style="color: #e2e8f0; font-family: monospace; font-size: 0.9rem;">{todos.map(todo => &lt;li&gt;{todo.text}&lt;/li&gt;)}

// C# Attribute:
[LoopTemplate(
    itemsBinding: "todos",
    template: "&lt;li&gt;{0}&lt;/li&gt;",
    bindings: ["item.text"]
)]</code></pre>
            </div>

            <h3>Runtime: Template Filling Flow</h3>
            <p>
                At runtime, when state changes, the client fills template slots with actual values for instant updates.
                No server round-trip needed!
            </p>
            <div class="mermaid">
sequenceDiagram
    participant User
    participant Client
    participant Templates as Template Cache
    participant DOM
    participant SignalR
    participant Server

    Note over User,Server: Initial Page Load

    Server->>Server: Render() ‚Üí VNode tree
    Server->>Server: Extract templates from<br/>[LoopTemplate] attributes
    Server->>Templates: Send all templates<br/>+ initial state
    Templates->>Templates: Cache templates by<br/>componentId + nodePath

    Note over User,Server: User Interaction (Instant Update)

    User->>Client: Click "Increment"
    Client->>Client: useState: setCount(count + 1)
    Client->>Templates: getTemplate(componentId, nodePath)
    Templates-->>Client: { template: "Count: {0}", bindings: ["count"] }

    Client->>Client: Fill slots:<br/>"Count: {0}" ‚Üí "Count: 5"
    Client->>DOM: Update text node
    Note right of DOM: ‚ú® 0ms! Instant update

    Client->>SignalR: updateComponentState("count", 5)
    SignalR->>Server: Sync state
    Server->>Server: SetStateFromClient("count", 5)
    Note right of Server: Server state in sync!<br/>Prevents stale data

    Note over User,Server: Complex State Change (Server Render)

    User->>Client: Add new todo item
    Client->>SignalR: invokeMethod("addTodo", ...)
    SignalR->>Server: Execute addTodo()
    Server->>Server: todos.Add(newTodo)
    Server->>Server: Render() ‚Üí New VNode
    Server->>Server: Rust reconciler diffs
    Server->>Client: Send patches
    Client->>DOM: Apply patches
    Note right of DOM: Server handles<br/>complex logic
            </div>

            <h3>Template vs Hint Queue Comparison</h3>
            <div class="mermaid">
graph TB
    subgraph "OLD: Hint Queue System"
        A1[User Action] --> B1[Server pre-computes<br/>specific predictions]
        B1 --> C1[Cache patches for<br/>count=0‚Üí1, count=1‚Üí2, etc.]
        C1 --> D1[Limited coverage<br/>N predicted values]
        D1 --> E1[Learning phase required]
        E1 --> F1[Cache misses possible]
    end

    subgraph "NEW: Template Patch System"
        A2[Build Time] --> B2[Babel extracts templates<br/>from JSX AST]
        B2 --> C2[Single parameterized template<br/>'Count: {0}']
        C2 --> D2[100% coverage<br/>ALL possible values]
        D2 --> E2[Zero learning phase]
        E2 --> F2[No cache misses ever]
    end

    style A1 fill:#fca5a5
    style F1 fill:#fca5a5
    style A2 fill:#86efac
    style F2 fill:#86efac
            </div>
        </section>

        <section id="plugin-system">
            <h2>üîå Plugin System Architecture <span class="badge new">NEW</span></h2>
            <h3>Overview</h3>
            <p>
                Minimact's Plugin System enables 100% server-side plugins distributed as NuGet packages.
                Plugins have <strong>zero client bundle overhead</strong> and leverage the Template Patch System
                for instant client updates.
            </p>
            <div class="mermaid">
flowchart TD
    subgraph "Plugin Development"
        A[Create C# Class] --> B[Implement IMinimactPlugin]
        B --> C[Add [MinimactPlugin] attribute]
        C --> D[Define state interface/class]
        D --> E[Implement Render method]
        E --> F[Add embedded assets<br/>CSS, JS, images]
        F --> G[Package as NuGet]
    end

    subgraph "Plugin Distribution"
        G --> H[Publish to NuGet.org]
        H --> I[Developer: dotnet add package]
    end

    subgraph "Plugin Discovery"
        I --> J[App starts]
        J --> K[PluginManager.AutoDiscover]
        K --> L[Scan assemblies for<br/>[MinimactPlugin]]
        L --> M[Register plugins]
        M --> N[Load embedded assets]
    end

    subgraph "Runtime Usage"
        N --> O[&lt;Plugin name='Clock' state={...} /&gt;]
        O --> P[Babel transforms to<br/>new PluginNode]
        P --> Q[Server renders plugin]
        Q --> R[Client applies templates]
    end

    style G fill:#3b82f6
    style H fill:#10b981
    style M fill:#8b5cf6
    style R fill:#f59e0b
            </div>

            <h3>Plugin Rendering Flow</h3>
            <p>
                From JSX to rendered output, showing how plugins integrate seamlessly with Minimact's architecture.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Dev as Developer
    participant Babel as Babel Plugin
    participant Server as ASP.NET Server
    participant PluginMgr as PluginManager
    participant Plugin as Clock Plugin
    participant Rust as Rust Reconciler
    participant Client as Browser

    Note over Dev,Client: Build Time

    Dev->>Babel: &lt;Plugin name="Clock" state={time} /&gt;
    Babel->>Babel: Detect Plugin JSX tag
    Babel->>Babel: Transform to C# code:<br/>new PluginNode("Clock", stateObj)
    Babel->>Server: Generate Component.cs

    Note over Dev,Client: Runtime - Initial Render

    Client->>Server: Request page
    Server->>Server: Component.Render()
    Server->>Server: VNode tree includes<br/>PluginNode("Clock", {...})

    Server->>PluginMgr: RenderPlugin("Clock", state)
    PluginMgr->>PluginMgr: Validate state schema
    PluginMgr->>Plugin: Plugin.Render(state)
    Plugin-->>PluginMgr: VNode tree<br/>(div > h2 + p)
    PluginMgr-->>Server: VNode tree

    Server->>Rust: Reconcile(oldVNode, newVNode)
    Rust-->>Server: DOM patches
    Server->>Client: Send patches + templates
    Client->>Client: Apply patches
    Client->>Client: Cache plugin templates

    Note over Dev,Client: State Update

    Client->>Client: time changes (1:23 ‚Üí 1:24)
    Client->>Client: Template filling:<br/>"{0}:{1} {2}" with [1,24,"PM"]
    Client->>Client: Update DOM instantly
    Note right of Client: 0ms update!<br/>No server needed

    Client->>Server: updateComponentState("time", ...)
    Server->>Server: Keep state in sync
            </div>

            <h3>Plugin Asset Serving</h3>
            <p>
                Plugins can include CSS, JavaScript, images, and fonts as embedded resources,
                served automatically with versioning and caching.
            </p>
            <div class="mermaid">
flowchart TD
    A[Plugin has embedded assets] --> B[PluginAssetMiddleware]
    B --> C{Request matches<br/>/plugin-assets/...?}

    C -->|No| D[Next middleware]
    C -->|Yes| E[Parse URL]

    E --> F{Version specified?}
    F -->|Yes| G[Get plugin by<br/>name + version]
    F -->|No| H[Get latest version]

    G --> I{Plugin found?}
    H --> I

    I -->|No| J[404 Not Found]
    I -->|Yes| K[Find embedded resource]

    K --> L{Resource found?}
    L -->|No| J
    L -->|Yes| M[Set Content-Type]

    M --> N[Set Cache headers<br/>max-age=86400]
    N --> O[Set ETag]
    O --> P[Stream resource bytes]

    style B fill:#3b82f6
    style K fill:#10b981
    style P fill:#8b5cf6
            </div>

            <h3>Plugin Example: Clock Widget</h3>
            <div style="background: #0f172a; border: 1px solid #475569; border-radius: 0.5rem; padding: 1.5rem; margin: 1.5rem 0;">
                <h4 style="color: #3b82f6; margin-bottom: 1rem;">Plugin Implementation (ClockPlugin.cs):</h4>
                <pre style="background: #1e293b; padding: 1rem; border-radius: 0.25rem; overflow-x: auto;"><code style="color: #e2e8f0; font-family: monospace; font-size: 0.9rem;">[MinimactPlugin("Clock", "1.0.0")]
public class ClockPlugin : MinimactPlugin&lt;ClockState&gt;
{
    public override string Name => "Clock";
    public override string Version => "1.0.0";

    [LoopTemplate(
        template: "&lt;div class='clock'&gt;&lt;h2&gt;{0}:{1}&lt;/h2&gt;&lt;p&gt;{2}&lt;/p&gt;&lt;/div&gt;",
        bindings: ["hours", "minutes", "period"]
    )]
    public override VNode Render(ClockState state)
    {
        return new VElement("div",
            new VAttribute("class", "clock"),
            new VElement("h2", $"{state.Hours}:{state.Minutes:D2}"),
            new VElement("p", state.Period)
        );
    }

    public override IEnumerable&lt;PluginAsset&gt; GetAssets()
    {
        yield return new PluginAsset(
            "clock-widget.css",
            PluginAssetType.Stylesheet
        );
    }
}

public class ClockState
{
    public int Hours { get; set; }
    public int Minutes { get; set; }
    public string Period { get; set; } // "AM" or "PM"
}</code></pre>

                <h4 style="color: #10b981; margin-bottom: 1rem; margin-top: 1.5rem;">Usage in Component (Dashboard.tsx):</h4>
                <pre style="background: #1e293b; padding: 1rem; border-radius: 0.25rem; overflow-x: auto;"><code style="color: #e2e8f0; font-family: monospace; font-size: 0.9rem;">export function Dashboard() {
    const [time, setTime] = useState({ hours: 1, minutes: 23, period: 'PM' });

    return (
        &lt;div&gt;
            &lt;h1&gt;Dashboard&lt;/h1&gt;
            &lt;Plugin name="Clock" state={time} /&gt;
        &lt;/div&gt;
    );
}</code></pre>
            </div>

            <h3>Plugin Discovery & Registration</h3>
            <p>
                PluginManager automatically discovers plugins at startup or supports explicit registration
                for fine-grained control.
            </p>
            <div class="mermaid">
flowchart TD
    START[App Startup] --> CONFIG{Configuration?}

    CONFIG -->|Auto-Discovery| AUTO[PluginManager.AutoDiscover]
    CONFIG -->|Explicit| EXPLICIT[options.RegisterPlugin&lt;T&gt;]

    AUTO --> SCAN[Scan all loaded assemblies]
    SCAN --> FIND[Find types with<br/>[MinimactPlugin] attribute]
    FIND --> INSTANTIATE[ActivatorUtilities.CreateInstance]

    EXPLICIT --> INSTANTIATE

    INSTANTIATE --> INIT[plugin.Initialize]
    INIT --> VALIDATE[Validate metadata]
    VALIDATE --> SCHEMA[Generate JSON Schema<br/>from state type]
    SCHEMA --> ASSETS[Discover embedded assets]
    ASSETS --> REGISTER[Add to plugin registry]
    REGISTER --> READY[Plugin ready]

    READY --> USAGE[&lt;Plugin name="..." /&gt;]

    style AUTO fill:#3b82f6
    style EXPLICIT fill:#8b5cf6
    style READY fill:#10b981
            </div>

            <h3>Multi-Version Plugin Support</h3>
            <p>
                Multiple versions of the same plugin can coexist, with semver-based compatibility checking.
            </p>
            <div class="mermaid">
graph TB
    subgraph "Plugin Registry"
        A[Clock@1.0.0] --> R[Registry]
        B[Clock@1.2.0] --> R
        C[Clock@2.0.0] --> R
    end

    subgraph "Component Requests"
        D[&lt;Plugin name='Clock' /&gt;] --> E{GetLatestVersion}
        F[&lt;Plugin name='Clock' version='1.x' /&gt;] --> G{GetLatestCompatible}
        H[&lt;Plugin name='Clock' version='1.2.0' /&gt;] --> I{GetExactVersion}
    end

    E --> C
    G --> B
    I --> B

    C --> J[Render with Clock@2.0.0]
    B --> K[Render with Clock@1.2.0]

    style R fill:#3b82f6
    style C fill:#10b981
    style B fill:#10b981
            </div>
        </section>

        <section id="security">
            <h2>Security & Authorization Model</h2>
            <h3>Method Invocation Security</h3>
            <p>
                Multi-layer security ensures only authenticated, authorized users can invoke
                component methods with validated parameters.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Client
    participant SignalR as SignalR Hub
    participant Auth as Authorization
    participant Registry as Component Registry
    participant Comp as Component

    Note over Client,Comp: Secure Method Invocation Flow

    Client->>SignalR: InvokeComponentMethod(componentId, "UpdateProfile", args)

    SignalR->>Auth: ValidateConnection()
    Auth->>Auth: Check User.Identity
    Auth->>Auth: Verify ConnectionId is authenticated

    alt Not Authenticated
        Auth->>Client: 401 Unauthorized
    end

    SignalR->>Registry: GetComponent(componentId)

    alt Component Not Found
        Registry->>Client: Error: Component not found
    end

    Registry->>Registry: Verify component belongs to this connection

    alt Wrong Connection
        Registry->>Client: Error: Unauthorized access
    end

    SignalR->>Comp: Check [Authorize] attribute on method

    alt Has [Authorize(Roles="Admin")]
        Comp->>Auth: Check User.IsInRole("Admin")
        Auth-->>Comp: False
        Comp->>Client: Error: Forbidden
    end

    Comp->>Comp: Validate method parameters

    alt Invalid Parameters
        Comp->>Client: Error: Validation failed
    end

    Comp->>Comp: Invoke method via reflection
    Comp->>Comp: Update state
    Comp->>Client: Success
            </div>

            <h3>State Validation Flow</h3>
            <p>
                All client state updates go through type checking, range validation,
                sanitization, and custom validators before being applied.
            </p>
            <div class="mermaid">
flowchart TD
    START[Client sends UpdateComponentState] --> AUTH{User Authenticated?}

    AUTH -->|No| REJECT1[Reject: 401 Unauthorized]
    AUTH -->|Yes| OWNER{Owns Component?}

    OWNER -->|No| REJECT2[Reject: 403 Forbidden]
    OWNER -->|Yes| VALIDATE[Validate State Value]

    VALIDATE --> TYPE{Type Valid?}
    TYPE -->|No| REJECT3[Reject: Invalid type]
    TYPE -->|Yes| RANGE{Range Valid?}

    RANGE -->|No| REJECT4[Reject: Out of range]
    RANGE -->|Yes| SANITIZE[Sanitize Input]

    SANITIZE --> CUSTOM{Custom Validator?}
    CUSTOM -->|Yes| RUN_VALIDATOR[Run validation logic]
    CUSTOM -->|No| APPLY

    RUN_VALIDATOR --> VALID{Valid?}
    VALID -->|No| REJECT5[Reject: Custom validation failed]
    VALID -->|Yes| APPLY[Apply state change]

    APPLY --> LOG[Log change for audit]
    LOG --> SUCCESS[Success]

    style REJECT1 fill:#FFB6C1
    style REJECT2 fill:#FFB6C1
    style REJECT3 fill:#FFB6C1
    style REJECT4 fill:#FFB6C1
    style REJECT5 fill:#FFB6C1
    style SUCCESS fill:#90EE90
            </div>

            <h3>Attack Prevention Examples</h3>
            <p>
                Demonstrating how the security layers block malicious state updates, unauthorized
                component access, and protected method invocation attempts.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Attacker as Malicious Client
    participant SignalR
    participant Validator
    participant Component

    Note over Attacker,Component: Attack Attempt: Send Invalid State

    Attacker->>SignalR: UpdateComponentState("count", 999999999)

    SignalR->>Validator: Validate state change

    Validator->>Validator: Check type: int ‚úì
    Validator->>Validator: Check range: > max allowed (1000)

    Validator->>Attacker: ‚ùå Error: Value exceeds maximum (1000)

    Note over Attacker,Component: Attack Attempt: Access Other User's Component

    Attacker->>SignalR: InvokeComponentMethod("other-user-component", "DeleteAccount")

    SignalR->>SignalR: Verify component ownership
    SignalR->>SignalR: ComponentId belongs to different ConnectionId

    SignalR->>Attacker: ‚ùå Error: Unauthorized access to component

    Note over Attacker,Component: Attack Attempt: Call Protected Method

    Attacker->>SignalR: InvokeComponentMethod("admin-panel", "DeleteAllUsers")

    SignalR->>Component: Check [Authorize(Roles="Admin")]
    Component->>Component: User.IsInRole("Admin") = false

    Component->>Attacker: ‚ùå Error: Forbidden - Admin role required

    Note over Attacker,Component: Result: All attacks blocked by security layers
            </div>
        </section>

        <section id="dev-setup">
            <h2>Project Setup & Scaffolding <span class="badge new">NEW</span></h2>
            <h3>Generated Project Structure</h3>
            <p>
                When you create a new Minimact project, this is the directory structure you get.
                Understanding where files go and what they do is crucial for development.
            </p>
            <div class="mermaid">
graph TB
    subgraph "Project Root"
        ROOT[my-app/]
    end

    subgraph "Source Code"
        SRC[src/]
        COMP[components/]
        PAGES[pages/]
        TEMPLATES[templates/]
        SERVICES[services/]
    end

    subgraph "Component Files"
        TSX["Counter.tsx
        Developer writes"]
        CS_GEN["Counter.cs
        Generated - do not edit"]
        CS_BEHIND["Counter.codebehind.cs
        Optional - business logic"]
    end

    subgraph "Configuration"
        BABEL["babel.config.js
        Minimact plugin"]
        TSCONFIG["tsconfig.json
        TypeScript config"]
        CSPROJ["MyApp.csproj
        C# project file"]
        PROGRAM["Program.cs
        ASP.NET setup"]
    end

    subgraph "Client Assets"
        WWWROOT[wwwroot/]
        CLIENT_JS["minimact-client.js
        ~5KB runtime"]
        STATIC[static assets]
    end

    ROOT --> SRC
    ROOT --> WWWROOT
    ROOT --> BABEL
    ROOT --> TSCONFIG
    ROOT --> CSPROJ
    ROOT --> PROGRAM

    SRC --> COMP
    SRC --> PAGES
    SRC --> TEMPLATES
    SRC --> SERVICES

    COMP --> TSX
    COMP --> CS_GEN
    COMP --> CS_BEHIND

    WWWROOT --> CLIENT_JS
    WWWROOT --> STATIC

    style TSX fill:#3b82f6
    style CS_GEN fill:#f59e0b
    style CS_BEHIND fill:#10b981
            </div>
        </section>

        <section id="dev-loop">
            <h2>Development Loop <span class="badge new">NEW</span></h2>
            <h3>Inner Development Loop</h3>
            <p>
                The file-save-to-browser-update cycle happens automatically. File watchers detect
                changes, trigger Babel transformation, compile C#, and update the browser‚Äîall in ~2-3 seconds.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Dev as Developer
    participant IDE as VS Code/Rider
    participant Watch as File Watcher
    participant Babel as Babel Plugin
    participant DotNet as .NET Compiler
    participant Server as Dev Server
    participant Browser

    Note over Dev,Browser: Developer Iteration Cycle

    Dev->>IDE: Edit Counter.tsx
    IDE->>IDE: Save file

    IDE->>Watch: File change detected
    Watch->>Babel: Transform Counter.tsx

    Babel->>Babel: Parse TSX AST
    Babel->>Babel: Generate C# code
    Babel->>CS_File: Write Counter.cs

    Note over Watch,Server: Automatic Build
    Watch->>DotNet: Trigger incremental build
    DotNet->>DotNet: Compile Counter.cs

    alt Compilation Error
        DotNet->>IDE: Show error in Problems panel
        IDE->>Dev: Display error
    else Success
        DotNet->>Server: Hot reload (if supported)
        alt Hot Reload Available
            Server->>Browser: Inject update (no refresh)
        else No Hot Reload
            Dev->>Browser: Manual refresh F5
        end
        Browser->>Browser: Re-render component
    end

    Note over Dev,Browser: Changes visible in ~2-3 seconds
            </div>
        </section>

        <section id="hot-reload">
            <h2>Hot Reload System <span class="badge new">NEW</span></h2>
            <h3>Template-Based Hot Reload</h3>
            <p>
                Minimact uses a <strong>template-based hot reload system</strong> that extracts text node templates
                at build time and caches them on both server and client. When you edit a TSX file, only the changed
                templates are sent to the browser, achieving <strong>3-5ms hot reload latency</strong> with
                <strong>98% less memory</strong> than prediction-based approaches.
            </p>
            <div class="features">
                <div class="feature">
                    <h4>‚ö° 3-5ms Latency</h4>
                    <p>Instant visual feedback on file save</p>
                </div>
                <div class="feature">
                    <h4>üíæ 2KB per Component</h4>
                    <p>98% memory reduction vs predictions</p>
                </div>
                <div class="feature">
                    <h4>üéØ 100% Coverage</h4>
                    <p>All state values, not just common ones</p>
                </div>
                <div class="feature">
                    <h4>üîÑ Auto State Updates</h4>
                    <p>Templates automatically re-render on state change</p>
                </div>
            </div>

            <h3>Complete System Flow</h3>
            <p>
                This diagram shows the entire lifecycle: build-time template extraction, runtime initialization,
                hot reload updates, and automatic state change integration.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Dev as Developer
    participant Babel as Babel Plugin
    participant FS as File System
    participant Server as C# Server
    participant SignalR as SignalR Hub
    participant Client as Browser Client
    participant TemplateState as Template State Manager
    participant DOM as DOM

    Note over Dev,DOM: BUILD TIME - Template Extraction

    Dev->>Babel: Write/Edit Counter.tsx<br/>&lt;h1&gt;Count: {count}&lt;/h1&gt;
    Babel->>Babel: Parse JSX AST
    Babel->>Babel: Extract text node template<br/>template: "Count: {0}"<br/>bindings: ["count"]
    Babel->>FS: Generate Counter.g.cs
    Babel->>FS: Generate Counter.templates.json
    Note right of FS: {<br/>  "templates": {<br/>    "h1[0].text[0]": {<br/>      "template": "Count: {0}",<br/>      "bindings": ["count"],<br/>      "slots": [7]<br/>    }<br/>  }<br/>}

    Note over Dev,DOM: RUNTIME - Component Initialization

    Client->>SignalR: RegisterComponent("Counter")
    SignalR->>Server: Load component
    Server->>FS: Read Counter.templates.json
    FS-->>Server: Return template map
    Server->>SignalR: Send template-map message
    SignalR->>Client: HotReload:TemplateMap
    Client->>TemplateState: loadTemplateMap(componentId, templates)
    TemplateState->>TemplateState: Cache templates in memory<br/>(~2KB per component)
    Note right of TemplateState: Templates ready for<br/>instant hot reload!

    Note over Dev,DOM: HOT RELOAD - Developer Edit

    Dev->>FS: Edit Counter.tsx<br/>Change: "Count: {count}"<br/>‚Üí "Counter: {count}"
    FS->>Babel: File change detected
    Babel->>Babel: Re-parse JSX
    Babel->>Babel: Extract new template<br/>template: "Counter: {0}"<br/>bindings: ["count"]
    Babel->>FS: Update Counter.templates.json
    FS->>Server: FileSystemWatcher event
    Server->>Server: TemplateHotReloadManager<br/>Load new template map
    Server->>Server: Detect template change<br/>OLD: "Count: {0}"<br/>NEW: "Counter: {0}"
    Server->>Server: Get current state<br/>count = 5
    Server->>Server: Create template patch<br/>{<br/>  template: "Counter: {0}",<br/>  params: [5],<br/>  bindings: ["count"]<br/>}
    Server->>SignalR: Send template patch
    SignalR->>Client: HotReload:TemplatePatch
    Client->>TemplateState: applyTemplatePatch(patch)
    TemplateState->>TemplateState: Render: "Counter: {0}"<br/>.replace("{0}", 5)<br/>= "Counter: 5"
    TemplateState->>DOM: Update text node
    DOM->>DOM: Flash visual feedback
    Note right of DOM: üöÄ INSTANT UPDATE!<br/>3-5ms total latency

    Note over Dev,DOM: STATE CHANGE - User Interaction

    DOM->>Client: User clicks increment
    Client->>Client: useState: setCount(6)
    Client->>Client: Update local state
    Client->>TemplateState: updateState("count", 6)
    Client->>TemplateState: getTemplatesBoundTo("count")
    TemplateState-->>Client: [template for "h1[0].text[0]"]
    Client->>TemplateState: render(componentId, nodePath)
    TemplateState->>TemplateState: "Counter: {0}"<br/>.replace("{0}", 6)<br/>= "Counter: 6"
    TemplateState-->>Client: "Counter: 6"
    Client->>DOM: findElementByPath([0, 0])
    Client->>DOM: textNode.textContent = "Counter: 6"
    Note right of DOM: ‚ú® Template auto-updates<br/>with new state!
    Client->>SignalR: updateComponentState("count", 6)
    SignalR->>Server: Sync state to prevent stale data
    Server->>Server: component.SetStateFromClient("count", 6)
    Note right of Server: Server state in sync!<br/>Next render will be correct
            </div>

            <h3>Template Extraction (Build Time)</h3>
            <p>
                During the Babel transformation, templates are extracted from JSX text nodes and saved to
                <code>.templates.json</code> files alongside the generated C# code.
            </p>
            <div class="mermaid">
flowchart TD
    A[Developer writes JSX] --> B{Babel Plugin}
    B --> C[Parse JSX AST]
    C --> D{For each JSX element}
    D --> E{Has text children?}
    E -->|Yes| F{Has expressions?}
    F -->|Yes| G[Extract dynamic template]
    F -->|No| H[Extract static template]
    E -->|No| D

    G --> I[Identify bindings<br/>e.g., count]
    I --> J[Calculate slots<br/>e.g., position 7]
    J --> K[Build template object]

    H --> K
    K --> L[Add to template map]
    L --> M{More elements?}
    M -->|Yes| D
    M -->|No| N[Generate .templates.json]
    N --> O[Generate .g.cs]

    style G fill:#4CAF50
    style H fill:#2196F3
    style N fill:#FF9800
            </div>

            <h3>Template Loading (Runtime Init)</h3>
            <p>
                When a component first registers, the server reads the <code>.templates.json</code> file
                and sends the template map to the client, which caches it in memory (~2KB per component).
            </p>
            <div class="mermaid">
flowchart TD
    A[Component registers] --> B[Server loads .templates.json]
    B --> C{File exists?}
    C -->|Yes| D[Parse JSON]
    C -->|No| E[Skip template features]

    D --> F[Cache in TemplateHotReloadManager]
    F --> G[Send template-map via SignalR]
    G --> H[Client receives message]
    H --> I[TemplateStateManager.loadTemplateMap]
    I --> J{For each template}
    J --> K[Store template with key<br/>componentId:nodePath]
    K --> L[Build binding index<br/>state ‚Üí templates map]
    L --> M{More templates?}
    M -->|Yes| J
    M -->|No| N[Templates ready!]

    N --> O[Memory: ~2KB]
    N --> P[Coverage: 100%]
    N --> Q[Ready for hot reload]

    style D fill:#4CAF50
    style I fill:#2196F3
    style N fill:#FF9800
            </div>

            <h3>Hot Reload Update (Template Patch)</h3>
            <p>
                When you save a TSX file, the FileSystemWatcher detects the change, Babel regenerates the templates,
                and the server sends only the changed templates to the browser with the current state values filled in.
            </p>
            <div class="mermaid">
flowchart TD
    A[Developer edits TSX] --> B[FileSystemWatcher detects]
    B --> C[Babel re-runs]
    C --> D[New .templates.json generated]
    D --> E[Server loads new map]
    E --> F{Compare with cached map}

    F --> G{Template changed?}
    G -->|Yes| H[Get current component state]
    G -->|No| I[Skip - no update needed]

    H --> J["Fill template with params<br/>template: Counter: {0}<br/>params: [5]<br/>= Counter: 5"]
    J --> K[Create TemplatePatch object]
    K --> L[Send via SignalR]
    L --> M[Client receives patch]
    M --> N[Render template with params]
    N --> O[Find DOM node by path]
    O --> P{Node found?}

    P -->|Yes| Q[Update textContent]
    P -->|No| R[Log warning]

    Q --> S[Flash visual feedback]
    S --> T[Update cached template]
    T --> U[Complete! 3-5ms total]

    style H fill:#4CAF50
    style N fill:#2196F3
    style U fill:#FF9800
            </div>

            <h3>State Change Integration</h3>
            <p>
                When <code>useState</code> triggers a state change, the template system automatically
                finds all templates bound to that state variable and re-renders them.
            </p>
            <div class="mermaid">
flowchart TD
    A[User triggers state change] --> B[setState called]
    B --> C[Update local state<br/>context.state.set]
    C --> D[Check HintQueue]
    D --> E{Hint match?}

    E -->|Yes| F[Apply cached patches]
    E -->|No| G[Log cache miss]

    F --> H[Update template state<br/>templateState.updateState]
    G --> H

    H --> I[Get templates bound to state<br/>getTemplatesBoundTo]
    I --> J{Templates found?}

    J -->|Yes| K{For each template}
    J -->|No| L[Skip template update]

    K --> M[Render template<br/>template.replace placeholders]
    M --> N[Find DOM node by path]
    N --> O{Node type?}

    O -->|Text| P[Update textContent]
    O -->|Element| Q{Has attribute?}

    Q -->|Yes| R[Update attribute]
    Q -->|No| S[Update textContent]

    P --> T{More templates?}
    R --> T
    S --> T

    T -->|Yes| K
    T -->|No| U[Sync to server<br/>updateComponentState]

    U --> V[Server updates state<br/>SetStateFromClient]
    V --> W[State synchronized!]

    style H fill:#4CAF50
    style M fill:#2196F3
    style U fill:#FF9800
    style W fill:#9C27B0
            </div>

            <h3>Memory & Performance Comparison</h3>
            <p>
                Template-based hot reload uses <strong>98% less memory</strong> than prediction-based caching
                while achieving <strong>100% coverage</strong> of all possible state values.
            </p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0;">
                <div style="background: #0f172a; border: 2px solid #f44336; border-radius: 0.75rem; padding: 1.5rem;">
                    <h4 style="color: #f44336; margin-bottom: 1rem;">‚ùå Prediction-Based</h4>
                    <ul style="list-style: none; padding: 0;">
                        <li style="padding: 0.5rem 0; border-bottom: 1px solid #334155;">
                            <strong>Memory:</strong> ~100KB per component
                        </li>
                        <li style="padding: 0.5rem 0; border-bottom: 1px solid #334155;">
                            <strong>Coverage:</strong> 85% (1000+ cached variations)
                        </li>
                        <li style="padding: 0.5rem 0; border-bottom: 1px solid #334155;">
                            <strong>Scalability:</strong> Poor (linear growth)
                        </li>
                        <li style="padding: 0.5rem 0;">
                            <strong>Latency:</strong> 3-5ms (cache hit)
                        </li>
                    </ul>
                </div>
                <div style="background: #0f172a; border: 2px solid #4CAF50; border-radius: 0.75rem; padding: 1.5rem;">
                    <h4 style="color: #4CAF50; margin-bottom: 1rem;">‚úÖ Template-Based</h4>
                    <ul style="list-style: none; padding: 0;">
                        <li style="padding: 0.5rem 0; border-bottom: 1px solid #334155;">
                            <strong>Memory:</strong> ~2KB per component
                        </li>
                        <li style="padding: 0.5rem 0; border-bottom: 1px solid #334155;">
                            <strong>Coverage:</strong> 100% (parameterized)
                        </li>
                        <li style="padding: 0.5rem 0; border-bottom: 1px solid #334155;">
                            <strong>Scalability:</strong> Excellent (constant size)
                        </li>
                        <li style="padding: 0.5rem 0;">
                            <strong>Latency:</strong> 3-5ms (same!)
                        </li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="code-behind">
            <h2>Code-Behind Pattern <span class="badge new">NEW</span></h2>
            <h3>When to Use Code-Behind</h3>
            <p>
                The code-behind pattern separates UI logic (TSX) from business logic (C#).
                Use <code>.codebehind.cs</code> for database queries, API calls, and complex server-side operations.
            </p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0;">
                <div style="background: #0f172a; border: 2px solid #3b82f6; border-radius: 0.75rem; padding: 1.5rem;">
                    <h4 style="color: #3b82f6; margin-bottom: 1rem;">Counter.tsx (UI Logic)</h4>
                    <pre style="background: #1e293b; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; margin: 0; font-size: 0.85rem;"><code style="color: #e2e8f0;">export function Counter() {
  const [count, setCount] = useState(0);
  const data = useServerData();

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                </div>
                <div style="background: #0f172a; border: 2px solid #f59e0b; border-radius: 0.75rem; padding: 1.5rem;">
                    <h4 style="color: #f59e0b; margin-bottom: 1rem;">Counter.cs (Generated)</h4>
                    <pre style="background: #1e293b; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; margin: 0; font-size: 0.85rem;"><code style="color: #e2e8f0;">// ‚ö†Ô∏è DO NOT EDIT - Auto-generated
public partial class Counter {
  [State] private int count = 0;

  protected override VNode Render() {
    var data = UseServerData();
    return new VElement(...);
  }

  private void increment() {
    count++;
    SetState("count", count);
  }
}</code></pre>
                </div>
                <div style="background: #0f172a; border: 2px solid #10b981; border-radius: 0.75rem; padding: 1.5rem;">
                    <h4 style="color: #10b981; margin-bottom: 1rem;">Counter.codebehind.cs (Business Logic)</h4>
                    <pre style="background: #1e293b; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; margin: 0; font-size: 0.85rem;"><code style="color: #e2e8f0;">public partial class Counter {
  private readonly AppDbContext _db;

  public Counter(AppDbContext db) {
    _db = db;
  }

  private async Task&lt;UserData&gt; UseServerData() {
    return await _db.Users
      .Where(u => u.Id == UserId)
      .Include(u => u.Orders)
      .FirstOrDefaultAsync();
  }
}</code></pre>
                </div>
            </div>
        </section>

        <section id="debugging">
            <h2>Debugging Tools <span class="badge new">NEW</span></h2>
            <h3>Debugging Across Layers</h3>
            <p>
                Minimact provides debugging tools for every layer: IDE breakpoints for C# server code,
                browser DevTools for client code, and the Playground Bridge for visual inspection.
            </p>
            <div class="features">
                <div class="feature">
                    <h4>üíª IDE Debugging</h4>
                    <p>Set C# breakpoints, watch variables, inspect call stacks in VS Code or Rider</p>
                </div>
                <div class="feature">
                    <h4>üåê Browser DevTools</h4>
                    <p>Console logging, SignalR traffic inspection, DOM element inspection</p>
                </div>
                <div class="feature">
                    <h4>üéØ Playground Bridge</h4>
                    <p>Visual hint queue viewer, patch inspector, performance metrics</p>
                </div>
                <div class="feature">
                    <h4>üìä Error Handling</h4>
                    <p>TypeScript errors in IDE, C# errors in Problems panel, runtime errors in console</p>
                </div>
            </div>
        </section>

        <section id="integration-points">
            <h2>Integration Points <span class="badge new">NEW</span></h2>
            <h3>Adding Database (EF Core)</h3>
            <p>
                Integrating Entity Framework Core is straightforward. Install packages, create DbContext,
                register in DI, and use in <code>.codebehind.cs</code> files.
            </p>
            <div class="mermaid">
flowchart TD
    START[Need database access] --> INSTALL[Install EF Core packages]

    INSTALL --> CONTEXT[Create DbContext]

    CONTEXT --> MODELS[Define entity models]

    MODELS --> REGISTER[Register in Program.cs]

    REGISTER --> CONFIG["services.AddDbContext&lt;AppDbContext&gt;(...)"]

    CONFIG --> MIGRATE[Create migrations]

    MIGRATE --> USE[Use in component]

    USE --> INJECT[Inject via constructor]

    INJECT --> CODEBEHIND[Write queries in .codebehind.cs]

    CODEBEHIND --> EXAMPLE["private async Task&lt;List&lt;Todo&gt;&gt; LoadTodos() {
  return await _db.Todos
    .Where(t => t.UserId == UserId)
    .ToListAsync();
}"]

    style CONFIG fill:#3b82f6
    style CODEBEHIND fill:#10b981
            </div>

            <h3>Full-Stack Integration</h3>
            <p>
                Minimact components can access the entire ASP.NET Core ecosystem through dependency injection
                in <code>.codebehind.cs</code> files.
            </p>
            <div class="features">
                <div class="feature">
                    <h4>üíæ Database</h4>
                    <p>EF Core, Dapper, or any ORM</p>
                </div>
                <div class="feature">
                    <h4>üîê Authentication</h4>
                    <p>ASP.NET Identity, JWT, OAuth</p>
                </div>
                <div class="feature">
                    <h4>üîß DI Services</h4>
                    <p>Any registered service available</p>
                </div>
                <div class="feature">
                    <h4>üì° External APIs</h4>
                    <p>HttpClient, gRPC, etc.</p>
                </div>
                <div class="feature">
                    <h4>üí® Caching</h4>
                    <p>Redis, MemoryCache, etc.</p>
                </div>
                <div class="feature">
                    <h4>üì¨ Messaging</h4>
                    <p>RabbitMQ, Azure Service Bus</p>
                </div>
            </div>
        </section>

        <footer>
            <p>
                üåµ The cactus knows not just the topology, but how to navigate it. üß≠
            </p>
            <p>
                <a href="https://github.com/minimact/minimact" target="_blank">View on GitHub</a> ‚Ä¢
                <a href="../README.md">Documentation</a> ‚Ä¢
                <a href="ARCHITECTURE_DIAGRAMS.md">Markdown Source</a>
            </p>
            <p style="margin-top: 1rem;">
                Built with ‚ù§Ô∏è for the .NET and React communities ‚Ä¢ ¬© 2025 Minimact
            </p>
        </footer>
    </div>
</body>
</html>
