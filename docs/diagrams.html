<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimact Architecture Diagrams</title>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#3b82f6',
                primaryTextColor: '#e2e8f0',
                primaryBorderColor: '#1e40af',
                lineColor: '#64748b',
                secondaryColor: '#8b5cf6',
                tertiaryColor: '#10b981',
                background: '#0f172a',
                mainBkg: '#1e293b',
                secondBkg: '#334155',
                textColor: '#e2e8f0',
                border1: '#475569',
                border2: '#64748b',
                arrowheadColor: '#3b82f6',
                fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace'
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            color: #e2e8f0;
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            border-bottom: 2px solid #334155;
        }

        h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.25rem;
            color: #94a3b8;
            margin-bottom: 2rem;
        }

        .emoji {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        nav {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 3rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
        }

        nav h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: #3b82f6;
        }

        nav ul {
            list-style: none;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 0.75rem;
        }

        nav a {
            display: block;
            padding: 0.75rem 1rem;
            background: #334155;
            border: 1px solid #475569;
            border-radius: 0.5rem;
            color: #e2e8f0;
            text-decoration: none;
            transition: all 0.2s;
        }

        nav a:hover {
            background: #3b82f6;
            border-color: #2563eb;
            transform: translateX(4px);
        }

        section {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.75rem;
            padding: 2rem;
            margin-bottom: 3rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #3b82f6;
            border-bottom: 2px solid #334155;
            padding-bottom: 0.5rem;
        }

        h3 {
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #8b5cf6;
        }

        p {
            margin-bottom: 1rem;
            color: #cbd5e1;
            font-size: 1.1rem;
        }

        .mermaid {
            background: #0f172a;
            border: 1px solid #475569;
            border-radius: 0.5rem;
            padding: 2rem;
            margin: 2rem 0;
            overflow-x: auto;
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .feature {
            background: #334155;
            border: 1px solid #475569;
            border-radius: 0.5rem;
            padding: 1.5rem;
            transition: all 0.2s;
        }

        .feature:hover {
            border-color: #3b82f6;
            transform: translateY(-4px);
            box-shadow: 0 10px 20px rgba(59, 130, 246, 0.3);
        }

        .feature h4 {
            color: #3b82f6;
            margin-bottom: 0.5rem;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            background: #3b82f6;
            color: white;
            border-radius: 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .badge.new {
            background: #10b981;
        }

        .badge.punch {
            background: #f59e0b;
        }

        code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            background: #334155;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.9em;
        }

        footer {
            text-align: center;
            padding: 2rem 0;
            margin-top: 4rem;
            border-top: 2px solid #334155;
            color: #64748b;
        }

        footer a {
            color: #3b82f6;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .container {
                padding: 1rem;
            }

            nav ul {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="emoji">üåµüìä</div>
            <h1>Minimact Architecture Diagrams</h1>
            <p class="subtitle">Visual documentation for Minimact and Minimact Punch</p>
        </header>

        <nav>
            <h2>üìë Quick Navigation</h2>
            <h3 style="color: #64748b; font-size: 0.875rem; margin-top: 1rem; margin-bottom: 0.5rem;">Core Diagrams</h3>
            <ul>
                <li><a href="#core-architecture">Core Architecture</a></li>
                <li><a href="#data-flow">Data Flow</a></li>
                <li><a href="#predictive-rendering">Predictive Rendering</a></li>
                <li><a href="#state-sync">State Synchronization <span class="badge new">NEW</span></a></li>
                <li><a href="#punch-architecture">Minimact Punch <span class="badge punch">üçπ</span></a></li>
                <li><a href="#integration">Integration Patterns</a></li>
                <li><a href="#system-overview">System Overview</a></li>
                <li><a href="#performance">Performance</a></li>
            </ul>
            <h3 style="color: #64748b; font-size: 0.875rem; margin-top: 1.5rem; margin-bottom: 0.5rem;">Deep Dives <span class="badge new">NEW</span></h3>
            <ul>
                <li><a href="#lifecycle">Component Lifecycle</a></li>
                <li><a href="#prediction-engine">Prediction Engine</a></li>
                <li><a href="#babel">Babel Transformation</a></li>
                <li><a href="#security">Security Model</a></li>
            </ul>
        </nav>

        <section id="intro">
            <h2>About These Diagrams</h2>
            <p>
                This page contains comprehensive visual documentation for the Minimact architecture,
                showing how components interact, data flows, messaging patterns, and the integration
                of the Minimact Punch extension.
            </p>
            <div class="features">
                <div class="feature">
                    <h4>üéØ Core Architecture</h4>
                    <p>System components from TSX to DOM</p>
                </div>
                <div class="feature">
                    <h4>‚ö° Data Flows</h4>
                    <p>Request/response cycles and messaging</p>
                </div>
                <div class="feature">
                    <h4>üîÆ Predictions</h4>
                    <p>Cache hit/miss logic and hint queues</p>
                </div>
                <div class="feature">
                    <h4>üîÑ State Sync</h4>
                    <p>NEW auto-sync pattern preventing stale data</p>
                </div>
                <div class="feature">
                    <h4>üöÄ Lifecycle <span class="badge new">NEW</span></h4>
                    <p>Initial SSR through SignalR connection</p>
                </div>
                <div class="feature">
                    <h4>üß† Learning <span class="badge new">NEW</span></h4>
                    <p>Pattern detection and confidence scoring</p>
                </div>
                <div class="feature">
                    <h4>üîß Babel <span class="badge new">NEW</span></h4>
                    <p>TSX ‚Üí C# transformation with examples</p>
                </div>
                <div class="feature">
                    <h4>üîí Security <span class="badge new">NEW</span></h4>
                    <p>Multi-layer authorization and validation</p>
                </div>
            </div>
        </section>

        <section id="core-architecture">
            <h2>Minimact Core Architecture</h2>
            <p>
                System components showing all layers from TSX development to DOM rendering,
                including the Babel compilation pipeline, ASP.NET Core runtime, Rust reconciliation engine,
                and client-side SignalR integration.
            </p>
            <div class="mermaid">
graph TB
    subgraph "Developer Layer"
        TSX[TSX/JSX Components]
        TS[TypeScript]
    end

    subgraph "Compilation Layer"
        BABEL[Babel Plugin]
        CODEGEN[Code Generator]
    end

    subgraph "Server Runtime (.NET)"
        COMP[MinimactComponent]
        STATE[State Manager]
        RENDER[Render Engine]
        HUB[MinimactHub SignalR]
        RUST[Rust Reconciler FFI]
    end

    subgraph "Rust Engine"
        RECON[Reconciliation Engine]
        PRED[Prediction Engine]
        DIFF[VNode Differ]
    end

    subgraph "Client Runtime (Browser)"
        SIGNALR[SignalR Manager]
        PATCHER[DOM Patcher]
        HOOKS[Hook System]
        QUEUE[Hint Queue]
        BRIDGE[Playground Bridge]
    end

    subgraph "Client DOM"
        DOM[Browser DOM]
        EVENTS[Event Delegation]
    end

    TSX --> BABEL
    TS --> BABEL
    BABEL --> CODEGEN
    CODEGEN --> COMP

    COMP --> STATE
    STATE --> RENDER
    RENDER --> RUST
    RUST --> RECON
    RECON --> DIFF
    DIFF --> PRED

    PRED --> HUB
    RENDER --> HUB
    HUB --> SIGNALR

    SIGNALR --> PATCHER
    SIGNALR --> QUEUE
    PATCHER --> DOM
    QUEUE --> PATCHER

    HOOKS --> SIGNALR
    DOM --> EVENTS
    EVENTS --> SIGNALR

    PATCHER --> BRIDGE
    QUEUE --> BRIDGE
            </div>
        </section>

        <section id="data-flow">
            <h2>Complete Data Flow</h2>
            <p>
                Sequence diagram showing the complete request/response cycle, from initial render
                through predictive pre-caching to user interactions with both cache hits and misses.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant User
    participant DOM
    participant EventDel as Event Delegation
    participant SignalR as SignalR Manager
    participant Hub as MinimactHub
    participant Comp as Component
    participant Rust as Rust Engine
    participant Predictor
    participant Queue as Hint Queue
    participant Patcher as DOM Patcher

    Note over User,Patcher: Initial Render
    Comp->>Rust: Render() ‚Üí VNode
    Rust->>Rust: Generate patches
    Rust->>Hub: Send patches
    Hub->>SignalR: ApplyPatches
    SignalR->>Patcher: Apply to DOM
    Patcher->>DOM: Update elements

    Note over User,Patcher: Predictive Pre-Caching
    Predictor->>Rust: Predict state changes
    Rust->>Rust: Pre-compute patches
    Rust->>Hub: Send predictions
    Hub->>SignalR: QueueHint
    SignalR->>Queue: Cache patches
    Queue-->>Queue: Ready for instant use

    Note over User,Patcher: User Interaction (Cache Hit)
    User->>DOM: Click button
    DOM->>EventDel: Capture event
    EventDel->>Queue: Check for hint
    Queue-->>Queue: üü¢ CACHE HIT!
    Queue->>Patcher: Apply cached patches
    Patcher->>DOM: Instant update (0ms)
    EventDel->>SignalR: Notify server (background)
    SignalR->>Hub: InvokeComponentMethod
    Hub->>Comp: Call method
    Comp->>Comp: Update state
    Comp->>Rust: Re-render
    Rust->>Hub: Verify patches
    Hub->>SignalR: ApplyCorrection (if needed)

    Note over User,Patcher: User Interaction (Cache Miss)
    User->>DOM: Click button
    DOM->>EventDel: Capture event
    EventDel->>Queue: Check for hint
    Queue-->>Queue: üî¥ CACHE MISS
    EventDel->>SignalR: Invoke method
    SignalR->>Hub: InvokeComponentMethod
    Hub->>Comp: Call method
    Comp->>Comp: Update state
    Comp->>Rust: Re-render
    Rust->>Rust: Compute patches
    Rust->>Hub: Send patches
    Hub->>SignalR: ApplyPatches
    SignalR->>Patcher: Apply to DOM
    Patcher->>DOM: Update (~45ms latency)
            </div>
        </section>

        <section id="predictive-rendering">
            <h2>Predictive Rendering Pipeline</h2>
            <p>
                Flowchart showing how the prediction engine determines whether to send predictions,
                the confidence threshold, and the verification/correction flow.
            </p>
            <div class="mermaid">
flowchart TD
    START[Component State Change] --> PREDICT{Can Predict?}

    PREDICT -->|Yes| CONF{Confidence >= 0.7?}
    PREDICT -->|No| RENDER[Normal Render]

    CONF -->|Yes| SEND_PRED[Send Prediction Immediately]
    CONF -->|No| RENDER

    SEND_PRED --> CLIENT_CACHE[Client Caches Patches]
    CLIENT_CACHE --> APPLY_PRED[Apply Prediction Instantly]

    APPLY_PRED --> BG_RENDER[Background: Server Renders]
    RENDER --> BG_RENDER

    BG_RENDER --> RECON[Rust Reconciliation]
    RECON --> ACTUAL_PATCHES[Actual Patches]

    ACTUAL_PATCHES --> COMPARE{Prediction Match?}

    COMPARE -->|‚úÖ Match| NO_ACTION[No Action Needed]
    COMPARE -->|‚ùå Mismatch| CORRECTION[Send Correction]

    CORRECTION --> CLIENT_FIX[Client Applies Fix]

    style SEND_PRED fill:#90EE90
    style APPLY_PRED fill:#90EE90
    style NO_ACTION fill:#90EE90
    style CORRECTION fill:#FFB6C1
    style CLIENT_FIX fill:#FFB6C1
            </div>
        </section>

        <section id="state-sync">
            <h2>State Synchronization <span class="badge new">NEW</span></h2>
            <p>
                <strong>Critical Update:</strong> The new auto-sync pattern ensures client state changes
                are immediately synchronized to the server, preventing stale data issues that could cause
                the Rust reconciler to overwrite client updates.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant User
    participant Client as Client Hook (useState)
    participant SignalR as SignalR Manager
    participant Hub as MinimactHub
    participant Comp as MinimactComponent
    participant Rust as Rust Reconciler

    Note over User,Rust: NEW: Automatic State Sync

    User->>Client: setCount(5)
    Client->>Client: Update local state

    par Check Hint Queue
        Client->>Client: Check HintQueue
        alt Cache Hit
            Client->>Client: Apply cached patches (instant)
        else Cache Miss
            Client->>Client: No instant feedback
        end
    and Sync to Server
        Client->>SignalR: updateComponentState(componentId, "count", 5)
        SignalR->>Hub: UpdateComponentState
        Hub->>Comp: SetStateFromClient("count", 5)
        Comp->>Comp: Update internal state
        Comp->>Rust: TriggerRender()
        Rust->>Rust: Compute patches
        Rust->>Hub: Patches ready
        Hub->>SignalR: ApplyPatches (verification)
        SignalR->>Client: Patches applied
    end

    Note over User,Rust: Result: Server always has correct state!
            </div>
        </section>

        <section id="punch-architecture">
            <h2>Minimact Punch Architecture <span class="badge punch">üçπ</span></h2>
            <p>
                <code>useDomElementState</code> integration showing how DOM observers
                feed into the reactive state system, enabling DOM-driven predictions.
            </p>
            <div class="mermaid">
graph TB
    subgraph "Client Runtime"
        HOOK[useDomElementState hook]
        STATE[DomElementState class]
        OBSERVERS[Browser Observers]
        SNAPSHOT[State Snapshot]
    end

    subgraph "Observers Layer"
        INTERSECT[IntersectionObserver]
        MUTATION[MutationObserver]
        RESIZE[ResizeObserver]
    end

    subgraph "Reactive Properties"
        PROPS["Properties
        - isIntersecting
        - childrenCount
        - attributes
        - classList"]
        COLLECTION["Collection Methods
        - every
        - some
        - filter"]
        STATS["Statistics
        - vals.avg
        - vals.sum
        - vals.median"]
    end

    subgraph "Integration"
        CONTEXT[ComponentContext]
        HINTQUEUE[HintQueue]
        SIGNALR[SignalR Manager]
        PATCHER[DOM Patcher]
    end

    subgraph "Server Side"
        CSHARP[C# DomElementStateHook]
        HUB[MinimactHub]
        PREDICTOR[Prediction Engine]
    end

    HOOK --> STATE
    STATE --> OBSERVERS

    OBSERVERS --> INTERSECT
    OBSERVERS --> MUTATION
    OBSERVERS --> RESIZE

    INTERSECT --> SNAPSHOT
    MUTATION --> SNAPSHOT
    RESIZE --> SNAPSHOT

    SNAPSHOT --> PROPS
    SNAPSHOT --> COLLECTION
    SNAPSHOT --> STATS

    STATE --> CONTEXT
    CONTEXT --> HINTQUEUE
    CONTEXT --> SIGNALR
    CONTEXT --> PATCHER

    SIGNALR --> HUB
    HUB --> CSHARP
    CSHARP --> PREDICTOR
    PREDICTOR --> HINTQUEUE
            </div>
        </section>

        <section id="integration">
            <h2>Integration Patterns</h2>
            <p>
                Hook integration showing the symmetry between <code>useState</code> and
                <code>useDomElementState</code>, both following the same MES-compliant pattern.
            </p>
            <div class="mermaid">
flowchart LR
    subgraph "Component Context"
        STATE_MAP[state: Map]
        EFFECTS[effects: Array]
        REFS[refs: Map]
        DOM_STATES[domElementStates: Map]
        HINT_QUEUE[hintQueue: HintQueue]
        DOM_PATCHER[domPatcher: DOMPatcher]
        SIGNALR_MGR[signalR: SignalRManager]
    end

    subgraph "Hooks"
        USE_STATE[useState]
        USE_EFFECT[useEffect]
        USE_REF[useRef]
        USE_DOM[useDomElementState]
    end

    subgraph "Symmetry"
        PATTERN[Same Pattern:<br/>1. Index tracking<br/>2. Context integration<br/>3. HintQueue check<br/>4. Server sync<br/>5. Cleanup]
    end

    USE_STATE --> STATE_MAP
    USE_EFFECT --> EFFECTS
    USE_REF --> REFS
    USE_DOM --> DOM_STATES

    USE_STATE --> HINT_QUEUE
    USE_DOM --> HINT_QUEUE

    USE_STATE --> SIGNALR_MGR
    USE_DOM --> SIGNALR_MGR

    STATE_MAP --> PATTERN
    DOM_STATES --> PATTERN

    style USE_DOM fill:#FFD700
    style DOM_STATES fill:#FFD700
    style PATTERN fill:#90EE90
            </div>
        </section>

        <section id="system-overview">
            <h2>Complete System Overview</h2>
            <p>
                End-to-end architecture showing all components from developer experience
                through build-time compilation, server runtime, Rust engine, SignalR layer,
                client runtime, and Minimact Punch extension.
            </p>
            <div class="mermaid">
graph TB
    subgraph "Developer Experience"
        DEV[Developer writes TSX]
        IDE[TypeScript IntelliSense]
    end

    subgraph "Build Time"
        BABEL[Babel Plugin]
        CODEGEN[Code Generator]
        CSHARP[C# Classes]
    end

    subgraph "Server Runtime"
        ASPNET[ASP.NET Core]
        COMPONENT[MinimactComponent]
        STATEMGR[State Manager]
        HOOKS_CS[C# Hook Implementations]
    end

    subgraph "Rust Engine"
        FFI[FFI Bridge]
        RECONCILER[Reconciliation Engine]
        PREDICTOR[Prediction Engine]
        VNODE[VNode Differ]
    end

    subgraph "SignalR Layer"
        HUB[MinimactHub]
        CONNECTION[SignalR Connection]
    end

    subgraph "Client Runtime"
        SIGNALR_CLIENT[SignalR Manager]
        HOOKS_TS[TypeScript Hooks]
        CONTEXT[Component Context]
        HINTQUEUE[Hint Queue]
        PATCHER[DOM Patcher]
        PLAYGROUND[Playground Bridge]
    end

    subgraph "minimact-punch Extension"
        DOM_STATE[DomElementState]
        OBSERVERS[DOM Observers]
        STATS[Statistical Engine]
        INTEGRATION[Integration Layer]
    end

    subgraph "Browser"
        DOM[DOM]
        EVENTS[Event System]
        WEB_APIS[Web APIs]
    end

    DEV --> BABEL
    IDE --> DEV
    BABEL --> CODEGEN
    CODEGEN --> CSHARP
    CSHARP --> COMPONENT

    COMPONENT --> STATEMGR
    COMPONENT --> HOOKS_CS
    STATEMGR --> FFI
    HOOKS_CS --> FFI

    FFI --> RECONCILER
    FFI --> PREDICTOR
    RECONCILER --> VNODE
    PREDICTOR --> VNODE

    VNODE --> HUB
    COMPONENT --> HUB
    HUB --> CONNECTION

    CONNECTION --> SIGNALR_CLIENT
    SIGNALR_CLIENT --> HOOKS_TS
    SIGNALR_CLIENT --> HINTQUEUE

    HOOKS_TS --> CONTEXT
    CONTEXT --> PATCHER
    CONTEXT --> PLAYGROUND

    HINTQUEUE --> PATCHER
    PATCHER --> DOM

    INTEGRATION --> HOOKS_TS
    INTEGRATION --> CONTEXT
    DOM_STATE --> OBSERVERS
    OBSERVERS --> WEB_APIS
    DOM_STATE --> STATS
    STATS --> INTEGRATION

    DOM --> EVENTS
    EVENTS --> SIGNALR_CLIENT
    WEB_APIS --> DOM

    style DOM_STATE fill:#FFD700
    style INTEGRATION fill:#FFD700
    style OBSERVERS fill:#FFD700
    style STATS fill:#FFD700
            </div>
        </section>

        <section id="performance">
            <h2>Performance Characteristics</h2>
            <p>
                Latency comparison showing the performance benefits of cache hits in both
                traditional Minimact and Minimact Punch scenarios.
            </p>
            <div class="features">
                <div class="feature">
                    <h4>Traditional SSR</h4>
                    <p>~52ms total latency (network round-trip + processing)</p>
                </div>
                <div class="feature">
                    <h4>Minimact Cache Hit</h4>
                    <p>~2ms total latency (instant patch application)</p>
                </div>
                <div class="feature">
                    <h4>Minimact Cache Miss</h4>
                    <p>~52ms total latency (falls back to server render)</p>
                </div>
                <div class="feature">
                    <h4>Minimact Punch Hit</h4>
                    <p>~2ms total latency (DOM observer + instant patch)</p>
                </div>
            </div>
        </section>

        <section id="lifecycle">
            <h2>Component Lifecycle & Initial Load</h2>
            <h3>Initial Page Load Flow</h3>
            <p>
                How does the initial page load work? This diagram shows the progression from
                SSR ‚Üí HTML ‚Üí SignalR connection upgrade, demonstrating how the page works
                <strong>without JavaScript</strong> and is progressively enhanced <strong>with JavaScript</strong>.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Browser
    participant Server as ASP.NET Core
    participant Rust as Rust Engine
    participant Component
    participant SignalR as SignalR Hub
    participant Client as Client Runtime

    Note over Browser,Client: 1. Initial SSR (No JavaScript Yet)
    Browser->>Server: HTTP GET /page
    Server->>Component: Create instance
    Component->>Component: OnInitializedAsync()
    Component->>Rust: Render() ‚Üí VNode
    Rust->>Rust: Generate HTML
    Rust->>Server: HTML string
    Server->>Browser: Return HTML page
    Browser->>Browser: Display HTML immediately

    Note over Browser,Client: 2. Progressive Enhancement (JavaScript Loads)
    Browser->>Browser: Parse & execute ~5KB client.js
    Browser->>Client: Initialize Minimact client
    Client->>SignalR: Establish WebSocket connection

    Note over Browser,Client: 3. Component Registration
    SignalR->>Server: Connection established
    Server->>SignalR: Assign ConnectionId
    Client->>Client: Query DOM for [data-component-id]
    Client->>SignalR: RegisterComponent(componentId)
    SignalR->>Server: Store mapping: ConnectionId ‚Üí ComponentId
    Server->>Component: Attach connection to instance

    Note over Browser,Client: 4. Ready State
    Component->>Rust: Generate initial predictions
    Rust->>SignalR: QueueHint messages
    SignalR->>Client: Cache predictions
    Client->>Client: System ready - instant interactions enabled

    Note over Browser,Client: Result: Page works WITHOUT JS, enhanced WITH JS
            </div>

            <h3>Component ID Tracking</h3>
            <p>
                Components are identified and tracked between server and client using GUIDs
                embedded in <code>data-component-id</code> attributes.
            </p>
            <div class="mermaid">
graph LR
    subgraph "Server-Side Rendering"
        COMP[Component Instance]
        ID[Generate GUID]
        HTML[Rendered HTML]
    end

    subgraph "HTML Output"
        ATTR[data-component-id attribute]
    end

    subgraph "Client-Side Discovery"
        DOM[DOM Query]
        MAP[ComponentId ‚Üí Element Map]
    end

    subgraph "Server Registry"
        REGISTRY[Component Registry]
        CONN[ConnectionId ‚Üí Component Map]
    end

    COMP --> ID
    ID --> ATTR
    ATTR --> HTML

    HTML --> DOM
    DOM --> MAP

    MAP --> REGISTRY
    REGISTRY --> CONN

    style ATTR fill:#FFD700
    style MAP fill:#90EE90
            </div>
        </section>

        <section id="prediction-engine">
            <h2>Prediction Engine Deep Dive</h2>
            <h3>Learning & Pattern Detection</h3>
            <p>
                The prediction engine learns patterns through frequency analysis, sequence detection,
                and conditional pattern recognition. It assigns confidence scores and only sends
                predictions with ‚â•70% confidence.
            </p>
            <div class="mermaid">
flowchart TD
    START[User Interaction] --> RECORD[Record to History]

    RECORD --> PATTERN{Pattern Analysis}

    PATTERN -->|Frequency Analysis| FREQ[Track state change frequency]
    PATTERN -->|Sequence Detection| SEQ[Detect interaction sequences]
    PATTERN -->|Conditional Patterns| COND[Learn conditional branches]

    FREQ --> CONFIDENCE[Calculate Confidence Score]
    SEQ --> CONFIDENCE
    COND --> CONFIDENCE

    CONFIDENCE --> THRESHOLD{Confidence >= 0.7?}

    THRESHOLD -->|Yes| GENERATE[Generate Prediction]
    THRESHOLD -->|No| SKIP[Skip prediction]

    GENERATE --> PRECOMPUTE[Pre-compute patches]
    PRECOMPUTE --> QUEUE[Queue to client]

    QUEUE --> MEASURE[Measure accuracy on use]
    MEASURE --> FEEDBACK[Adjust confidence weights]
    FEEDBACK --> PATTERN

    SKIP --> END[End]

    style GENERATE fill:#90EE90
    style QUEUE fill:#90EE90
    style CONFIDENCE fill:#FFD700
            </div>

            <h3>Prediction Triggers</h3>
            <p>
                Three types of triggers: explicit <code>usePredictHint</code>, automatic pattern learning,
                and user behavior patterns (e.g., hover ‚Üí click probability).
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Dev as Developer
    participant Comp as Component
    participant Pred as Prediction Engine
    participant Rust as Rust Reconciler
    participant Queue as Hint Queue

    Note over Dev,Queue: Trigger 1: Explicit usePredictHint
    Dev->>Comp: usePredictHint('increment', {count: count+1})
    Comp->>Pred: Register hint
    Pred->>Rust: Compute patches for predicted state
    Rust->>Pred: Return patches
    Pred->>Queue: QueueHint(hintId, patches, confidence: 1.0)

    Note over Dev,Queue: Trigger 2: Automatic Pattern Learning
    Comp->>Comp: setState(newValue)
    Comp->>Pred: Notify state change
    Pred->>Pred: Analyze historical patterns
    Pred->>Pred: Detect: "count always increments by 1"
    Pred->>Rust: Compute patches for likely next state
    Rust->>Pred: Return patches
    Pred->>Queue: QueueHint(hintId, patches, confidence: 0.85)

    Note over Dev,Queue: Trigger 3: User Behavior Patterns
    Comp->>Pred: Track: User hovered button for 500ms
    Pred->>Pred: Pattern: Hover ‚Üí Click (78% probability)
    Pred->>Rust: Pre-compute click result
    Rust->>Pred: Return patches
    Pred->>Queue: QueueHint(hintId, patches, confidence: 0.78)

    Note over Dev,Queue: Accuracy Feedback Loop
    Queue->>Queue: User clicked ‚Üí Check cache
    Queue->>Pred: Report: Hit/Miss + actual state
    Pred->>Pred: Update pattern weights
            </div>
        </section>

        <section id="babel">
            <h2>Babel Plugin Transformation</h2>
            <h3>TSX to C# Example</h3>
            <p>
                Concrete before/after example showing how TypeScript/JSX transforms into C# with VNode trees.
            </p>
            <div style="background: #0f172a; border: 1px solid #475569; border-radius: 0.5rem; padding: 1.5rem; margin: 1.5rem 0;">
                <h4 style="color: #3b82f6; margin-bottom: 1rem;">Input (Counter.tsx):</h4>
                <pre style="background: #1e293b; padding: 1rem; border-radius: 0.25rem; overflow-x: auto; margin: 0;"><code style="color: #e2e8f0; font-family: monospace; font-size: 0.9rem;">import { useState } from 'minimact';

export function Counter() {
    const [count, setCount] = useState(0);

    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;
                Increment
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
            </div>

            <div style="background: #0f172a; border: 1px solid #475569; border-radius: 0.5rem; padding: 1.5rem; margin: 1.5rem 0;">
                <h4 style="color: #10b981; margin-bottom: 1rem;">Output (Counter.cs):</h4>
                <pre style="background: #1e293b; padding: 1rem; border-radius: 0.25rem; overflow-x: auto; margin: 0;"><code style="color: #e2e8f0; font-family: monospace; font-size: 0.9rem;">using Minimact.AspNetCore.Core;
using Minimact.AspNetCore.VNodes;

namespace MyApp.Components
{
    public partial class Counter : MinimactComponent
    {
        [State]
        private int count = 0;

        protected override VNode Render()
        {
            return new VElement("div",
                new VElement("p", $"Count: {count}"),
                new VElement("button",
                    new VAttribute("onClick", nameof(Increment)),
                    "Increment"
                )
            );
        }

        private void Increment()
        {
            count++;
            SetState(nameof(count), count);
        }
    }
}</code></pre>
            </div>

            <h3>Transformation Pipeline</h3>
            <div class="mermaid">
flowchart TD
    START[Counter.tsx] --> PARSE[Babel Parse AST]

    PARSE --> DETECT[Detect Hooks]
    DETECT --> HOOK_STATE{Hook Type?}

    HOOK_STATE -->|useState| GEN_STATE[Generate State field]
    HOOK_STATE -->|useEffect| GEN_EFFECT[Generate lifecycle method]
    HOOK_STATE -->|useRef| GEN_REF[Generate private field]

    GEN_STATE --> TRACK_DEPS[Track dependencies]
    GEN_EFFECT --> TRACK_DEPS
    GEN_REF --> TRACK_DEPS

    TRACK_DEPS --> JSX[Parse JSX]
    JSX --> BUILD_VNODE[Build VNode tree]

    BUILD_VNODE --> EVENTS{Event Handlers?}
    EVENTS -->|Yes| GEN_METHODS[Generate C# methods]
    EVENTS -->|No| CONTINUE

    GEN_METHODS --> CONTINUE[Continue]
    CONTINUE --> TYPE_MAP[Map TS types to C# types]

    TYPE_MAP --> OUTPUT[Generate Counter.cs]

    style GEN_STATE fill:#90EE90
    style BUILD_VNODE fill:#FFD700
    style OUTPUT fill:#3b82f6
            </div>
        </section>

        <section id="security">
            <h2>Security & Authorization Model</h2>
            <h3>Method Invocation Security</h3>
            <p>
                Multi-layer security ensures only authenticated, authorized users can invoke
                component methods with validated parameters.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Client
    participant SignalR as SignalR Hub
    participant Auth as Authorization
    participant Registry as Component Registry
    participant Comp as Component

    Note over Client,Comp: Secure Method Invocation Flow

    Client->>SignalR: InvokeComponentMethod(componentId, "UpdateProfile", args)

    SignalR->>Auth: ValidateConnection()
    Auth->>Auth: Check User.Identity
    Auth->>Auth: Verify ConnectionId is authenticated

    alt Not Authenticated
        Auth->>Client: 401 Unauthorized
    end

    SignalR->>Registry: GetComponent(componentId)

    alt Component Not Found
        Registry->>Client: Error: Component not found
    end

    Registry->>Registry: Verify component belongs to this connection

    alt Wrong Connection
        Registry->>Client: Error: Unauthorized access
    end

    SignalR->>Comp: Check [Authorize] attribute on method

    alt Has [Authorize(Roles="Admin")]
        Comp->>Auth: Check User.IsInRole("Admin")
        Auth-->>Comp: False
        Comp->>Client: Error: Forbidden
    end

    Comp->>Comp: Validate method parameters

    alt Invalid Parameters
        Comp->>Client: Error: Validation failed
    end

    Comp->>Comp: Invoke method via reflection
    Comp->>Comp: Update state
    Comp->>Client: Success
            </div>

            <h3>State Validation Flow</h3>
            <p>
                All client state updates go through type checking, range validation,
                sanitization, and custom validators before being applied.
            </p>
            <div class="mermaid">
flowchart TD
    START[Client sends UpdateComponentState] --> AUTH{User Authenticated?}

    AUTH -->|No| REJECT1[Reject: 401 Unauthorized]
    AUTH -->|Yes| OWNER{Owns Component?}

    OWNER -->|No| REJECT2[Reject: 403 Forbidden]
    OWNER -->|Yes| VALIDATE[Validate State Value]

    VALIDATE --> TYPE{Type Valid?}
    TYPE -->|No| REJECT3[Reject: Invalid type]
    TYPE -->|Yes| RANGE{Range Valid?}

    RANGE -->|No| REJECT4[Reject: Out of range]
    RANGE -->|Yes| SANITIZE[Sanitize Input]

    SANITIZE --> CUSTOM{Custom Validator?}
    CUSTOM -->|Yes| RUN_VALIDATOR[Run validation logic]
    CUSTOM -->|No| APPLY

    RUN_VALIDATOR --> VALID{Valid?}
    VALID -->|No| REJECT5[Reject: Custom validation failed]
    VALID -->|Yes| APPLY[Apply state change]

    APPLY --> LOG[Log change for audit]
    LOG --> SUCCESS[Success]

    style REJECT1 fill:#FFB6C1
    style REJECT2 fill:#FFB6C1
    style REJECT3 fill:#FFB6C1
    style REJECT4 fill:#FFB6C1
    style REJECT5 fill:#FFB6C1
    style SUCCESS fill:#90EE90
            </div>

            <h3>Attack Prevention Examples</h3>
            <p>
                Demonstrating how the security layers block malicious state updates, unauthorized
                component access, and protected method invocation attempts.
            </p>
            <div class="mermaid">
sequenceDiagram
    participant Attacker as Malicious Client
    participant SignalR
    participant Validator
    participant Component

    Note over Attacker,Component: Attack Attempt: Send Invalid State

    Attacker->>SignalR: UpdateComponentState("count", 999999999)

    SignalR->>Validator: Validate state change

    Validator->>Validator: Check type: int ‚úì
    Validator->>Validator: Check range: > max allowed (1000)

    Validator->>Attacker: ‚ùå Error: Value exceeds maximum (1000)

    Note over Attacker,Component: Attack Attempt: Access Other User's Component

    Attacker->>SignalR: InvokeComponentMethod("other-user-component", "DeleteAccount")

    SignalR->>SignalR: Verify component ownership
    SignalR->>SignalR: ComponentId belongs to different ConnectionId

    SignalR->>Attacker: ‚ùå Error: Unauthorized access to component

    Note over Attacker,Component: Attack Attempt: Call Protected Method

    Attacker->>SignalR: InvokeComponentMethod("admin-panel", "DeleteAllUsers")

    SignalR->>Component: Check [Authorize(Roles="Admin")]
    Component->>Component: User.IsInRole("Admin") = false

    Component->>Attacker: ‚ùå Error: Forbidden - Admin role required

    Note over Attacker,Component: Result: All attacks blocked by security layers
            </div>
        </section>

        <footer>
            <p>
                üåµ The cactus knows the topology of the desert. üçπ
            </p>
            <p>
                <a href="https://github.com/minimact/minimact" target="_blank">View on GitHub</a> ‚Ä¢
                <a href="../README.md">Documentation</a> ‚Ä¢
                <a href="ARCHITECTURE_DIAGRAMS.md">Markdown Source</a>
            </p>
            <p style="margin-top: 1rem;">
                Built with ‚ù§Ô∏è for the .NET and React communities ‚Ä¢ ¬© 2025 Minimact
            </p>
        </footer>
    </div>
</body>
</html>
