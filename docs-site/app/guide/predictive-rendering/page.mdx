# Predictive Rendering

Minimact's breakthrough feature: pre-computing UI state changes and caching them on the client **before** the user interacts.

## The Problem with Traditional Frameworks

Traditional frameworks reconcile state changes **at the moment of need**:

```
User clicks button
  ‚Üì
Event handler runs
  ‚Üì
State changes
  ‚Üì
Framework diffs VDOM              ‚Üê CPU overhead
  ‚Üì
Framework applies patches         ‚Üê More overhead
  ‚Üì
DOM updates
```

This happens on **every interaction**, consuming CPU cycles and causing delays.

## The Minimact Approach

Minimact pre-computes and caches patches **before** interaction:

```
[Before User Clicks]
Server predicts likely state changes
  ‚Üì
Rust engine generates templates
  ‚Üì
Templates sent to client
  ‚Üì
Client caches patches
  ‚Üì
[User Clicks]
  ‚Üì
Patch already in cache!
  ‚Üì
Apply instantly (0ms latency)
  ‚Üì
[Background]
Server verifies and corrects if needed
```

## Template System Architecture

### Phase 1-3: Basic Templates

Simple value substitution:

```tsx
<button>Count: {count}</button>
```

**First click** (count: 0 ‚Üí 1):
- Server renders: `<button>Count: 1</button>`
- Rust extracts template: `<button>Count: {0}</button>`
- Cache stores: `{ template, params: [1] }`

**All future clicks**:
- Client applies template with new value
- **100% cache hit rate**
- **0ms latency**

### Phase 4: Loop Templates

ONE template for infinite list items:

```tsx
{todos.map(todo => (
    <li key={todo.id}>{todo.text}</li>
))}
```

**Before templates**:
```
3 todos = 3 patterns √ó 150 bytes = 450 bytes
100 todos = 100 patterns √ó 150 bytes = 15KB
```

**With templates**:
```
ANY number of todos = 1 template √ó 200 bytes = 200 bytes
```

**98% memory reduction!** üéâ

### Phase 5: Structural Templates

Conditional rendering:

```tsx
{loading ? <Spinner /> : <Content />}
```

Template includes both branches:
```json
{
  "condition": "{loading}",
  "true": "<Spinner />",
  "false": "<Content />"
}
```

### Phase 6: Expression Templates

Formatted values:

```tsx
<span>${price.toFixed(2)}</span>
```

Template captures the expression:
```json
{
  "template": "${{0}.toFixed(2)}",
  "variable": "price"
}
```

### Phase 7: Deep State Traversal

Nested objects:

```tsx
<div>{user.profile.address.city}</div>
```

Template tracks path:
```json
{
  "template": "<div>{0}</div>",
  "path": ["user", "profile", "address", "city"]
}
```

### Phase 8: Reorder Templates

Sorting and filtering:

```tsx
{items.sort((a, b) => a.name.localeCompare(b.name))}
```

Template stores reordering instructions instead of new content.

### Phase 9: Semantic Array Operations

**10x faster learning** with semantic hints:

```tsx
// Minimact automatically detects common array patterns
todos.push(newTodo)      // Append operation
todos.splice(idx, 1)     // Remove operation
todos[0].done = true     // Item mutation
```

Instead of learning N individual patterns, learns ONE semantic operation.

## Real-World Example: FAQ Accordion

```tsx
function FAQ() {
    const [openIndex, setOpenIndex] = useState(null);
    const faqs = [...]; // 29 FAQ items

    return (
        <div>
            {faqs.map((item, i) => (
                <div key={item.id}>
                    <button onClick={() => setOpenIndex(i)}>
                        {item.question}
                    </button>
                    {openIndex === i && <div>{item.answer}</div>}
                </div>
            ))}
        </div>
    );
}
```

**Without templates**:
- 29 items √ó 2 states (open/closed) = 58 patterns
- 58 √ó 150 bytes = **8.7KB**

**With templates**:
- 1 loop template √ó 200 bytes = **200 bytes**
- **97.7% reduction** (43x smaller!)

## Cache Hit Rates

After warmup (1-2 interactions):

| UI Pattern | Cache Hit Rate |
|------------|---------------|
| Counters, toggles | **100%** |
| Lists with .map() | **100%** |
| Conditional rendering | **95%+** |
| Formatted values | **85%+** |
| Complex nested state | **75%+** |

**Overall real-world: 95-98%** ‚úÖ

## Zero Cold Start

Babel pre-generates templates at **compile time**:

```tsx
// Your code
{todos.map(t => <li>{t.text}</li>)}

// Babel extracts template during build
// Template ready from FIRST render!
```

No learning phase needed. Instant cache hits from the start.

## Performance Impact

### Traditional React
```
User clicks ‚Üí 15ms reconciliation ‚Üí 5ms DOM update ‚Üí 20ms total
+ network latency (20-50ms) ‚Üí 40-70ms perceived latency
```

### Minimact (Cache Hit)
```
User clicks ‚Üí Patch in cache ‚Üí 1ms DOM update ‚Üí 1ms total
+ 0ms network (cached) ‚Üí 1ms perceived latency
```

**20-70x faster!** ‚ö°

### Minimact (Cache Miss)
```
User clicks ‚Üí 5ms server round-trip ‚Üí 1ms DOM update ‚Üí 6ms total
+ network latency (20-50ms) ‚Üí 26-56ms perceived latency
```

Still competitive, and cache miss rate is only 2-5%.

## Hint System (Optional)

For edge cases, give explicit hints:

```tsx
const [count, setCount] = useState(0);

// Tell predictor: when count increments, predict +1
usePredictHint('increment', { count: count + 1 });

return (
    <button onClick={() => setCount(count + 1)}>
        Count: {count}
    </button>
);
```

But **95% of the time, you don't need hints!** The template system handles it automatically.

## Next Steps

- Understand [Hybrid State](/guide/hybrid-state)
- Learn about [Server Tasks](/guide/server-tasks)
- Explore [Hooks Reference](/api/hooks)
