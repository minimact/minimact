# Core Concepts

Understanding the key concepts behind Minimact will help you build better applications.

## The Minimact Philosophy

Traditional UI frameworks ship logic to the client and reconcile at runtime. Minimact takes a different approach:

> **Pre-compile state transitions on the server, cache them on the client, and reduce interaction to pure execution.**

Think of it as **stored procedures for the DOM**.

## Server-Side Rendering

Unlike traditional React apps that hydrate on the client, Minimact renders on the server:

```tsx
// Your component
export function UserProfile() {
    const [user, setUser] = useState(null);
    return <div>{user?.name}</div>;
}
```

```csharp
// Generated C# code (simplified)
public partial class UserProfile : MinimactComponent {
    public override VNode Render() {
        var user = GetState<User>("user");
        return h("div", null, user?.Name);
    }
}
```

The server sends HTML to the client, not a JavaScript bundle.

## Template Prediction System

The Rust reconciliation engine learns patterns from your UI and predicts future state changes.

### How It Works

1. **First Interaction**: User clicks a button
   - Server processes the state change
   - Rust engine extracts a parameterized template
   - Server sends the patch to the client

2. **Template Learning**:
   ```
   Before: <button>Count: 0</button>
   After:  <button>Count: 1</button>

   Template: <button>Count: {0}</button>
   ```

3. **Future Interactions**: All subsequent clicks hit the template (100% cache hit rate)

### Coverage Phases (All Complete!)

- âœ… **Phase 1-3**: Simple text substitution, conditionals, multi-variable patterns
- âœ… **Phase 4**: Loop templates for `.map()` - ONE template for infinite list items
- âœ… **Phase 5**: Structural templates for conditional rendering
- âœ… **Phase 6**: Expression templates (`.toFixed`, arithmetic, string operations)
- âœ… **Phase 7**: Deep state traversal for nested objects
- âœ… **Phase 8**: Reorder templates for sorting/filtering
- âœ… **Phase 9**: Semantic array operations (10x faster learning)

**Real-world coverage: 95-98%** ðŸŽ¯

## Hybrid State Management

Minimact supports both server-side and client-side state:

### Server State (Default)

```tsx
const [count, setCount] = useState(0);
```

- State lives on the server
- State changes trigger server round-trip
- Predictive caching makes updates feel instant
- Secure - business logic stays server-side

### Client State

```tsx
const [query, setQuery] = useClientState('');
```

- State lives only on the client
- Zero latency updates
- Perfect for UI-only state (input values, animations)
- No server communication needed

### Mixing Both

```tsx
function SearchBox() {
    const [query, setQuery] = useClientState('');     // Instant typing
    const [results, setResults] = useState([]);       // Server-managed

    return (
        <div>
            <input
                value={query}
                onInput={e => setQuery(e.target.value)}
            />
            <button onClick={() => setResults(search(query))}>
                Search
            </button>
            <ul>
                {results.map(r => <li key={r.id}>{r.title}</li>)}
            </ul>
        </div>
    );
}
```

## Component Lifecycle

Minimact components follow a similar lifecycle to React:

```tsx
export function DataLoader() {
    const [data, setData] = useState(null);

    useEffect(() => {
        // Runs after component mounts
        fetchData().then(setData);

        return () => {
            // Cleanup when component unmounts
        };
    }, []); // Dependencies array

    return <div>{data ? <DataView data={data} /> : <Loading />}</div>;
}
```

The difference: `useEffect` runs **on the server**, not the client.

## Event Handling

Events work just like React:

```tsx
<button onClick={() => setCount(count + 1)}>
    Increment
</button>

<input onInput={e => setQuery(e.target.value)} />

<form onSubmit={handleSubmit}>
    ...
</form>
```

Behind the scenes:
1. Client sends event to server via SignalR
2. Server processes state change
3. Rust engine generates patch (or uses cached template)
4. Client applies patch to DOM

With predictive caching, step 3 often happens **before** the user clicks, making updates instant.

## SignalR Communication

Minimact uses SignalR for bidirectional real-time communication:

```
Client                          Server
  â”‚                               â”‚
  â”‚â”€â”€â”€â”€â”€â”€â”€ Click Event â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚                               â”‚ Process state change
  â”‚                               â”‚ Generate/retrieve patch
  â”‚<â”€â”€â”€â”€â”€â”€ DOM Patch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                               â”‚
  â”‚ Apply patch to DOM            â”‚
  â”‚ (often from cache)            â”‚
```

The ~5KB client library handles:
- Event delegation and batching
- Patch application
- Predictive cache management
- Optimistic updates

## Type Safety

Full TypeScript â†’ C# type inference:

```tsx
// TypeScript
interface User {
    id: number;
    name: string;
    email: string;
}

const [user, setUser] = useState<User | null>(null);
```

```csharp
// Generated C#
public class User {
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}

private User? _user;
```

Types are enforced end-to-end, catching errors at compile time.

## Next Steps

- Learn about [Predictive Rendering](/guide/predictive-rendering) in detail
- Explore [Hybrid State](/guide/hybrid-state) patterns
- See [Hooks](/guide/hooks) reference
- Try [Server Tasks](/guide/server-tasks) for background processing
