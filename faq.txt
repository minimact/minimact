â“ Why did you build Minimact?

Because I got tired of pretending hydration was acceptable just because itâ€™s familiar. I wanted a better modelâ€”one that didnâ€™t rely on overburdened clients, giant bundles, and reconciliation cycles happening after the user acts.

Minimact was born from a simple, almost heretical question:

â€œWhat if the client didnâ€™t need to reconcile anything at all... because it already knew what would happen?â€

ğŸ¤– Where did the idea of prediction come from?

From AI.

Modern AI systemsâ€”particularly transformers and reinforcement learnersâ€”excel at one thing: prediction.

Whether itâ€™s next tokens, future states, or optimal actions, they all revolve around:

Observing patterns

Modeling likely outcomes

Acting before complete information is available

That inspired me to ask:

What if we could apply predictive modeling principles to the UI itself?

And not through neural nets, but through deterministic, cacheable state transitions.

ğŸ”­ Did AI play a direct role in the architecture?

Indirectly, yes.

I wasn't trying to stuff machine learning into a web framework. But I was asking questions that are common in AI design:

Can we precompute probable futures?

Can we reduce latency by betting on the most likely paths?

Can we let the system adapt to user behavior?

The answers led to a reconciliation engine in Rust, predictive hints, and the entire stored-procedure-for-the-DOM model.

ğŸ“œ What inspired the predictive patch system?

Patterns. Repeated patterns. And hours of staring at logs.

I spent a lot of time chasing down weird bugs and performance issues in large-scale cloud-hosted apps. I saw the same actions happening over and over. Same inputs. Same flows. Same timing. But every interaction was treated like a blank slate.

That felt... deeply inefficient.

Why were we reacting in real-time to things weâ€™ve seen thousands of times?

I wanted to preempt the predictable. Thatâ€™s where the predictive patch cache came from.

ğŸ› ï¸ What was the first thing you prototyped?

A counter. The simplest UI on Earth.

But instead of updating the DOM reactively, I had a server compute what the DOM would look like after a click, then send it down ahead of time. The patch was ready before the user clicked.

That tiny momentâ€”click â†’ instant change â†’ no network delayâ€”felt electric âš¡

I knew then that this wasnâ€™t just an optimization. It was a shift in how we think about UI responsiveness.

ğŸ’¡ Where did usePredictHint() come from?

From wanting to empower developers to optimize their own experiencesâ€”without writing custom cache logic or prediction models.

Hints are like hooks for the future. Instead of managing complex state transitions, you just say:

â€œHey, when they click this, they're probably going to want this state.â€

And the engine handles the restâ€”generating and sending the patch ahead of time. It's the dev saying, "Trust me, this is gonna happen." And the system answering, "Cool. Iâ€™m on it."

ğŸ”„ Why compile TypeScript into C#?

Because I was already working in .NET environments, where business logic, data access, and deployment were C#-centric. But frontend devs still wanted to write React.

Instead of splitting logic across two universes (with brittle APIs and duplicate types), I thought:

What if React UI code could become first-class citizens in C# land?

So I built a Babel plugin that turns JSX/TSX into C# component classes with preserved structure, hooks, and state.

TypeScript handles the ergonomics. C# handles the execution. Rust handles the prediction. ğŸ§ 

ğŸŒ Why not just use HTMX, Blazor, or RSC?

Because none of them fully solved the core problems I was focused on:

Latency: React Server Components still hydrate; Blazor Server does full roundtrips; HTMX requires manual control

Prediction: None of them precompute state transitions based on future interactions

Developer experience: I wanted React ergonomics, not handcrafted event attributes or Razor code

Optimization: I wanted proactive rendering, not reactive patching

Minimact is a response to all of that. Itâ€™s not â€œlike React but on the server.â€ Itâ€™s React reimagined through predictive execution.

ğŸ§  What philosophy drives Minimact?

Donâ€™t hydrate. Anticipate.

Hydration is a patch. Reconciliation is a reaction. Minimact asks: What if the work was done before the user ever clicked?

Itâ€™s built on:

Pattern observation

Predictive modeling

Latency minimization

Developer empowerment

Simplicity over cleverness

The cactus metaphor isnâ€™t just cuteâ€”itâ€™s functional. Cacti thrive by storing what they need before the drought. So should your UI.

ğŸ—ºï¸ Whatâ€™s the long-term vision?

To make web development faster, safer, and smarter by default.

Give developers tools to express performance-critical intent

Eliminate the burden of hydration, bundles, and client state bugs

Use prediction not as a gimmick, but as an architectural pillar

Make UIs feel native-speed without shipping 100KB of JS

Eventually? Predictive UI should feel obvious. Hydration should feel like legacy tech. And Minimact will be the friendly cactus that led the way.

======================

ğŸš€ What is Minimact?

Minimact is a server-side React framework for ASP.NET Core that eliminates client-side hydration using a predictive rendering engine written in Rust.

You write JSX/TSX with familiar React hooks

Itâ€™s transpiled into C# components

The Rust engine precomputes likely UI state transitions

The client caches these transitions (patches) ahead of time

On user interaction, patches are applied instantly with 0ms perceived latency

The server verifies in the background

No hydration. No VDOM diffing. No nonsense.

ğŸ¤– How does prediction work in a UI framework?

Prediction is based on state transitions, not user intent guesses.

Minimact precomputes what the DOM would look like if a specific state change occurred. This is similar to speculative execution in CPUs or stored procedures in databases.

If the user performs the predicted action (e.g., clicks a button, opens a dropdown), the corresponding DOM patch is already cached on the client. It gets applied instantlyâ€”without roundtrips or reconciliation.

ğŸ’¡ What are usePredictHint() hooks?

usePredictHint() lets you hint to the prediction engine that a certain state change is likely.

Example:

usePredictHint('increment', { count: count + 1 });


This tells the system:

â€œHey, I'm pretty sure the userâ€™s going to increment this counterâ€”queue the patch now.â€

Hints improve prediction accuracy and ensure sub-5ms response for latency-sensitive interactions.

â±ï¸ What happens if the prediction is wrong?

No sweat ğŸ˜…

The client applies the wrong patch (visually)

The server notices and corrects the DOM in the background

In most cases, the mismatch is corrected within ~50ms and users donâ€™t even notice

Think of it like optimistic UI but grounded in actual compiled transitions.

ğŸŒ Does this require JavaScript on the client?

Nope. Minimact works with progressive enhancement in mind.

With JS: You get predictive patches, instant UI, and background verification

Without JS: You fall back to full server-rendered HTML with standard form posts or link clicks

Either way, you ship ~5KB of client JS. Thatâ€™s less than the average favicon.

ğŸ› ï¸ Do I need to learn a new syntax or DSL?

No! You use:

JSX/TSX for UI

React hooks (useState, useEffect, useRef, etc.)

Optional semantic hooks (useToggle, useDropdown, useModal)

All your existing ASP.NET Core backend skills

Minimact is more â€œHow you write it stays the sameâ€, not â€œRelearn your tools from scratch.â€

ğŸ” What is hybrid state?

Hybrid state means some state is:

Client-local (e.g. search box input)

Server-managed (e.g. search results, DB-backed lists)

Example:

const [query, setQuery] = useClientState('');
const [results, setResults] = useState([]);


This keeps the UX snappy and secure. You get instant feedback, but the real work happens server-side.

ğŸ” Is this secure? What about business logic?

Yes. Since all logic and rendering happen server-side:

Business logic stays on the server (not exposed to the browser)

No API keys or tokens are shipped to the client

Predictive patches only affect the DOM, not actual application state

And with SignalR in the loop, you always get a verified source of truth.

âš™ï¸ What are the platform requirements?

Youâ€™ll need:

Node.js 18+

.NET 8.0+

Rust (for building the predictive engine from source)

ğŸ’¬ Why not just use React Server Components (RSC)?

You couldâ€¦ but:

RSC still relies on hydration and client bundles

It's tightly coupled to Node/Edge runtimes

It doesn't offer precomputed UI patches

You have to re-learn a bunch of rules and limitations around where hooks can be used

Minimact says: keep your hooks, keep your mental model, and go faster.

ğŸ›£ï¸ Why compile TSX into C#?

Because C# + ASP.NET Core gives you:

Dependency injection

EF Core

.NET ecosystem power

Compile-time type safety

A secure, mature hosting model

You're still writing in TypeScript, but you're compiling into a highly optimized server-native runtime.

ğŸ¦€ Why is Rust involved?

Because Rust is:

Fast: for VDOM diffing and patch computation

Safe: memory-safety guarantees

Compact: great for precomputed patch payloads

It handles the reconciliation + prediction side with zero GC pauses, and can be compiled to WASM in the future.

ğŸ” What happens during an interaction?

The client checks its cache for a predicted patch

If found â†’ apply patch instantly

SignalR sends the event to the server

Server verifies or sends correction patch

If not found â†’ fallback to server-rendered HTML

ğŸ§ª How accurate are predictions?

On average:

Counters, toggles, modals â†’ 95%+

Lists, dropdowns â†’ 70â€“85%

Complex workflows â†’ 60â€“75%

Hinting, telemetry, and usage data can raise these numbers further.

ğŸ§° What tools does Minimact come with?

CLI for project scaffolding and dev server

Babel plugin to compile TSX â†’ C#

Semantic hooks for common UX patterns

Type-safe route generation from your C# API

Built-in templates for dashboards, auth, admin, etc.

ğŸ“Š What are real-world benefits?

ğŸš€ 2Ã— faster interactions vs traditional SSR

ğŸ“‰ Drastically reduced CPU load on low-end clients

ğŸ” Centralized logic and state = better security

ğŸŒ Minimal JS = faster first paint

ğŸ’ª React familiarity = low learning curve

ğŸ§­ Who is Minimact for?

âœ… Teams with .NET backends
âœ… React developers tired of hydration hell
âœ… Apps where performance, security, and UX matter
âœ… Enterprises with regulatory or deployment constraints
âœ… Devs who want predictable behaviorâ€”not runtime roulette

ğŸ™… Who is Minimact not for?

âŒ Fully offline-first apps
âŒ Multiplayer collaborative editors
âŒ Canvas/WebGL-heavy frontends
âŒ Projects that want bleeding-edge React features (e.g. Suspense streaming)

ğŸ“¦ How big is the client bundle?

About 5KB, gzipped.
For comparison:

React: ~30KB+

Vue: ~20KB+

HTMX: ~14KB

Minimact: tiny cactus mode engaged

ğŸ›£ï¸ Is this production-ready?

The core predictor engine is solid. The runtime and Babel tooling are under active development, aiming for alpha Q2 2025.

Follow progress in VISION.md
 or join the Discord
.

ğŸŒµ Whatâ€™s â€œposthydrationismâ€?

A tongue-in-cheek term for rejecting client hydration as the default paradigm. Posthydrationism prefers:

Precomputation over runtime diffing

Stored state transitions over reconciliation

Latency minimalism over JS maximalism

In short:
Donâ€™t hydrate. Anticipate.