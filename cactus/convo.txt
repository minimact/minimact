# ğŸŒµ Cactus Browser

## The Posthydrationist Web

**A revolutionary web browser that treats GitHub as the internet, TSX as HTML, and Minimact as the rendering engine.**

<p align="center">
  <img src="https://img.shields.io/badge/Protocol-gh%3A%2F%2F-green.svg" alt="gh:// Protocol">
  <img src="https://img.shields.io/badge/Engine-Minimact-blue.svg" alt="Minimact Engine">
  <img src="https://img.shields.io/badge/Shell-Tauri-orange.svg" alt="Tauri Shell">
  <img src="https://img.shields.io/badge/Language-TSX-purple.svg" alt="TSX Native">
</p>

---

## Table of Contents

- [What Is This?](#what-is-this)
- [The Problem With Today's Web](#the-problem-with-todays-web)
- [The Solution: Posthydrationist Architecture](#the-solution-posthydrationist-architecture)
- [Core Concepts](#core-concepts)
- [How It Works](#how-it-works)
- [The gh:// Protocol](#the-gh-protocol)
- [Architecture Deep Dive](#architecture-deep-dive)
- [Key Features](#key-features)
- [Performance Comparison](#performance-comparison)
- [Developer Experience](#developer-experience)
- [The Manifesto](#the-manifesto)
- [Getting Started](#getting-started)
- [Roadmap](#roadmap)
- [FAQ](#faq)

---

## What Is This?

**Cactus Browser is a native desktop application that:**

1. Treats **GitHub repositories** as websites
2. Renders **TSX files** as web pages (not HTML)
3. Uses **Minimact** for zero-hydration, predictive rendering
4. Provides **instant interactions** (2-5ms latency)
5. Requires **zero deployment** (just `git push`)

**In other words:** A browser for the web that should have existed from the beginning.

---

## The Problem With Today's Web

### The Legacy Stack (1991-2025)

```
HTML (documents, 1991)
  â””â”€ CSS (styling, 1996)
      â””â”€ JavaScript (interactivity, 1995)
          â””â”€ Frameworks (React, Vue, Angular, 2010+)
              â””â”€ Build tools (Webpack, Vite, 2015+)
                  â””â”€ Deployment (Vercel, Netlify, AWS, 2020+)
```

**The fundamental problem:** We're building **applications** using tools designed for **documents**.

### What This Causes

| Problem | Root Cause | Impact |
|---------|-----------|---------|
| **Slow initial load** | Must download HTML, CSS, JS, then hydrate | 3-5 second TTI |
| **Laggy interactions** | React reconciliation on every state change | 16-50ms latency |
| **Complex deployments** | CI/CD pipelines, build steps, hosting | Hours to deploy |
| **Large bundles** | Ship entire framework + components to client | 500KB+ downloads |
| **Security vulnerabilities** | Client executes arbitrary code | XSS, injection attacks |
| **Poor offline support** | Designed for always-connected clients | Manual PWA setup |

**After 34 years of optimizations, we're still fighting the architecture.**

---

## The Solution: Posthydrationist Architecture

### The New Stack

```
TSX (components, native)
  â””â”€ Minimact (predictive rendering engine)
      â””â”€ GitHub (version-controlled hosting)
          â””â”€ Tauri (native shell)
              â””â”€ gh:// protocol (direct repository access)
```

**The fundamental shift:** Start with the right foundation for applications.

### What This Enables

| Innovation | How It Works | Result |
|-----------|--------------|--------|
| **Zero hydration** | Templates + predictions shipped at load | 100ms TTI |
| **Instant interactions** | Client applies cached predictions | 2-5ms latency |
| **Git-based deployment** | `git push` publishes instantly | Seconds to deploy |
| **Tiny bundles** | Only templates (data), not code | 20KB downloads |
| **Inherent security** | Client interprets data, doesn't execute code | XSS immune |
| **Built-in offline** | Compiled components cached locally | Works offline by default |

---

## Core Concepts

### 1. **GitHub Is the Web**

Traditional web: URLs point to servers running HTML
```
https://example.com/about
  â†“
HTTP request to server
  â†“
Server returns HTML file
```

Cactus Browser: URLs point to GitHub repositories
```
gh://user/repo/pages/about.tsx
  â†“
GitHub API request
  â†“
Repository returns TSX file
```

**Publishing a website:**
```bash
# Traditional
git push
npm run build
vercel deploy
# Wait for CI/CD...
# Site live in 5-10 minutes

# Cactus Browser
git push
# Site live immediately
```

### 2. **TSX Replaces HTML**

Traditional browser: Expects HTML markup
```html
<!DOCTYPE html>
<html>
  <body>
    <div id="root"></div>
    <script src="bundle.js"></script>
  </body>
</html>
```

Cactus Browser: Expects TSX components
```typescript
export function AboutPage() {
  return (
    <div>
      <h1>About Us</h1>
      <p>Welcome to our site</p>
    </div>
  );
}
```

**No HTML. No hydration. Just components.**

### 3. **Minimact Predictive Rendering**

Traditional React: Reconciliation on every state change
```javascript
setState(newValue)
  â†’ React re-runs component
    â†’ Creates new virtual DOM
      â†’ Diffs with old virtual DOM
        â†’ Generates patches
          â†’ Updates real DOM
            â†’ 16-50ms latency
```

Minimact: Predictions applied instantly
```javascript
setState(newValue)
  â†’ Lookup cached prediction
    â†’ Apply template
      â†’ Update DOM
        â†’ 2-5ms latency
```

**The client already knows what will happen before the user clicks.**

### 4. **Data-Driven Architecture**

This principle comes from Liberty Tax Service's optimization strategy:

**Traditional approach (compute on demand):**
```
User changes input
  â†’ Send to server
    â†’ Server computes result
      â†’ Return to client
        â†’ Show result
          â†’ Latency: 200-500ms
```

**Data-driven approach (push instructions forward):**
```
Initial load: Server sends computation instructions
User changes input
  â†’ Client computes result using instructions
    â†’ Show result immediately
      â†’ Latency: 2-5ms
```

**Applied to web rendering:**

Instead of shipping component **code** (executable JavaScript), ship component **templates** (pure data structures).

**Example:**

Traditional (ships code):
```javascript
// Shipped to client - 2KB
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>
    Count: {count}
  </button>;
}
```

Minimact (ships data):
```json
// Shipped to client - 200 bytes
{
  "template": "Count: {0}",
  "binding": "count",
  "path": [0, 2, 1],
  "event": "onclick",
  "action": "increment"
}
```

**Benefits:**
- âœ… 90% smaller (data vs code)
- âœ… Faster parsing (JSON vs JavaScript)
- âœ… Secure (no code execution)
- âœ… Predictable (deterministic behavior)
- âœ… Cacheable (templates never change)

---

## How It Works

### The Complete Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. USER NAVIGATES                                   â”‚
â”‚    gh://facebook/react-docs/pages/hooks.tsx         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. CACTUS BROWSER FETCHES FROM GITHUB               â”‚
â”‚    GitHub API: GET /repos/facebook/react-docs/      â”‚
â”‚                contents/pages/hooks.tsx              â”‚
â”‚    Returns: Raw TSX source code                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. CHECK LOCAL CACHE                                â”‚
â”‚    Cache key: gh://facebook/react-docs@sha/hooks    â”‚
â”‚    Hit: Load compiled version                       â”‚
â”‚    Miss: Continue to compilation                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. BABEL COMPILATION (if cache miss)                â”‚
â”‚    Input:  TSX source code                          â”‚
â”‚    Output: C# component class                       â”‚
â”‚            + Template metadata (JSON)               â”‚
â”‚            + Conditional structures                 â”‚
â”‚            + Loop patterns                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. SERVER-SIDE SIMULATION                           â”‚
â”‚    Rust engine simulates all state combinations     â”‚
â”‚    For each combination:                            â”‚
â”‚      - Render VNode tree                            â”‚
â”‚      - Extract DOM insertion paths                  â”‚
â”‚      - Generate pathVariants map                    â”‚
â”‚    Output: Prediction lookup table                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. INITIAL RENDER                                   â”‚
â”‚    C# runtime: Execute Render() with initial state  â”‚
â”‚    Generate: HTML + embedded templates              â”‚
â”‚    Ship to browser:                                 â”‚
â”‚      - Rendered HTML                                â”‚
â”‚      - Template metadata                            â”‚
â”‚      - PathVariants map                             â”‚
â”‚      - Minimact runtime (13.33 KB)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 7. BROWSER DISPLAYS PAGE                            â”‚
â”‚    Parse HTML, inject into DOM                      â”‚
â”‚    Initialize Minimact client runtime               â”‚
â”‚    Cache templates + predictions locally            â”‚
â”‚    Page is interactive (100ms TTI)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 8. USER INTERACTION (button click)                  â”‚
â”‚    User clicks button â†’ state.count++               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 9. CLIENT-SIDE PREDICTION                           â”‚
â”‚    Lookup template by state binding                 â”‚
â”‚    Build state signature: "count:5"                 â”‚
â”‚    Lookup path from pathVariants                    â”‚
â”‚    Apply template: "Count: {0}" â†’ "Count: 5"        â”‚
â”‚    Update DOM at path [0, 2, 1]                     â”‚
â”‚    â±ï¸ Total time: 2ms                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 10. BACKGROUND VALIDATION (optional)                â”‚
â”‚     Send state change to local C# runtime           â”‚
â”‚     Validate business logic, check permissions      â”‚
â”‚     If incorrect: Send correction patch             â”‚
â”‚     If correct: Do nothing (client was right)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## The gh:// Protocol

### URL Structure

```
gh://[user]/[repo]@[ref]/[path]

Components:
  user  - GitHub username or organization
  repo  - Repository name
  ref   - Branch, tag, or commit SHA (optional, defaults to main)
  path  - Path to TSX file within repo

Examples:
  gh://vercel/next.js/docs/getting-started.tsx
  gh://facebook/react@v18.0.0/docs/hooks.tsx
  gh://you/blog@main/posts/my-article.tsx
  gh://company/app@abc123/pages/dashboard.tsx
```

### Special URLs

```
gh://user/repo                    # Loads pages/index.tsx from main branch
gh://user/repo@branch             # Specific branch
gh://user/repo@v1.0.0             # Specific version tag
gh://user/repo@sha                # Immutable commit reference
gh://user/repo#component-name     # Deep link to component section
gh://user/repo@pull/123/head      # Preview pull request
```

### Folder Conventions

The browser expects a standard folder structure:

```
your-repo/
â”œâ”€â”€ pages/                    # Routable pages
â”‚   â”œâ”€â”€ index.tsx            # gh://user/repo â†’ this file
â”‚   â”œâ”€â”€ about.tsx            # gh://user/repo/about
â”‚   â”œâ”€â”€ blog/
â”‚   â”‚   â”œâ”€â”€ index.tsx        # gh://user/repo/blog
â”‚   â”‚   â””â”€â”€ post-1.tsx       # gh://user/repo/blog/post-1
â”‚   â””â”€â”€ 404.tsx              # Fallback for not found
â”‚
â”œâ”€â”€ components/               # Reusable components
â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”œâ”€â”€ Footer.tsx
â”‚   â””â”€â”€ Button.tsx
â”‚
â”œâ”€â”€ lib/                      # Utilities and helpers
â”‚   â”œâ”€â”€ utils.ts
â”‚   â””â”€â”€ api.ts
â”‚
â”œâ”€â”€ public/                   # Static assets
â”‚   â”œâ”€â”€ images/
â”‚   â””â”€â”€ fonts/
â”‚
â””â”€â”€ minimact.config.json      # Browser configuration
```

### Configuration File

**minimact.config.json:**

```json
{
  "name": "My Awesome Site",
  "version": "1.0.0",
  "description": "A site built for the Posthydrationist Web",
  
  "router": {
    "pagesDir": "pages",
    "componentsDir": "components",
    "fallback": "404.tsx",
    "basePath": "/"
  },
  
  "cache": {
    "strategy": "aggressive",
    "maxSize": "100MB",
    "ttl": 86400
  },
  
  "prediction": {
    "depth": 3,
    "simulationLimit": 1000,
    "enablePreload": true
  },
  
  "build": {
    "typescript": {
      "strict": true,
      "target": "ES2020"
    },
    "babel": {
      "plugins": ["@minimact/babel-plugin-tsx"]
    }
  },
  
  "seo": {
    "title": "My Site",
    "description": "Welcome to my site",
    "author": "Your Name"
  }
}
```

---

## Architecture Deep Dive

### Technology Stack

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PRESENTATION LAYER                          â”‚
â”‚                                             â”‚
â”‚ Tauri (Native Shell)                        â”‚
â”‚   - Desktop app (Windows, macOS, Linux)     â”‚
â”‚   - WebView rendering                       â”‚
â”‚   - Native menus, shortcuts                 â”‚
â”‚   - Protocol handler (gh://)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ COMPILATION LAYER                           â”‚
â”‚                                             â”‚
â”‚ Babel + Minimact Compiler                   â”‚
â”‚   - TSX â†’ AST analysis                      â”‚
â”‚   - Extract templates                       â”‚
â”‚   - Generate C# components                  â”‚
â”‚   - Conditional/loop detection              â”‚
â”‚   - Build pathVariants maps                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RUNTIME LAYER                               â”‚
â”‚                                             â”‚
â”‚ Minimact Runtime (C# + Rust)                â”‚
â”‚   - C#: Component execution                 â”‚
â”‚   - Rust: Prediction engine                 â”‚
â”‚   - Rust: VNode reconciliation              â”‚
â”‚   - Rust: PathConverter (hex â†’ DOM index)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CLIENT LAYER                                â”‚
â”‚                                             â”‚
â”‚ Minimact Client (TypeScript)                â”‚
â”‚   - Template interpreter                    â”‚
â”‚   - Prediction cache                        â”‚
â”‚   - State management                        â”‚
â”‚   - DOM patcher                             â”‚
â”‚   - SignalM protocol (13.33 KB)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DATA LAYER                                  â”‚
â”‚                                             â”‚
â”‚ GitHub API + Local Cache                    â”‚
â”‚   - Repository access                       â”‚
â”‚   - File fetching                           â”‚
â”‚   - Version history                         â”‚
â”‚   - IndexedDB cache                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Component Compilation Pipeline

**Input TSX:**
```typescript
import { useState } from '@minimact/core';

export function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h1>Counter</h1>
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
    </div>
  );
}
```

**Babel Output (C#):**
```csharp
using Minimact.AspNetCore.Core;

namespace Minimact.Components;

[Component]
public partial class Counter : MinimactComponent
{
    [State]
    private int count = 0;
    
    protected override VNode Render()
    {
        return MinimactHelpers.createElement("div", null,
            new VElement("h1", "1.1", new Dictionary<string, string>(), "Counter"),
            new VElement("button", "1.2", new Dictionary<string, string> {
                ["onclick"] = "Handle0"
            }, $"Count: {count}")
        );
    }
    
    public void Handle0()
    {
        setCount(count + 1);
    }
    
    private void setCount(int value)
    {
        SetState("count", value);
    }
}
```

**Template Metadata (JSON):**
```json
{
  "templates": {
    "1.2": {
      "template": "Count: {0}",
      "binding": "count",
      "hexPath": "1.2",
      "type": "text"
    }
  },
  "events": {
    "Handle0": {
      "type": "click",
      "path": "1.2",
      "action": "increment",
      "stateKey": "count"
    }
  },
  "pathVariants": {
    "count:0": [0, 1],
    "count:1": [0, 1],
    "count:*": [0, 1]
  }
}
```

### Prediction System

**How predictions work:**

1. **Build Time (Babel):** Extract all possible structures
```json
{
  "conditionals": {
    "1.3": {
      "expression": "count > 10",
      "branches": {
        "true": { "type": "element", "tag": "div", ... },
        "false": null
      }
    }
  }
}
```

2. **Initial Load (Server Simulation):** Pre-compute paths
```
For count = 0 to 20:
  Render(count)
  Extract DOM paths
  Store in pathVariants
```

3. **Runtime (Client):** Apply cached predictions
```javascript
// User clicks button
state.count = 5;

// Lookup template
const template = templates["1.2"];  // "Count: {0}"

// Apply binding
const text = template.replace("{0}", state.count);  // "Count: 5"

// Update DOM
element.textContent = text;  // 2ms
```

### State Synchronization

**Optimistic client updates with server validation:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ USER CLICKS BUTTON                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CLIENT APPLIES PREDICTION (2ms)     â”‚
â”‚   count: 4 â†’ 5                      â”‚
â”‚   DOM updated instantly             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BACKGROUND: VALIDATE (async)        â”‚
â”‚   Send to local C# runtime          â”‚
â”‚   Check business logic              â”‚
â”‚   Verify permissions                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ VALIDATION RESULT                   â”‚
â”‚   âœ… Correct: Do nothing            â”‚
â”‚   âŒ Wrong: Send correction patch   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Example correction scenario:**
```typescript
// User tries to set quantity to 100
// Client optimistically shows 100
// Server checks inventory: only 50 available
// Server sends correction: quantity = 50
// Client updates DOM: 100 â†’ 50
```

---

## Key Features

### 1. **Zero-Deploy Publishing**

**Traditional workflow:**
```bash
# Write code
vim src/App.tsx

# Build
npm run build
# 30 seconds...

# Deploy
vercel deploy
# Waiting for CI/CD...
# 3-5 minutes...

# Site is live
```

**Cactus Browser workflow:**
```bash
# Write code
vim pages/home.tsx

# Publish
git add .
git commit -m "Update home page"
git push

# Site is live (instantly)
```

### 2. **Fork & Remix**

**Remix any site with one click:**

```
1. Browse to: gh://awesome-dev/cool-ui
2. Click "Fork" button in browser
3. Browser creates: gh://you/cool-ui (forked repo)
4. Built-in editor opens
5. Modify components
6. Save â†’ auto-commits to your fork
7. Now viewing: gh://you/cool-ui (your version)
```

**Every website becomes a starting point for your own.**

### 3. **Time Travel**

**Browse websites through history:**

```
gh://facebook/react@v16.8.0/docs/hooks.tsx
# See the site as it looked when Hooks were introduced

gh://facebook/react@v18.0.0/docs/hooks.tsx
# See the current version

gh://facebook/react@abc123/docs/hooks.tsx
# See any specific commit
```

**Use cases:**
- View historical documentation
- Compare design iterations
- Debug "what changed" issues
- Educational (see evolution of popular sites)

### 4. **Pull Request Previews**

**Every PR is a live preview environment:**

```
Developer creates PR #123
  â†“
Click "Preview" in browser
  â†“
Opens: gh://user/repo@pull/123/head
  â†“
See exact UI changes from PR
  â†“
Leave feedback on visual changes
  â†“
Approve or request changes
```

**Code review + design review in one.**

### 5. **Component Marketplace**

**GitHub becomes npm for components:**

```
Browser search: "authentication component"

Results:
  gh://auth-ui/oauth/Login.tsx        â­ 2.3k
  gh://security/jwt/Auth.tsx          â­ 1.8k
  gh://firebase/auth/SignIn.tsx       â­ 1.2k

Click "Import" on auth-ui/oauth
  â†“
Browser adds as git submodule
  â†“
Use in your code:
  import { Login } from 'gh://auth-ui/oauth';
```

### 6. **Offline-First**

**Works without internet after first visit:**

```
First visit: gh://user/repo
  â†“
Browser fetches TSX from GitHub
  â†“
Compiles locally
  â†“
Caches:
  - Compiled C# components
  - Template metadata
  - Predicted patches
  
Subsequent visits (offline):
  â†“
Load from local cache
  â†“
Site works perfectly
  
When online again:
  â†“
Pull updates from GitHub
  â†“
Re-compile if changed
```

### 7. **Built-In Developer Tools**

**Cactus Browser includes:**

- **Component Inspector:** See component tree, state, props
- **Prediction Debugger:** View cache hit/miss rates, patch timing
- **Git Integration:** Commit, branch, push from browser
- **Live Editor:** Monaco editor with TSX support
- **Visual Diff:** Compare branches/commits visually
- **Performance Profiler:** See rendering metrics in real-time

### 8. **Branch-Based Environments**

**No separate staging/production servers:**

```
Development:  gh://you/app@dev
Staging:      gh://you/app@staging
Production:   gh://you/app@main
Feature:      gh://you/app@feature-auth

# Switch environments = switch branches
# Deploy to staging = merge to staging branch
# Deploy to production = merge to main
# Rollback = git revert
```

---

## Performance Comparison

### Initial Load

| Metric | Traditional (Next.js) | Cactus Browser | Improvement |
|--------|----------------------|----------------|-------------|
| **First Paint** | 500-2000ms | 50-100ms | **10-20Ã— faster** |
| **Time to Interactive** | 3000-5000ms | 100ms | **30-50Ã— faster** |
| **Bundle Size** | 500KB+ | 20KB | **25Ã— smaller** |
| **Hydration Time** | 1000-2000ms | 0ms | **âˆ faster** |

### Runtime Performance

| Metric | React | Cactus Browser | Improvement |
|--------|-------|----------------|-------------|
| **Button Click Latency** | 16-50ms | 2-5ms | **8-10Ã— faster** |
| **State Update** | Reconcile tree | Apply template | **10Ã— faster** |
| **Conditional Toggle** | Re-render branch | Swap element | **15Ã— faster** |
| **List Reorder** | Diff + patch | Move nodes | **5Ã— faster** |

### Real-World Example: Todo App

**Traditional React (Next.js):**
```
Initial Load:     2.1s
Add Todo:         23ms
Toggle Todo:      18ms
Delete Todo:      21ms
Filter Todos:     34ms
Bundle Size:      487KB
```

**Cactus Browser (Minimact):**
```
Initial Load:     89ms    (23Ã— faster)
Add Todo:         3ms     (7Ã— faster)
Toggle Todo:      2ms     (9Ã— faster)
Delete Todo:      2ms     (10Ã— faster)
Filter Todos:     4ms     (8Ã— faster)
Bundle Size:      19KB    (25Ã— smaller)
```

### Network Performance (3G)

| Metric | Traditional | Cactus | Improvement |
|--------|-------------|--------|-------------|
| **Initial HTML** | 50KB | 50KB | Same |
| **CSS Bundle** | 80KB | 0KB | âœ… None needed |
| **JS Framework** | 45KB (React) | 13KB (Minimact) | **3Ã— smaller** |
| **JS Components** | 200KB | 0KB | âœ… Templates only |
| **Total Download** | 375KB | 63KB | **6Ã— smaller** |
| **Load Time (3G)** | 8.2s | 1.4s | **6Ã— faster** |

---

## Developer Experience

### Publishing Your First Site

**1. Initialize project:**
```bash
npx create-cactus-site my-site
cd my-site
```

**2. Project structure created:**
```
my-site/
â”œâ”€â”€ pages/
â”‚   â””â”€â”€ index.tsx
â”œâ”€â”€ components/
â”‚   â””â”€â”€ Layout.tsx
â””â”€â”€ minimact.config.json
```

**3. Write your first page:**
```typescript
// pages/index.tsx
import { useState } from '@minimact/core';

export function HomePage() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h1>Welcome to My Site!</h1>
      <button onClick={() => setCount(count + 1)}>
        Clicks: {count}
      </button>
    </div>
  );
}
```

**4. Publish:**
```bash
git init
git add .
git commit -m "Initial site"
gh repo create --public
git push
```

**5. View your site:**
```
Open Cactus Browser
Navigate to: gh://you/my-site
Site is live!
```

**Total time: ~5 minutes from zero to live site.**

### Development Workflow

**Local development:**
```bash
# Start local dev server (optional)
cactus dev

# Browser auto-reloads on file changes
# Hot reload preserves state (Lifted State Component System)
```

**Making updates:**
```bash
# Edit files
vim pages/about.tsx

# Commit and push
git add .
git commit -m "Add about page"
git push

# Changes live immediately
# No build step required
```

**Preview before publishing:**
```bash
# Create feature branch
git checkout -b feature-new-design

# Make changes
vim pages/home.tsx

# Push to branch
git push origin feature-new-design

# Preview at: gh://you/repo@feature-new-design
```

### Component Development

**Reusable components:**
```typescript
// components/Button.tsx
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
}

export function Button({ label, onClick, variant = 'primary' }: ButtonProps) {
  const className = variant === 'primary' ? 'btn-primary' : 'btn-secondary';
  
  return (
    <button className={className} onClick={onClick}>
      {label}
    </button>
  );
}
```

**Using in pages:**
```typescript
// pages/index.tsx
import { Button } from '../components/Button';

export function HomePage() {
  const handleClick = () => {
    console.log('Button clicked!');
  };
  
  return (
    <div>
      <Button label="Click Me" onClick={handleClick} />
    </div>
  );
}
```

**Publishing as library:**
```bash
# Create component library repo
gh repo create my-components --public

# Others can import:
import { Button } from 'gh://you/my-components/Button';
```

### State Management

**Built-in hooks (familiar React API):**

```typescript
import { 
  useState,           // Local component state
  useMvcState,        // State bound to MVC ViewModel
  useProtectedState,  // State hidden from parent
  useEffect,          // Side effects
  useRef,             // DOM references
  useContext,         // Server-side cache (Redis-like)
  useServerTask,      // Async server tasks
  useComputed         // Derived state
} from '@minimact/core';
```

**Example: Todo app with multiple state patterns:**

```typescript
export function TodoApp() {
  // Local state (client-only)
  const [filter, setFilter] = useState<'all' | 'active' | 'completed'>('all');
  
  // MVC state (bound to server ViewModel)
  const [todos, setTodos] = useMvcState<Todo[]>('todos');
  
  // Protected state (hidden from devtools/parents)
  const [draftText, setDraftText] = useProtectedState('');
  
  // Server task (runs on server)
  const saveTodo = useServerTask(async (todo: Todo) => {
    await db.todos.insert(todo);
  });
  
  // Computed state (derived)
  const filteredTodos = useComputed(() => {
    return todos.filter(t => {
      if (filter === 'active') return !t.completed;
      if (filter === 'completed') return t.completed;
      return true;
    });
  }, [todos, filter]);
  
  return (
    <div>
      <input 
        value={draftText}
        onChange={(e) => setDraftText(e.target.value)}
      />
      <button onClick={() => {
        const newTodo = { id: Date.now(), text: draftText, completed: false };
        setTodos([...todos, newTodo]);
        saveTodo(newTodo);
        setDraftText('');
      }}>
        Add Todo
      </button>
      
      {filteredTodos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </div>
  );
}
```

---

## The Manifesto

### The Posthydrationist Manifesto

The web was built for documents in 1991.  
We are building applications in 2025.

For 34 years, we have been papering over this fundamental mismatch with layers of abstraction, frameworks, and tooling.

HTML â†’ CSS â†’ JavaScript â†’ jQuery â†’ Angular â†’ React â†’ Next.js â†’ ...

Each layer adding complexity.  
Each layer adding weight.  
Each layer adding latency.

**We declare: This ends now.**

The web needs a new foundation.  
Not another framework on top of HTML.  
A new protocol. A new format. A new architecture.

**We are the Posthydrationists.**

---

### Ten Principles

**1. Components Are Native**  
TSX is not a compile target. It is the source language.

**2. Git Is the Protocol**  
Publishing is pushing. Versioning is branching. Rollback is checkout.

**3. Prediction Over Reconciliation**  
The client knows what will happen before it happens.

**4. Data Over Code**  
Ship templates (data), not components (code).

**5. Server Authority**  
Client is optimistic. Server is authoritative. Always.

**6. Zero Hydration**  
If you're hydrating, you've already lost.

**7. Instant Interactions**  
2ms or bust. Users should never wait for UI.

**8. Offline First**  
Cache everything. Work without network. Sync when available.

**9. Fork to Remix**  
Every site is remixable. Composition over creation.

**10. Open by Default**  
Source is visible. Components are forkable. Knowledge is shared.

---

### Why "Posthydrationist"?

**Hydration** is the process of taking server-rendered HTML and "activating" it with JavaScript on the client. It's expensive, slow, and fundamentally flawed.

**Posthydrationism** rejects hydration entirely. The client receives:
1. Rendered HTML (already interactive)
2. Templates (for future updates)
3. Predictions (for instant responses)

**No JavaScript bundle to download and execute.**  
**No virtual DOM to construct.**  
**No reconciliation to perform.**

The era of hydration is over. We are posthydrationist.

---

### The Cactus Philosophy ğŸŒµ

**The cactus doesn't hydrate â€” it stores.**

In the desert, cacti survive by:
- Storing water efficiently (templates cached locally)
- Minimizing needs (tiny 13KB runtime)
- Thriving in harsh conditions (works offline, on slow networks)
- Being resilient (survives server outages)

**Cactus Browser follows the same principles:**
- Store predictions before they're needed
- Minimize client work (just apply templates)
- Thrive on any network (offline-first)
- Be resilient (local compilation, no server dependency)

---

## Getting Started

### Install Cactus Browser

**macOS:**
```bash
brew install cactus-browser
```

**Windows:**
```powershell
winget install cactus-browser
```

**Linux:**
```bash
# Debian/Ubuntu
sudo apt install cactus-browser

# Arch
yay -S cactus-browser
```

**From source:**
```bash
git clone https://github.com/minimact/cactus-browser
cd cactus-browser
cargo build --release
./target/release/cactus-browser
```

### Create Your First Site

**Quick start:**
```bash
npx create-cactus-site my-site
cd my-site
git init
git add .
git commit -m "Initial commit"
gh repo create --public
git push
```

**Open in browser:**
```
Launch Cactus Browser
Navigate to: gh://[your-username]/my-site
```

### Example Sites to Browse

**Official examples:**
```
gh://minimact/examples/todo
gh://minimact/examples/blog
gh://minimact/examples/dashboard
gh://minimact/examples/ecommerce
```

**Community sites:**
```
gh://cactus-community/awesome-sites
# Curated list of sites built with Cactus Browser
```

### Configuration

**Customize your browser:**

Settings â†’ Preferences
```json
{
  "defaultBranch": "main",
  "cache": {
    "enabled": true,
    "maxSize": "1GB",
    "ttl": 86400
  },
  "compilation": {
    "autoCompile": true,
    "strictMode": true
  },
  "devTools": {
    "enabled": true,
    "showPredictions": true,
    "showCacheHits": true
  }
}
```

---

## Roadmap

### Phase 1: Core Browser âœ… (Q1 2025)
- âœ… Tauri shell with basic navigation
- âœ… gh:// protocol handler
- âœ… GitHub API integration
- âœ… Minimact runtime embedded
- âœ… Local compilation (Babel + Minimact)
- âœ… Single-page rendering

### Phase 2: Full Features (Q2 2025)
- ğŸš§ Folder-based routing
- ğŸš§ Local caching (IndexedDB)
- ğŸš§ Branch/tag navigation
- ğŸš§ Component imports
- ğŸš§ Built-in developer tools
- ğŸš§ Hot reload with state preservation

### Phase 3: Developer Tools (Q3 2025)
- â³ Built-in TSX editor (Monaco)
- â³ Live preview
- â³ Component inspector
- â³ Git integration (commit/push from browser)
- â³ Visual diff tool
- â³ Performance profiler

### Phase 4: Advanced Features (Q4 2025)
- â³ Fork & remix UI
- â³ Pull request previews
- â³ Collaborative editing
- â³ Component marketplace
- â³ Mobile browser (Tauri Mobile)
- â³ Browser extensions (Chrome/Firefox)

### Phase 5: Platform Play (2026)
- â³ GitHub partnership
- â³ Official GitHub Action
- â³ GitHub Pages alternative
- â³ Component registry
- â³ Template starter kits
- â³ Enterprise features

---

## FAQ

### General Questions

**Q: Is this just a browser for viewing GitHub files?**  
A: No. It's a full application runtime that happens to use GitHub as its hosting/distribution mechanism. Think of it as a new internet where GitHub repos are websites.

**Q: Do I need to know C# or Rust?**  
A: No. You write TSX (React-style components). The browser handles compilation automatically.

**Q: Can I use existing React components?**  
A: Many React patterns work (useState, useEffect, etc.), but not all libraries are compatible. We're building a compatibility layer for popular libraries.

**Q: Is this production-ready?**  
A: Currently in beta. Core features work, but expect rough edges. Not recommended for mission-critical production use yet.

### Performance Questions

**Q: How is 2ms latency possible?**  
A: The client doesn't compute anythingâ€”it just looks up pre-computed predictions and applies them. No reconciliation, no diffing, just template application.

**Q: What about complex apps with lots of state?**  
A: The prediction system is optimized for this. We use dependency analysis to only simulate reachable state combinations, not all possible combinations.

**Q: Does this work on mobile?**  
A: Desktop browser is available now. Mobile browser (via Tauri Mobile) is in development for iOS/Android.

### Security Questions

**Q: Is it safe to run code from random GitHub repos?**  
A: Yes. The browser compiles TSX locally in a sandbox. Templates are pure data (no code execution). All state changes validated by local C# runtime.

**Q: Can malicious repos exploit the browser?**  
A: No more than viewing a website can exploit Chrome. The compilation/rendering pipeline is sandboxed with the same security model as traditional browsers.

**Q: What about XSS attacks?**  
A: Impossible. Client interprets templates (data), not code. No eval(), no Function(), no code execution path.

### GitHub Questions

**Q: Do I need GitHub Pro?**  
A: No. Free GitHub accounts work fine. Public repos are always free.

**Q: Can I use private repos?**  
A: Yes. Authenticate with GitHub, and the browser can access your private repos.

**Q: What if GitHub goes down?**  
A: Sites you've visited are cached locally and work offline. New sites require GitHub to be available.

**Q: Can I self-host?**  
A: Yes. Point the browser to any git server (GitLab, Gitea, etc.). GitHub is just the default.

### Developer Questions

**Q: How do I debug my site?**  
A: Built-in developer tools (similar to Chrome DevTools) with component inspector, state viewer, and prediction debugger.

**Q: Can I use npm packages?**  
A: Yes, but they must be bundled with your TSX files. We're working on a better import system.

**Q: How do I handle databases?**  
A: Use `useServerTask` to run database queries on the server-side runtime. Client never touches the database directly.

**Q: What about authentication?**  
A: Server-side logic handles auth. Client receives user state as part of the ViewModel. Use `useProtectedState` for sensitive data.

### Comparison Questions

**Q: How is this different from Electron?**  
A: Electron bundles a full Chromium browser. Cactus uses Tauri (lighter, using system WebView) and has a completely different rendering model (Minimact vs HTML/CSS).

**Q: How is this different from GitHub Pages?**  
A: GitHub Pages serves static HTML. Cactus renders TSX components with full interactivity, state management, and server-side logic.

**Q: How is this different from HTMX?**  
A: HTMX sends HTML fragments from server on every interaction. Cactus pre-sends predictions so client can update instantly without round-trips.

**Q: How is this different from Remix/Next.js?**  
A: Remix/Next.js use React hydration and require deployment pipelines. Cactus has zero hydration and deploys via `git push`.

---

## Contributing

We welcome contributions! Here's how to get involved:

### Code Contributions

```bash
# Fork the repo
gh repo fork minimact/cactus-browser

# Clone your fork
git clone https://github.com/[your-username]/cactus-browser
cd cactus-browser

# Create branch
git checkout -b feature-awesome

# Make changes
# ...

# Test
cargo test
npm test

# Commit
git commit -m "Add awesome feature"

# Push
git push origin feature-awesome

# Create pull request
gh pr create
```

### Documentation

Help improve docs:
- Fix typos
- Add examples
- Write tutorials
- Translate to other languages

### Component Libraries

Build and share reusable components:
```bash
# Create component library
npx create-cactus-library my-components

# Publish to GitHub
gh repo create --public
git push

# Others can use:
# import { Button } from 'gh://you/my-components';
```

### Report Issues

Found a bug? [Open an issue](https://github.com/minimact/cactus-browser/issues)

---

## Community

- **Discord:** [discord.gg/cactus-browser](https://discord.gg/cactus-browser)
- **Twitter:** [@CactusBrowser](https://twitter.com/CactusBrowser)
- **Reddit:** [r/CactusBrowser](https://reddit.com/r/CactusBrowser)
- **GitHub Discussions:** [github.com/minimact/cactus-browser/discussions](https://github.com/minimact/cactus-browser/discussions)

---

## License

MIT License - see [LICENSE](LICENSE) for details

---

## Acknowledgments

**Built on the shoulders of giants:**

- **Minimact** - The posthydrationist rendering engine
- **Tauri** - Native desktop framework
- **Rust** - Systems programming language
- **Babel** - JavaScript compiler
- **TypeScript** - Typed superset of JavaScript
- **React** - UI component inspiration
- **GitHub** - Version control and hosting

**Special thanks to:**
- The Minimact community
- Early Cactus Browser testers
- Everyone who believed in the Posthydrationist Web

---

## The Future

**Cactus Browser is just the beginning.**

We're building:
- The Component Economy (marketplace for TSX components)
- The Forkable Web (every site is remixable)
- The Instant Web (2ms interactions everywhere)
- The Offline Web (works without internet)
- The Open Web (source always visible)

**This is the web that should have existed from the start.**

**Join us in building the Posthydrationist Web.** ğŸŒµ

---

<p align="center">
  <strong>The cactus doesn't hydrate â€” it stores.</strong>
</p>

<p align="center">
  <a href="https://github.com/minimact/cactus-browser">â­ Star on GitHub</a> â€¢
  <a href="https://posthydration.dev">ğŸŒ Visit Website</a> â€¢
  <a href="https://discord.gg/cactus-browser">ğŸ’¬ Join Discord</a>
</p>