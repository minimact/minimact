{"version":3,"file":"tracker.min.js","sources":["../src/tracker.ts"],"sourcesContent":["/**\r\n * Mactic Tracker - Client-side change detection for event-driven search\r\n *\r\n * Stop crawling. Start running.\r\n */\r\n\r\nexport interface TrackerConfig {\r\n  apiKey: string;\r\n  apiEndpoint?: string;\r\n\r\n  // Category scoping (required)\r\n  category: string;\r\n\r\n  // Optional tags for fine-grained categorization\r\n  tags?: string[];\r\n\r\n  // Optional ontology path (future hierarchical categories)\r\n  ontologyPath?: string;\r\n\r\n  // Trust level hint\r\n  trustLevel?: 'unverified' | 'verified' | 'authoritative';\r\n\r\n  // Zones to watch for changes\r\n  watchZones: WatchZone[];\r\n\r\n  // Change detection options\r\n  checkInterval?: number; // ms between checks (default: 5000)\r\n  semanticThreshold?: number; // 0-1, how much change triggers notification (default: 0.1)\r\n\r\n  // Enable/disable features\r\n  enableMutationObserver?: boolean; // default: true\r\n  enablePeriodicCheck?: boolean; // default: true\r\n  enableDebugLogging?: boolean; // default: false\r\n}\r\n\r\nexport interface WatchZone {\r\n  selector: string;\r\n  importance: 'low' | 'medium' | 'high';\r\n}\r\n\r\nexport interface ChangeEvent {\r\n  url: string;\r\n  selector: string;\r\n  importance: string;\r\n  content: string;\r\n  title: string;\r\n  description: string;\r\n  timestamp: string;\r\n\r\n  // Category metadata\r\n  category: string;\r\n  tags: string[];\r\n  ontologyPath?: string;\r\n  trustLevel: string;\r\n\r\n  // Source metadata\r\n  domain: string;\r\n  language: string;\r\n\r\n  // Change metadata\r\n  changeType: 'content' | 'structure' | 'metadata';\r\n  oldHash?: string;\r\n  newHash: string;\r\n}\r\n\r\nexport class MacticTracker {\r\n  private config: TrackerConfig;\r\n  private contentHashes: Map<string, string> = new Map();\r\n  private mutationObserver?: MutationObserver;\r\n  private checkIntervalId?: number;\r\n  private initialized: boolean = false;\r\n\r\n  constructor(config: TrackerConfig) {\r\n    // Validate required fields\r\n    if (!config.apiKey) {\r\n      throw new Error('[Mactic] API key is required');\r\n    }\r\n    if (!config.category) {\r\n      throw new Error('[Mactic] Category is required');\r\n    }\r\n    if (!config.watchZones || config.watchZones.length === 0) {\r\n      throw new Error('[Mactic] At least one watch zone is required');\r\n    }\r\n\r\n    this.config = {\r\n      ...config,\r\n      apiEndpoint: config.apiEndpoint || 'https://api.itsmactic.com/api/events',\r\n      checkInterval: config.checkInterval || 5000,\r\n      semanticThreshold: config.semanticThreshold || 0.1,\r\n      enableMutationObserver: config.enableMutationObserver !== false,\r\n      enablePeriodicCheck: config.enablePeriodicCheck !== false,\r\n      enableDebugLogging: config.enableDebugLogging || false,\r\n      tags: config.tags || [],\r\n      trustLevel: config.trustLevel || 'unverified'\r\n    };\r\n\r\n    this.log('Tracker initialized', this.config);\r\n  }\r\n\r\n  /**\r\n   * Initialize the tracker and start monitoring for changes\r\n   */\r\n  public init(): void {\r\n    if (this.initialized) {\r\n      this.log('Tracker already initialized');\r\n      return;\r\n    }\r\n\r\n    // Wait for DOM to be ready\r\n    if (document.readyState === 'loading') {\r\n      document.addEventListener('DOMContentLoaded', () => this.startMonitoring());\r\n    } else {\r\n      this.startMonitoring();\r\n    }\r\n\r\n    this.initialized = true;\r\n    this.log('Tracker started');\r\n  }\r\n\r\n  /**\r\n   * Stop monitoring and cleanup\r\n   */\r\n  public destroy(): void {\r\n    if (this.mutationObserver) {\r\n      this.mutationObserver.disconnect();\r\n      this.mutationObserver = undefined;\r\n    }\r\n\r\n    if (this.checkIntervalId) {\r\n      clearInterval(this.checkIntervalId);\r\n      this.checkIntervalId = undefined;\r\n    }\r\n\r\n    this.contentHashes.clear();\r\n    this.initialized = false;\r\n    this.log('Tracker destroyed');\r\n  }\r\n\r\n  private startMonitoring(): void {\r\n    // Store initial hashes\r\n    this.config.watchZones.forEach(zone => {\r\n      const element = document.querySelector(zone.selector);\r\n      if (element) {\r\n        const hash = this.hashContent(this.getElementContent(element));\r\n        this.contentHashes.set(zone.selector, hash);\r\n        this.log(`Initial hash for ${zone.selector}:`, hash);\r\n      } else {\r\n        this.log(`Warning: Element not found: ${zone.selector}`);\r\n      }\r\n    });\r\n\r\n    // Set up MutationObserver for real-time detection\r\n    if (this.config.enableMutationObserver) {\r\n      this.mutationObserver = new MutationObserver(() => {\r\n        this.checkForChanges();\r\n      });\r\n\r\n      this.mutationObserver.observe(document.body, {\r\n        childList: true,\r\n        subtree: true,\r\n        characterData: true,\r\n        attributes: false // Ignore attribute changes for now\r\n      });\r\n\r\n      this.log('MutationObserver started');\r\n    }\r\n\r\n    // Set up periodic check as fallback\r\n    if (this.config.enablePeriodicCheck) {\r\n      this.checkIntervalId = window.setInterval(() => {\r\n        this.checkForChanges();\r\n      }, this.config.checkInterval);\r\n\r\n      this.log(`Periodic check started (every ${this.config.checkInterval}ms)`);\r\n    }\r\n\r\n    // Initial check\r\n    this.checkForChanges();\r\n  }\r\n\r\n  private async checkForChanges(): Promise<void> {\r\n    for (const zone of this.config.watchZones) {\r\n      const element = document.querySelector(zone.selector);\r\n      if (!element) continue;\r\n\r\n      const content = this.getElementContent(element);\r\n      const currentHash = this.hashContent(content);\r\n      const previousHash = this.contentHashes.get(zone.selector);\r\n\r\n      if (currentHash !== previousHash && previousHash !== undefined) {\r\n        this.log(`Change detected in ${zone.selector}`);\r\n        await this.notifyChange(zone, element, content, previousHash, currentHash);\r\n        this.contentHashes.set(zone.selector, currentHash);\r\n      }\r\n    }\r\n  }\r\n\r\n  private getElementContent(element: Element): string {\r\n    // Extract text content, stripping excessive whitespace\r\n    return (element.textContent || '')\r\n      .replace(/\\s+/g, ' ')\r\n      .trim();\r\n  }\r\n\r\n  private hashContent(content: string): string {\r\n    // Simple hash function (DJB2)\r\n    // For MVP - can be upgraded to crypto hash or embedding-based later\r\n    let hash = 5381;\r\n    for (let i = 0; i < content.length; i++) {\r\n      const char = content.charCodeAt(i);\r\n      hash = ((hash << 5) + hash) + char; // hash * 33 + char\r\n    }\r\n    return hash.toString(36);\r\n  }\r\n\r\n  private async notifyChange(\r\n    zone: WatchZone,\r\n    element: Element,\r\n    content: string,\r\n    oldHash: string,\r\n    newHash: string\r\n  ): Promise<void> {\r\n    const event: ChangeEvent = {\r\n      url: window.location.href,\r\n      selector: zone.selector,\r\n      importance: zone.importance,\r\n      content: content.substring(0, 10000), // Limit content size\r\n      title: document.title,\r\n      description: this.getMetaDescription(),\r\n      timestamp: new Date().toISOString(),\r\n\r\n      // Category metadata\r\n      category: this.config.category,\r\n      tags: this.config.tags || [],\r\n      ontologyPath: this.config.ontologyPath,\r\n      trustLevel: this.config.trustLevel || 'unverified',\r\n\r\n      // Source metadata\r\n      domain: window.location.hostname,\r\n      language: document.documentElement.lang || 'en',\r\n\r\n      // Change metadata\r\n      changeType: 'content',\r\n      oldHash,\r\n      newHash\r\n    };\r\n\r\n    this.log('Notifying change:', event);\r\n\r\n    try {\r\n      const response = await fetch(this.config.apiEndpoint!, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'X-API-Key': this.config.apiKey\r\n        },\r\n        body: JSON.stringify(event)\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\r\n      }\r\n\r\n      const result = await response.json();\r\n      this.log('Change notification sent successfully:', result);\r\n    } catch (error) {\r\n      console.error('[Mactic] Failed to notify change:', error);\r\n      // Don't throw - we don't want to break the page\r\n    }\r\n  }\r\n\r\n  private getMetaDescription(): string {\r\n    const meta = document.querySelector('meta[name=\"description\"]');\r\n    return meta?.getAttribute('content') || '';\r\n  }\r\n\r\n  private log(message: string, ...args: any[]): void {\r\n    if (this.config.enableDebugLogging) {\r\n      console.log(`[Mactic] ${message}`, ...args);\r\n    }\r\n  }\r\n}\r\n\r\n// Global API for easy initialization\r\nexport const init = (config: TrackerConfig): MacticTracker => {\r\n  const tracker = new MacticTracker(config);\r\n  tracker.init();\r\n  return tracker;\r\n};\r\n\r\n// Export for UMD bundle\r\nif (typeof window !== 'undefined') {\r\n  (window as any).MacticTracker = {\r\n    MacticTracker,\r\n    init\r\n  };\r\n}\r\n"],"names":["MacticTracker","constructor","config","this","contentHashes","Map","initialized","apiKey","Error","category","watchZones","length","apiEndpoint","checkInterval","semanticThreshold","enableMutationObserver","enablePeriodicCheck","enableDebugLogging","tags","trustLevel","log","init","document","readyState","addEventListener","startMonitoring","destroy","mutationObserver","disconnect","undefined","checkIntervalId","clearInterval","clear","forEach","zone","element","querySelector","selector","hash","hashContent","getElementContent","set","MutationObserver","checkForChanges","observe","body","childList","subtree","characterData","attributes","window","setInterval","content","currentHash","previousHash","get","notifyChange","textContent","replace","trim","i","charCodeAt","toString","oldHash","newHash","event","url","location","href","importance","substring","title","description","getMetaDescription","timestamp","Date","toISOString","ontologyPath","domain","hostname","language","documentElement","lang","changeType","response","fetch","method","headers","JSON","stringify","ok","status","statusText","result","json","error","console","meta","getAttribute","message","args","tracker"],"mappings":"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"}