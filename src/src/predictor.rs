use crate::vdom::{VNode, Patch, TemplatePatch, ComponentMetadata, LoopTemplate};
use crate::reconciler::reconcile;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Represents a change to component state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateChange {
    /// Component identifier
    pub component_id: String,
    /// State key that changed
    pub state_key: String,
    /// Old value (JSON serialized)
    pub old_value: serde_json::Value,
    /// New value (JSON serialized)
    pub new_value: serde_json::Value,
}

/// Pattern type detected from state changes
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PatternType {
    /// Numeric increment (e.g., 0→1, 1→2, 2→3)
    NumericIncrement,
    /// Numeric decrement (e.g., 5→4, 4→3, 3→2)
    NumericDecrement,
    /// Boolean toggle (true↔false)
    BooleanToggle,
    /// String/object change (no pattern)
    Literal,
}

/// Source of template prediction (for tracking/debugging)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum TemplateSource {
    /// Generated by Babel plugin at compile time (perfect accuracy)
    BabelGenerated,
    /// Extracted by Rust at runtime (inferred from observations)
    RuntimeExtracted,
    /// Hybrid: Babel template refined by runtime observations
    BabelRefined,
}

/// Represents a prediction of how a state change will affect the DOM
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Prediction {
    /// The state change that triggers this prediction
    pub state_change: StateChange,
    /// Predicted patches to the DOM
    pub predicted_patches: Vec<Patch>,
    /// Confidence score (0.0 to 1.0)
    pub confidence: f32,
    /// The predicted new VNode tree (optional, for validation)
    pub predicted_tree: Option<VNode>,
}

/// Template-based prediction (covers infinite values with one pattern)
#[derive(Debug, Clone, Serialize, Deserialize)]
struct TemplatePrediction {
    /// State key that this template applies to
    state_key: String,
    /// Template patches (one pattern for all values)
    patches: Vec<Patch>,
    /// Source of this template (Babel vs runtime extraction)
    source: TemplateSource,
    /// Number of times this template was successfully used
    usage_count: usize,
    /// Number of correct predictions
    correct_count: usize,
    /// Number of incorrect predictions
    incorrect_count: usize,
}

impl TemplatePrediction {
    fn hit_rate(&self) -> f32 {
        let total = self.correct_count + self.incorrect_count;
        if total == 0 {
            return 1.0; // Assume high confidence if never tested
        }
        self.correct_count as f32 / total as f32
    }
}

/// The predictor engine that learns patterns and makes predictions
#[derive(Serialize, Deserialize)]
pub struct Predictor {
    /// Historical patterns: maps state changes to observed patches
    patterns: HashMap<String, Vec<PredictionPattern>>,
    /// Template-based predictions (NEW: 98% memory reduction!)
    /// Maps state key to template patches that work for ANY value
    template_predictions: HashMap<String, TemplatePrediction>,
    /// Configuration
    config: PredictorConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct PredictionPattern {
    /// The state change pattern
    #[allow(dead_code)]
    state_change_key: String,
    /// Detected pattern type
    pattern_type: PatternType,
    /// The observed patches
    patches: Vec<Patch>,
    /// Number of times this pattern was observed
    observation_count: usize,
    /// Last VNode tree before the change
    old_tree: Option<VNode>,
    /// Last VNode tree after the change
    new_tree: Option<VNode>,
    /// Seconds since pattern was last accessed (serialized from Instant)
    #[serde(skip, default = "std::time::Instant::now")]
    last_accessed: std::time::Instant,
    /// Seconds since pattern was created (serialized from Instant)
    #[serde(skip, default = "std::time::Instant::now")]
    created_at: std::time::Instant,
    /// Number of predictions made using this pattern
    predictions_made: usize,
    /// Number of correct predictions
    predictions_correct: usize,
    /// Number of incorrect predictions
    predictions_incorrect: usize,
}

impl PredictionPattern {
    /// Calculate hit rate for this pattern
    fn hit_rate(&self) -> f32 {
        if self.predictions_made == 0 {
            return 0.0;
        }
        self.predictions_correct as f32 / self.predictions_made as f32
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PredictorConfig {
    /// Minimum confidence threshold to send predictions
    pub min_confidence: f32,
    /// Maximum number of patterns to track per state key
    pub max_patterns_per_key: usize,
    /// Whether to use ML-based prediction (future enhancement)
    pub use_ml: bool,
    /// Maximum number of unique state keys to track
    pub max_state_keys: usize,
    /// Maximum total memory usage in bytes (approximate)
    pub max_memory_bytes: usize,
    /// Eviction policy when limits are reached
    pub eviction_policy: EvictionPolicy,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum EvictionPolicy {
    /// Remove least recently used patterns
    LeastRecentlyUsed,
    /// Remove least frequently observed patterns
    LeastFrequentlyUsed,
    /// Remove oldest patterns first
    OldestFirst,
}

impl Default for PredictorConfig {
    fn default() -> Self {
        Self {
            min_confidence: 0.7,
            max_patterns_per_key: 100,
            use_ml: false,
            max_state_keys: 1000,
            max_memory_bytes: 100 * 1024 * 1024, // 100 MB
            eviction_policy: EvictionPolicy::LeastFrequentlyUsed,
        }
    }
}

impl Predictor {
    /// Create a new predictor with default config
    pub fn new() -> Self {
        Self::with_config(PredictorConfig::default())
    }

    /// Create a new predictor with custom config
    pub fn with_config(config: PredictorConfig) -> Self {
        Self {
            patterns: HashMap::new(),
            template_predictions: HashMap::new(),
            config,
        }
    }

    /// Detect pattern type from state change
    fn detect_pattern_type(state_change: &StateChange) -> PatternType {
        use serde_json::Value;

        match (&state_change.old_value, &state_change.new_value) {
            // Boolean toggle
            (Value::Bool(old), Value::Bool(new)) if old != new => PatternType::BooleanToggle,

            // Numeric increment
            (Value::Number(old), Value::Number(new)) => {
                if let (Some(old_val), Some(new_val)) = (old.as_f64(), new.as_f64()) {
                    if new_val > old_val {
                        PatternType::NumericIncrement
                    } else if new_val < old_val {
                        PatternType::NumericDecrement
                    } else {
                        PatternType::Literal
                    }
                } else {
                    PatternType::Literal
                }
            }

            // Everything else is literal
            _ => PatternType::Literal,
        }
    }

    /// Check if a state change matches a pattern type
    fn matches_pattern_type(state_change: &StateChange, pattern_type: PatternType) -> bool {
        Self::detect_pattern_type(state_change) == pattern_type
    }

    /// Extract template from UpdateText patches
    /// Detects if a patch content change follows a pattern with state variable(s)
    fn extract_template(
        &self,
        state_change: &StateChange,
        old_patches: &[Patch],
        new_patches: &[Patch],
        all_state: &HashMap<String, serde_json::Value>,
    ) -> Option<Vec<Patch>> {
        use serde_json::Value;

        // NEW: Try loop template first (for array state changes)
        if matches!(&state_change.new_value, Value::Array(_)) {
            if let Some(loop_patches) = self.extract_loop_template(
                state_change,
                old_patches,
                new_patches,
                all_state
            ) {
                return Some(loop_patches);
            }
        }

        // Only handle single patch for existing logic (Phases 1-3)
        if old_patches.len() != 1 || new_patches.len() != 1 {
            return None;
        }

        match (&old_patches[0], &new_patches[0]) {
            (
                Patch::UpdateText { path: old_path, content: old_content },
                Patch::UpdateText { path: new_path, content: new_content }
            ) if old_path == new_path => {
                // Phase 2: Try conditional template first (for booleans)
                if let Value::Bool(_) = &state_change.old_value {
                    if let Some(template_patch) = self.extract_conditional_template(
                        state_change,
                        old_content,
                        new_content,
                        old_path
                    ) {
                        return Some(vec![Patch::UpdateTextTemplate {
                            path: old_path.clone(),
                            template_patch,
                        }]);
                    }
                }

                // Phase 1: Simple single-variable template
                let old_value_str = match &state_change.old_value {
                    Value::Number(n) => n.to_string(),
                    Value::String(s) => s.clone(),
                    Value::Bool(b) => b.to_string(),
                    _ => return None,
                };

                let new_value_str = match &state_change.new_value {
                    Value::Number(n) => n.to_string(),
                    Value::String(s) => s.clone(),
                    Value::Bool(b) => b.to_string(),
                    _ => return None,
                };

                // Check if old_content contains old_value
                if let Some(pos) = old_content.find(&old_value_str) {
                    // Extract template by replacing old value with {0}
                    let template = old_content.replace(&old_value_str, "{0}");

                    // Verify template works for new value
                    let expected = template.replace("{0}", &new_value_str);
                    if expected == *new_content {
                        // ✅ Pattern found!
                        crate::log_info!(
                            "📐 Simple template extracted for {}::{}: '{}'",
                            state_change.component_id,
                            state_change.state_key,
                            template
                        );

                        return Some(vec![Patch::UpdateTextTemplate {
                            path: old_path.clone(),
                            template_patch: TemplatePatch {
                                template,
                                bindings: vec![state_change.state_key.clone()],
                                slots: vec![pos],
                                conditional_templates: None,
                                conditional_binding_index: None,
                            },
                        }]);
                    }
                }

                // Phase 3: Try multi-variable template
                // This catches cases like "Hello, {firstName} {lastName}!"
                if let Some(template_patch) = self.extract_multi_variable_template(
                    old_content,
                    new_content,
                    all_state
                ) {
                    return Some(vec![Patch::UpdateTextTemplate {
                        path: old_path.clone(),
                        template_patch,
                    }]);
                }

                None
            }
            _ => None,
        }
    }

    /// Extract conditional template for boolean state changes
    /// Example: true → "Active", false → "Inactive"
    fn extract_conditional_template(
        &self,
        state_change: &StateChange,
        old_content: &str,
        new_content: &str,
        path: &[usize],
    ) -> Option<TemplatePatch> {
        use serde_json::Value;
        use std::collections::HashMap;

        // Only for boolean toggles
        let (old_bool, new_bool) = match (&state_change.old_value, &state_change.new_value) {
            (Value::Bool(old), Value::Bool(new)) if old != new => (*old, *new),
            _ => return None,
        };

        // Check if the content completely changed (no common substring pattern)
        // This indicates a conditional template
        if old_content != new_content && !old_content.contains(new_content) && !new_content.contains(old_content) {
            let mut conditional_map = HashMap::new();
            conditional_map.insert(old_bool.to_string(), old_content.to_string());
            conditional_map.insert(new_bool.to_string(), new_content.to_string());

            crate::log_info!(
                "📐 Conditional template extracted for {}::{}: '{}' ↔ '{}'",
                state_change.component_id,
                state_change.state_key,
                old_content,
                new_content
            );

            return Some(TemplatePatch {
                template: "{0}".to_string(), // Placeholder, actual value from conditional_templates
                bindings: vec![state_change.state_key.clone()],
                slots: vec![0],
                conditional_templates: Some(conditional_map),
                conditional_binding_index: Some(0),
            });
        }

        None
    }

    /// Extract multi-variable template by finding changed substrings
    /// Detects multiple variable changes in content like "Hello, {firstName} {lastName}!"
    ///
    /// Algorithm:
    ///   1. Find longest common prefix/suffix to identify stable parts
    ///   2. Extract changing parts from the middle
    ///   3. Build template with placeholders for changed parts
    ///   4. Match changed parts to state variables from all_state
    ///
    /// Example:
    ///   old_content: "User: John Doe"
    ///   new_content: "User: Jane Smith"
    ///   all_state: { "firstName": "John", "lastName": "Doe" }
    ///   → template: "User: {0} {1}", bindings: ["firstName", "lastName"]
    fn extract_multi_variable_template(
        &self,
        old_content: &str,
        new_content: &str,
        all_state: &HashMap<String, serde_json::Value>
    ) -> Option<TemplatePatch> {
        use serde_json::Value;

        // For multi-variable templates, we need to detect which state variables appear
        // Since we only have one changing state variable at a time in state_change,
        // we need to find OTHER state variables that are also in the content

        #[derive(Clone)]
        struct ValueMatch {
            state_key: String,
            value_str: String,
            position: usize,
        }

        let mut matches: Vec<ValueMatch> = Vec::new();

        // Find all primitive state values that appear in old_content
        for (key, value) in all_state {
            let value_str = match value {
                Value::String(s) if !s.is_empty() => s.clone(),
                Value::Number(n) => n.to_string(),
                Value::Bool(b) => b.to_string(),
                _ => continue,
            };

            // Find this value in old_content
            if let Some(pos) = old_content.find(&value_str) {
                matches.push(ValueMatch {
                    state_key: key.clone(),
                    value_str,
                    position: pos,
                });
            }
        }

        // Need at least 2 variables for multi-variable template
        if matches.len() < 2 {
            return None;
        }

        // Sort by position (leftmost first)
        matches.sort_by_key(|m| m.position);

        // Check for overlapping matches (ambiguous)
        for i in 0..matches.len() - 1 {
            let end_pos = matches[i].position + matches[i].value_str.len();
            if end_pos > matches[i + 1].position {
                // Overlapping - can't extract clean template
                return None;
            }
        }

        // Build template by replacing values with {0}, {1}, etc.
        let mut template = old_content.to_string();
        let mut bindings = Vec::new();
        let mut slots = Vec::new();
        let mut offset: isize = 0;

        for (index, vm) in matches.iter().enumerate() {
            let placeholder = format!("{{{}}}", index);
            let actual_pos = (vm.position as isize + offset) as usize;
            let value_len = vm.value_str.len();

            // Bounds check
            if actual_pos + value_len > template.len() {
                return None;
            }

            // Replace value with placeholder
            template.replace_range(
                actual_pos..(actual_pos + value_len),
                &placeholder
            );

            bindings.push(vm.state_key.clone());
            slots.push(vm.position);

            // Update offset
            offset += placeholder.len() as isize - value_len as isize;
        }

        // Now we need to render with NEW values to verify it matches new_content
        // Problem: we don't have new_state, only all_state (which has old values)
        // So we need to infer the new values from the diff

        // For now, verify that the template structure is correct by checking
        // if we can find corresponding values in new_content at similar positions
        let mut test_render = template.clone();
        let old_values: Vec<&str> = matches.iter().map(|m| m.value_str.as_str()).collect();

        // Try to extract new values from new_content using the template structure
        let mut new_values = Vec::new();
        let mut search_pos = 0;

        for (i, _) in matches.iter().enumerate() {
            let placeholder = format!("{{{}}}", i);
            if let Some(ph_pos) = test_render.find(&placeholder) {
                // Find what comes after this placeholder in template
                let after_ph = &test_render[(ph_pos + placeholder.len())..];

                // Find the next fixed part (or end of string)
                let next_fixed = if let Some(next_ph_idx) = after_ph.find('{') {
                    &after_ph[..next_ph_idx]
                } else {
                    after_ph
                };

                // In new_content, find where this fixed part appears
                let search_from = search_pos;
                if let Some(fixed_pos) = new_content[search_from..].find(next_fixed) {
                    let value_end = search_from + fixed_pos;
                    let new_value = &new_content[search_pos..value_end];
                    new_values.push(new_value.to_string());
                    search_pos = value_end + next_fixed.len();
                } else if next_fixed.is_empty() {
                    // Last placeholder - take rest of string
                    new_values.push(new_content[search_pos..].to_string());
                    search_pos = new_content.len();
                } else {
                    // Can't find the fixed part - template doesn't match
                    return None;
                }
            }
        }

        // Verify by rendering template with new values
        let mut rendered = template.clone();
        for (i, new_val) in new_values.iter().enumerate() {
            rendered = rendered.replace(&format!("{{{}}}", i), new_val);
        }

        if rendered == new_content {
            crate::log_info!(
                "📐 Multi-variable template extracted with {} bindings: '{}'",
                bindings.len(),
                template
            );

            return Some(TemplatePatch {
                template,
                bindings,
                slots,
                conditional_templates: None,
                conditional_binding_index: None,
            });
        }

        None
    }

    /// Extract loop template from array state change (Phase 4)
    ///
    /// Detects patterns like:
    ///   Old: [{ id: 1, text: "A" }, { id: 2, text: "B" }]
    ///   New: [{ id: 1, text: "A" }, { id: 2, text: "B" }, { id: 3, text: "C" }]
    ///   Patches: [Create { path: [0, 2], node: <li>C</li> }]
    ///
    /// Extracts:
    ///   LoopTemplate {
    ///     array_binding: "todos",
    ///     item_template: Element { tag: "li", children: [Text("{item.text}")] }
    ///   }
    fn extract_loop_template(
        &self,
        state_change: &StateChange,
        _old_patches: &[Patch],
        new_patches: &[Patch],
        all_state: &HashMap<String, serde_json::Value>
    ) -> Option<Vec<Patch>> {
        use serde_json::Value;
        use crate::vdom::{LoopTemplate, ItemTemplate};

        // 1. Detect array state change
        let new_array = match &state_change.new_value {
            Value::Array(arr) => arr,
            _ => return None,
        };

        if new_array.is_empty() {
            return None; // Can't extract template from empty array
        }

        // 2. Detect structural changes (Create/Remove/Replace)
        let created_nodes: Vec<(&VNode, &Vec<usize>)> = new_patches.iter()
            .filter_map(|p| {
                if let Patch::Create { path, node } = p {
                    Some((node, path))
                } else {
                    None
                }
            })
            .collect();

        if created_nodes.is_empty() {
            return None; // No new nodes created, not a loop pattern
        }

        // 3. Try to extract item template from first created node
        let (first_node, first_path) = created_nodes[0];
        let item_template = self.extract_item_template(
            first_node,
            &state_change.state_key,
            new_array
        )?;

        // 4. Get parent path (path without last element)
        let parent_path = if first_path.is_empty() {
            vec![]
        } else {
            first_path[..first_path.len() - 1].to_vec()
        };

        // 5. Build loop template
        let loop_template = LoopTemplate {
            array_binding: state_change.state_key.clone(),
            item_template,
            index_var: None, // TODO: Detect if index is used
            separator: None, // TODO: Detect separators
        };

        crate::log_info!(
            "📐 Loop template extracted for {}::{}: {} items",
            state_change.component_id,
            state_change.state_key,
            new_array.len()
        );

        Some(vec![Patch::UpdateListTemplate {
            path: parent_path,
            loop_template,
        }])
    }

    /// Extract item template from a VNode
    /// Finds variable bindings from array items
    fn extract_item_template(
        &self,
        node: &VNode,
        array_state_key: &str,
        array_items: &[serde_json::Value]
    ) -> Option<crate::vdom::ItemTemplate> {
        if array_items.is_empty() {
            return None;
        }

        match node {
            VNode::Text(text_node) => {
                // Extract text template with item bindings
                self.extract_text_item_template(&text_node.content, array_items)
            }
            VNode::Element(element) => {
                // Extract element template with child templates
                self.extract_element_item_template(element, array_items)
            }
        }
    }

    /// Extract text item template
    /// Example: "Buy milk" → "{item.text}"
    fn extract_text_item_template(
        &self,
        content: &str,
        array_items: &[serde_json::Value]
    ) -> Option<crate::vdom::ItemTemplate> {
        use serde_json::Value;
        use crate::vdom::{ItemTemplate, TemplatePatch};

        // Try to find which array item property matches this content
        if let Some(Value::Object(first_item)) = array_items.get(0) {
            // Search for property that matches content
            for (key, value) in first_item {
                let value_str = match value {
                    Value::String(s) => s.clone(),
                    Value::Number(n) => n.to_string(),
                    Value::Bool(b) => b.to_string(),
                    _ => continue,
                };

                if content.contains(&value_str) {
                    // Found match! Build template
                    let pos = content.find(&value_str)?;
                    let template = content.replace(&value_str, "{0}");
                    let binding = format!("item.{}", key);

                    crate::log_info!(
                        "📐 Text item template: '{}' with binding '{}'",
                        template,
                        binding
                    );

                    return Some(ItemTemplate::Text {
                        template_patch: TemplatePatch {
                            template,
                            bindings: vec![binding],
                            slots: vec![pos],
                            conditional_templates: None,
                            conditional_binding_index: None,
                        }
                    });
                }
            }
        }

        None
    }

    /// Extract element item template
    /// Example: <li class="todo">Buy milk</li> → Element template
    fn extract_element_item_template(
        &self,
        element: &crate::vdom::VElement,
        array_items: &[serde_json::Value]
    ) -> Option<crate::vdom::ItemTemplate> {
        use crate::vdom::ItemTemplate;

        // For Phase 4A (simple text lists), we only handle text children
        // Phase 4B will add support for props_templates

        // Extract children templates
        let mut children_templates = Vec::new();

        for child in &element.children {
            match child {
                VNode::Text(text_node) => {
                    if let Some(text_template) = self.extract_text_item_template(
                        &text_node.content,
                        array_items
                    ) {
                        children_templates.push(text_template);
                    }
                }
                VNode::Element(child_element) => {
                    if let Some(element_template) = self.extract_element_item_template(
                        child_element,
                        array_items
                    ) {
                        children_templates.push(element_template);
                    }
                }
            }
        }

        // Extract key binding if element has key
        let key_binding = if let Some(_key) = &element.key {
            // Try to find which property is the key
            // For now, default to "item.id"
            Some("item.id".to_string())
        } else {
            None
        };

        let children = if children_templates.is_empty() {
            None
        } else {
            Some(children_templates)
        };

        crate::log_info!(
            "📐 Element item template: <{}> with {} children",
            element.tag,
            element.children.len()
        );

        Some(ItemTemplate::Element {
            tag: element.tag.clone(),
            props_templates: None, // TODO: Phase 4B
            children_templates: children,
            key_binding,
        })
    }

    /// Save predictor state to JSON string
    pub fn save_to_json(&self) -> crate::error::Result<String> {
        serde_json::to_string_pretty(self)
            .map_err(|e| crate::error::MinimactError::Serialization(
                format!("Failed to serialize predictor: {}", e)
            ))
    }

    /// Load predictor state from JSON string
    pub fn load_from_json(json: &str) -> crate::error::Result<Self> {
        let mut predictor: Predictor = serde_json::from_str(json)
            .map_err(|e| crate::error::MinimactError::Serialization(
                format!("Failed to deserialize predictor: {}", e)
            ))?;

        // Reset Instant fields to current time since they can't be serialized
        let now = std::time::Instant::now();
        for patterns in predictor.patterns.values_mut() {
            for pattern in patterns.iter_mut() {
                pattern.last_accessed = now;
                pattern.created_at = now;
            }
        }

        Ok(predictor)
    }

    /// Learn from an observed state change and its resulting patches
    ///
    /// # Parameters
    /// * `state_change` - The state change that triggered this render
    /// * `old_tree` - VNode tree before the change
    /// * `new_tree` - VNode tree after the change
    /// * `all_state` - Complete component state (for multi-variable template extraction)
    pub fn learn(
        &mut self,
        state_change: StateChange,
        old_tree: &VNode,
        new_tree: &VNode,
        all_state: Option<&HashMap<String, serde_json::Value>>
    ) -> crate::error::Result<()> {
        crate::log_debug!("Learning pattern for {}::{}", state_change.component_id, state_change.state_key);

        let new_patches = match reconcile(old_tree, new_tree) {
            Ok(p) => p,
            Err(e) => {
                crate::metrics::METRICS.record_learn(true);
                return Err(e);
            }
        };

        // Try to extract template (supports single and multi-variable)
        let old_patches = match reconcile(old_tree, old_tree) {
            Ok(p) => p,
            Err(_) => vec![],
        };

        // Use all_state if provided, otherwise create empty HashMap
        let empty_state = HashMap::new();
        let state_ref = all_state.unwrap_or(&empty_state);

        if let Some(template_patches) = self.extract_template(&state_change, &old_patches, &new_patches, state_ref) {
            // Store template prediction
            let pattern_key = self.make_pattern_key(&state_change);
            self.template_predictions.insert(
                pattern_key.clone(),
                TemplatePrediction {
                    state_key: state_change.state_key.clone(),
                    patches: template_patches,
                    source: TemplateSource::RuntimeExtracted,
                    usage_count: 0,
                    correct_count: 0,
                    incorrect_count: 0,
                }
            );
            crate::log_info!("📐 Runtime-extracted template prediction stored for {}", pattern_key);
            crate::metrics::METRICS.record_learn(false);
            return Ok(());
        }

        // Fall back to concrete patch learning
        let patches = new_patches;
        let pattern_key = self.make_pattern_key(&state_change);

        // Check memory limits before adding new patterns
        self.enforce_memory_limits()?;

        let patterns = self.patterns.entry(pattern_key.clone()).or_insert_with(Vec::new);

        // Detect pattern type
        let pattern_type = Self::detect_pattern_type(&state_change);

        // Try to find existing similar pattern OF THE SAME TYPE
        let existing_idx = patterns.iter().position(|p| {
            p.pattern_type == pattern_type &&
            p.patches.len() == patches.len() &&
            p.patches.iter().zip(patches.iter()).all(|(p1, p2)| {
                std::mem::discriminant(p1) == std::mem::discriminant(p2)
            })
        });

        let now = std::time::Instant::now();

        if let Some(idx) = existing_idx {
            // Increment observation count for this pattern
            patterns[idx].observation_count += 1;
            patterns[idx].old_tree = Some(old_tree.clone());
            patterns[idx].new_tree = Some(new_tree.clone());
            patterns[idx].last_accessed = now;
        } else {
            // Add new pattern
            patterns.push(PredictionPattern {
                state_change_key: pattern_key.clone(),
                pattern_type,
                patches: patches.clone(),
                observation_count: 1,
                old_tree: Some(old_tree.clone()),
                new_tree: Some(new_tree.clone()),
                last_accessed: now,
                created_at: now,
                predictions_made: 0,
                predictions_correct: 0,
                predictions_incorrect: 0,
            });

            // Limit number of patterns per key
            if patterns.len() > self.config.max_patterns_per_key {
                // Evict patterns in-place
                match self.config.eviction_policy {
                    EvictionPolicy::LeastFrequentlyUsed => {
                        patterns.sort_by_key(|p| std::cmp::Reverse(p.observation_count));
                    }
                    EvictionPolicy::LeastRecentlyUsed => {
                        patterns.sort_by_key(|p| std::cmp::Reverse(p.last_accessed));
                    }
                    EvictionPolicy::OldestFirst => {
                        patterns.sort_by_key(|p| std::cmp::Reverse(p.created_at));
                    }
                }
                patterns.truncate(self.config.max_patterns_per_key);
            }
        }

        crate::metrics::METRICS.record_learn(false);
        Ok(())
    }

    /// Learn with Babel-generated component metadata (NEW!)
    /// Accepts compile-time loop templates from Babel plugin as primary prediction source
    /// Falls back to runtime extraction if no Babel template available
    pub fn learn_with_metadata(
        &mut self,
        state_change: StateChange,
        old_tree: &VNode,
        new_tree: &VNode,
        all_state: Option<&HashMap<String, serde_json::Value>>,
        metadata: Option<&ComponentMetadata>
    ) -> crate::error::Result<()> {
        crate::log_debug!("Learning pattern for {}::{} (with metadata)", state_change.component_id, state_change.state_key);

        // Try Babel-generated template FIRST (perfect accuracy!)
        if let Some(meta) = metadata {
            if let Some(loop_template) = meta.parse_loop_template(&state_change.state_key) {
                crate::log_info!("📐 Using Babel-generated loop template for {}", state_change.state_key);

                let pattern_key = self.make_pattern_key(&state_change);
                self.template_predictions.insert(
                    pattern_key.clone(),
                    TemplatePrediction {
                        state_key: state_change.state_key.clone(),
                        patches: vec![Patch::UpdateListTemplate {
                            path: vec![], // Will be determined by reconciler
                            loop_template,
                        }],
                        source: TemplateSource::BabelGenerated,
                        usage_count: 0,
                        correct_count: 0,
                        incorrect_count: 0,
                    }
                );
                crate::log_info!("✅ Babel template stored for {}", pattern_key);
                crate::metrics::METRICS.record_learn(false);
                return Ok(());
            }
        }

        // Fall back to runtime learning if no Babel template
        crate::log_debug!("⚠️ No Babel template found for {}, using runtime extraction", state_change.state_key);
        self.learn(state_change, old_tree, new_tree, all_state)
    }

    /// Pre-compute patches for a hinted state change (for usePredictHint)
    /// This allows developers to explicitly tell the predictor what might happen next
    pub fn predict_hint(
        &mut self,
        hint_id: &str,
        component_id: &str,
        state_changes: Vec<StateChange>,
        current_tree: &VNode
    ) -> Option<Prediction> {
        crate::log_info!("Processing hint '{}' for component {}", hint_id, component_id);

        // For now, handle single state change hints
        // Future: support multiple simultaneous state changes
        if state_changes.len() != 1 {
            crate::log_warn!("Multi-state hints not yet supported");
            return None;
        }

        let state_change = &state_changes[0];

        // Use the same prediction logic, but mark it as a hint
        let mut prediction = self.predict(state_change, current_tree)?;

        // Add hint metadata
        crate::log_info!("Hint '{}' predicted {} patches with {:.2} confidence",
                        hint_id, prediction.predicted_patches.len(), prediction.confidence);

        Some(prediction)
    }

    /// Predict patches for a given state change
    pub fn predict(&mut self, state_change: &StateChange, current_tree: &VNode) -> Option<Prediction> {
        let start = std::time::Instant::now();
        let pattern_key = self.make_pattern_key(state_change);

        // Try template predictions first (100% coverage!)
        if let Some(template_pred) = self.template_predictions.get_mut(&pattern_key) {
            template_pred.usage_count += 1;
            let confidence = template_pred.hit_rate();

            if confidence >= self.config.min_confidence {
                crate::log_info!(
                    "📐 Template prediction with {:.2} confidence (used {} times)",
                    confidence,
                    template_pred.usage_count
                );

                crate::metrics::METRICS.record_prediction(start.elapsed(), true);

                return Some(Prediction {
                    state_change: state_change.clone(),
                    predicted_patches: template_pred.patches.clone(),
                    confidence,
                    predicted_tree: None, // Templates don't store trees
                });
            }
        }

        // Detect pattern type for this state change
        let requested_pattern_type = Self::detect_pattern_type(state_change);

        // Try learned patterns first
        if let Some(patterns) = self.patterns.get_mut(&pattern_key) {
            crate::log_debug!("Predicting for {}::{}, found {} patterns, looking for {:?}",
                             state_change.component_id, state_change.state_key, patterns.len(), requested_pattern_type);

            // Find patterns matching the requested type
            let matching_indices: Vec<usize> = patterns.iter()
                .enumerate()
                .filter(|(_, p)| p.pattern_type == requested_pattern_type)
                .map(|(idx, _)| idx)
                .collect();

            if !matching_indices.is_empty() {
                // Find the most observed pattern of the matching type
                let best_idx = *matching_indices.iter()
                    .max_by_key(|&&idx| patterns[idx].observation_count)?;

                // Calculate confidence based on observation frequency
                let total_observations: usize = matching_indices.iter()
                    .map(|&idx| patterns[idx].observation_count)
                    .sum();
                let confidence = patterns[best_idx].observation_count as f32 / total_observations as f32;

                if confidence >= self.config.min_confidence {
                    crate::log_info!("Learned prediction with confidence {:.2} ({} observations)",
                                    confidence, patterns[best_idx].observation_count);

                    patterns[best_idx].predictions_made += 1;

                    let predicted_patches = Self::adapt_patches(&patterns[best_idx].patches, current_tree);
                    let predicted_tree = patterns[best_idx].new_tree.clone();

                    crate::metrics::METRICS.record_prediction(start.elapsed(), true);

                    return Some(Prediction {
                        state_change: state_change.clone(),
                        predicted_patches,
                        confidence,
                        predicted_tree,
                    });
                }
            }
        }

        // No learned patterns or low confidence - try built-in pattern prediction
        crate::log_debug!("No learned patterns, trying built-in prediction for {:?}", requested_pattern_type);
        let builtin_prediction = Self::predict_builtin_pattern(state_change, current_tree, requested_pattern_type);

        if builtin_prediction.is_some() {
            crate::metrics::METRICS.record_prediction(start.elapsed(), true);
        } else {
            crate::metrics::METRICS.record_prediction(start.elapsed(), false);
        }

        builtin_prediction
    }

    /// Predict patches using built-in knowledge of common patterns
    /// This allows instant predictions for simple cases without needing to learn first
    fn predict_builtin_pattern(
        state_change: &StateChange,
        current_tree: &VNode,
        pattern_type: PatternType
    ) -> Option<Prediction> {
        use serde_json::Value;

        match pattern_type {
            PatternType::NumericIncrement | PatternType::NumericDecrement => {
                // Predict text content will change to show new number
                if let Value::Number(new_val) = &state_change.new_value {
                    let new_text = new_val.to_string();

                    // Try to find text nodes in the tree that might contain the old value
                    if let Some(patches) = Self::find_and_replace_number_text(current_tree, state_change, &new_text) {
                        crate::log_info!("Built-in prediction for {:?}: {} patch(es)", pattern_type, patches.len());
                        return Some(Prediction {
                            state_change: state_change.clone(),
                            predicted_patches: patches,
                            confidence: 0.85, // High confidence for simple numeric changes
                            predicted_tree: None,
                        });
                    }
                }
            }
            PatternType::BooleanToggle => {
                // Predict checkbox checked state or class changes
                crate::log_info!("Built-in prediction for BooleanToggle (simplified)");
                // For now, return None - would need more context to predict boolean changes
                // Future: analyze tree for checkboxes, conditional classes, etc.
            }
            PatternType::Literal => {
                // No built-in prediction for arbitrary changes
            }
        }

        None
    }

    /// Find text nodes containing the old value and predict UpdateText patches
    fn find_and_replace_number_text(
        tree: &VNode,
        state_change: &StateChange,
        new_text: &str
    ) -> Option<Vec<Patch>> {
        use serde_json::Value;

        let old_text = if let Value::Number(old_val) = &state_change.old_value {
            old_val.to_string()
        } else {
            return None;
        };

        let mut patches = Vec::new();
        Self::find_text_patches_recursive(tree, &old_text, new_text, &mut Vec::new(), &mut patches);

        if patches.is_empty() {
            None
        } else {
            Some(patches)
        }
    }

    /// Recursively search tree for text nodes containing the old value
    fn find_text_patches_recursive(
        node: &VNode,
        old_text: &str,
        new_text: &str,
        path: &mut Vec<usize>,
        patches: &mut Vec<Patch>
    ) {
        match node {
            VNode::Text(text_node) => {
                // Check if text contains the old value
                if text_node.content.contains(old_text) {
                    // Replace old value with new value in the text
                    let new_content = text_node.content.replace(old_text, new_text);
                    patches.push(Patch::UpdateText {
                        path: path.clone(),
                        content: new_content,
                    });
                }
            }
            VNode::Element(element) => {
                // Recursively check children
                for (i, child) in element.children.iter().enumerate() {
                    path.push(i);
                    Self::find_text_patches_recursive(child, old_text, new_text, path, patches);
                    path.pop();
                }
            }
        }
    }

    /// Verify if a prediction was correct by comparing predicted tree with actual tree
    /// Call this after reconciliation to track prediction accuracy
    pub fn verify_prediction(
        &mut self,
        state_change: &StateChange,
        predicted_tree: &VNode,
        actual_tree: &VNode
    ) -> crate::error::Result<bool> {
        let pattern_key = self.make_pattern_key(state_change);

        if let Some(patterns) = self.patterns.get_mut(&pattern_key) {
            // Find the pattern that was likely used for prediction
            if let Some(pattern) = patterns.iter_mut().max_by_key(|p| p.observation_count) {
                let matches = Self::trees_match(predicted_tree, actual_tree);

                if matches {
                    pattern.predictions_correct += 1;
                    crate::log_debug!("Prediction verified as CORRECT for {}::{}",
                                     state_change.component_id, state_change.state_key);
                } else {
                    pattern.predictions_incorrect += 1;
                    crate::log_debug!("Prediction verified as INCORRECT for {}::{}",
                                     state_change.component_id, state_change.state_key);
                }

                Ok(matches)
            } else {
                Ok(false)
            }
        } else {
            // Pattern not found
            Ok(false)
        }
    }

    /// Check if two VNode trees match (deep equality)
    fn trees_match(tree1: &VNode, tree2: &VNode) -> bool {
        // For now, use simple JSON comparison
        // In production, we might want to allow small differences (e.g., timestamps)
        match (serde_json::to_string(tree1), serde_json::to_string(tree2)) {
            (Ok(json1), Ok(json2)) => json1 == json2,
            _ => false,
        }
    }

    /// Create a pattern key from a state change
    fn make_pattern_key(&self, state_change: &StateChange) -> String {
        format!("{}::{}", state_change.component_id, state_change.state_key)
    }

    /// Check if two patch lists are similar (for pattern matching)
    #[allow(dead_code)]
    fn patches_similar(&self, a: &[Patch], b: &[Patch]) -> bool {
        if a.len() != b.len() {
            return false;
        }

        a.iter().zip(b.iter()).all(|(p1, p2)| {
            std::mem::discriminant(p1) == std::mem::discriminant(p2)
        })
    }

    /// Adapt learned patches to current tree (basic implementation)
    fn adapt_patches(patches: &[Patch], _current_tree: &VNode) -> Vec<Patch> {
        // For now, return patches as-is
        // Future enhancement: intelligently adapt paths based on current tree structure
        patches.to_vec()
    }

    /// Get statistics about learned patterns
    pub fn stats(&self) -> PredictorStats {
        let total_patterns: usize = self.patterns.values().map(|v| v.len()).sum();
        let total_observations: usize = self.patterns.values()
            .flat_map(|patterns| patterns.iter().map(|p| p.observation_count))
            .sum();

        let total_predictions: usize = self.patterns.values()
            .flat_map(|patterns| patterns.iter().map(|p| p.predictions_made))
            .sum();

        let correct_predictions: usize = self.patterns.values()
            .flat_map(|patterns| patterns.iter().map(|p| p.predictions_correct))
            .sum();

        let incorrect_predictions: usize = self.patterns.values()
            .flat_map(|patterns| patterns.iter().map(|p| p.predictions_incorrect))
            .sum();

        let hit_rate = if total_predictions > 0 {
            correct_predictions as f32 / total_predictions as f32
        } else {
            0.0
        };

        // Calculate average confidence from patterns with observations
        let patterns_with_obs: Vec<&PredictionPattern> = self.patterns.values()
            .flat_map(|patterns| patterns.iter())
            .filter(|p| p.observation_count > 0)
            .collect();

        let avg_confidence = if !patterns_with_obs.is_empty() {
            let total_conf: f32 = patterns_with_obs.iter()
                .map(|p| p.observation_count as f32)
                .sum::<f32>() / patterns_with_obs.len() as f32;
            // Normalize to 0-1 range (simplified)
            (total_conf / (total_conf + 1.0)).min(1.0)
        } else {
            0.0
        };

        PredictorStats {
            unique_state_keys: self.patterns.len(),
            total_patterns,
            total_observations,
            estimated_memory_bytes: self.estimate_memory_usage(),
            total_predictions,
            correct_predictions,
            incorrect_predictions,
            hit_rate,
            avg_confidence,
            active_patterns: total_patterns,
            prediction_hits: correct_predictions,
        }
    }

    /// Estimate memory usage of the predictor
    fn estimate_memory_usage(&self) -> usize {

        let mut total = 0;

        // HashMap overhead
        total += std::mem::size_of::<HashMap<String, Vec<PredictionPattern>>>();

        for (key, patterns) in &self.patterns {
            // Key string
            total += key.len();

            // Vec overhead
            total += std::mem::size_of::<Vec<PredictionPattern>>();

            for pattern in patterns {
                // Pattern struct overhead
                total += std::mem::size_of::<PredictionPattern>();

                // State change key
                total += pattern.state_change_key.len();

                // Patches
                total += pattern.patches.len() * std::mem::size_of::<Patch>();

                // Trees (approximate)
                if let Some(ref tree) = pattern.old_tree {
                    total += tree.estimate_size();
                }
                if let Some(ref tree) = pattern.new_tree {
                    total += tree.estimate_size();
                }
            }
        }

        total
    }

    /// Enforce memory limits by evicting patterns if necessary
    fn enforce_memory_limits(&mut self) -> crate::error::Result<()> {
        // Check state key limit
        if self.patterns.len() > self.config.max_state_keys {
            self.evict_state_keys()?;
        }

        // Check memory limit
        let current_memory = self.estimate_memory_usage();
        if current_memory > self.config.max_memory_bytes {
            self.evict_to_memory_limit()?;
        }

        Ok(())
    }

    /// Evict entire state keys based on eviction policy
    fn evict_state_keys(&mut self) -> crate::error::Result<()> {
        let target_count = (self.config.max_state_keys * 9) / 10; // Remove 10%

        if self.patterns.len() <= target_count {
            return Ok(());
        }

        crate::log_warn!("Evicting state keys: {} -> {}", self.patterns.len(), target_count);

        // Collect keys with their scores for eviction
        let mut key_scores: Vec<(String, u64)> = self.patterns.iter().map(|(key, patterns)| {
            let score = match self.config.eviction_policy {
                EvictionPolicy::LeastFrequentlyUsed => {
                    patterns.iter().map(|p| p.observation_count as u64).sum()
                }
                EvictionPolicy::LeastRecentlyUsed => {
                    patterns.iter()
                        .map(|p| p.last_accessed.elapsed().as_secs())
                        .max()
                        .unwrap_or(0)
                }
                EvictionPolicy::OldestFirst => {
                    patterns.iter()
                        .map(|p| p.created_at.elapsed().as_secs())
                        .max()
                        .unwrap_or(0)
                }
            };
            (key.clone(), score)
        }).collect();

        // Sort by score (lowest first for eviction)
        match self.config.eviction_policy {
            EvictionPolicy::LeastFrequentlyUsed => {
                key_scores.sort_by_key(|(_, score)| *score);
            }
            EvictionPolicy::LeastRecentlyUsed | EvictionPolicy::OldestFirst => {
                key_scores.sort_by_key(|(_, score)| std::cmp::Reverse(*score));
            }
        }

        // Remove keys until we reach target
        let to_remove = self.patterns.len() - target_count;
        for (key, _) in key_scores.iter().take(to_remove) {
            self.patterns.remove(key);
            crate::metrics::METRICS.record_eviction();
        }

        Ok(())
    }

    /// Evict patterns to get under memory limit
    fn evict_to_memory_limit(&mut self) -> crate::error::Result<()> {
        let current_memory = self.estimate_memory_usage();
        let target_memory = (self.config.max_memory_bytes * 9) / 10; // Target 90% of limit

        if current_memory <= target_memory {
            return Ok(());
        }

        crate::log_warn!("Evicting to memory limit: {} bytes -> {} bytes", current_memory, target_memory);

        while self.estimate_memory_usage() > target_memory && !self.patterns.is_empty() {
            // Remove one state key at a time
            if let Some(key_to_remove) = self.find_key_to_evict() {
                self.patterns.remove(&key_to_remove);
                crate::metrics::METRICS.record_eviction();
            } else {
                break;
            }
        }

        Ok(())
    }

    /// Find the best key to evict based on policy
    fn find_key_to_evict(&self) -> Option<String> {
        self.patterns.iter().min_by_key(|(_, patterns)| {
            match self.config.eviction_policy {
                EvictionPolicy::LeastFrequentlyUsed => {
                    patterns.iter().map(|p| p.observation_count as u64).sum()
                }
                EvictionPolicy::LeastRecentlyUsed => {
                    patterns.iter()
                        .map(|p| p.last_accessed.elapsed().as_secs())
                        .max()
                        .unwrap_or(0)
                }
                EvictionPolicy::OldestFirst => {
                    patterns.iter()
                        .map(|p| p.created_at.elapsed().as_secs())
                        .max()
                        .unwrap_or(0)
                }
            }
        }).map(|(key, _)| key.clone())
    }
}

impl Default for Predictor {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PredictorStats {
    pub unique_state_keys: usize,
    pub total_patterns: usize,
    pub total_observations: usize,
    pub estimated_memory_bytes: usize,
    pub total_predictions: usize,
    pub correct_predictions: usize,
    pub incorrect_predictions: usize,
    pub hit_rate: f32,
    pub avg_confidence: f32,
    pub active_patterns: usize,
    pub prediction_hits: usize,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::vdom::VNode;
    use std::collections::HashMap;

    #[test]
    fn test_predictor_learns_and_predicts() {
        let mut predictor = Predictor::new();

        // Create a simple state change pattern
        let state_change = StateChange {
            component_id: "counter".to_string(),
            state_key: "count".to_string(),
            old_value: serde_json::json!(0),
            new_value: serde_json::json!(1),
        };

        let old_tree = VNode::element("div", HashMap::new(), vec![
            VNode::text("Count: 0"),
        ]);

        let new_tree = VNode::element("div", HashMap::new(), vec![
            VNode::text("Count: 1"),
        ]);

        // Learn the pattern multiple times
        for _ in 0..5 {
            predictor.learn(state_change.clone(), &old_tree, &new_tree, None).unwrap();
        }

        // Now predict
        let prediction = predictor.predict(&state_change, &old_tree);
        assert!(prediction.is_some());

        let prediction = prediction.unwrap();
        assert!(prediction.confidence > 0.9); // Should be very confident
        assert!(!prediction.predicted_patches.is_empty());
    }

    #[test]
    fn test_predictor_stats() {
        let mut predictor = Predictor::new();

        let state_change = StateChange {
            component_id: "comp1".to_string(),
            state_key: "value".to_string(),
            old_value: serde_json::json!(0),
            new_value: serde_json::json!(1),
        };

        let tree = VNode::text("test");
        predictor.learn(state_change, &tree, &tree, None).unwrap();

        let stats = predictor.stats();
        assert_eq!(stats.unique_state_keys, 1);
        assert_eq!(stats.total_observations, 1);
    }

    #[test]
    fn test_low_confidence_returns_none() {
        let mut predictor = Predictor::with_config(PredictorConfig {
            min_confidence: 0.9,
            ..Default::default()
        });

        // Learn two different patterns for the same state key
        let state_change = StateChange {
            component_id: "test".to_string(),
            state_key: "val".to_string(),
            old_value: serde_json::json!(0),
            new_value: serde_json::json!(1),
        };

        let tree1 = VNode::text("A");
        let tree2 = VNode::text("B");
        let tree3 = VNode::element("div", HashMap::new(), vec![]);

        // Learn different outcomes
        predictor.learn(state_change.clone(), &tree1, &tree2, None).unwrap();
        predictor.learn(state_change.clone(), &tree1, &tree3, None).unwrap();

        // Low confidence - should return None
        let prediction = predictor.predict(&state_change, &tree1);
        assert!(prediction.is_none());
    }

    #[test]
    fn test_hit_rate_tracking() {
        let mut predictor = Predictor::new();

        let state_change = StateChange {
            component_id: "counter".to_string(),
            state_key: "count".to_string(),
            old_value: serde_json::json!(0),
            new_value: serde_json::json!(1),
        };

        let old_tree = VNode::text("Count: 0");
        let new_tree = VNode::text("Count: 1");

        // Learn pattern
        for _ in 0..5 {
            predictor.learn(state_change.clone(), &old_tree, &new_tree, None).unwrap();
        }

        // Make prediction
        let prediction = predictor.predict(&state_change, &old_tree);
        assert!(prediction.is_some());

        let prediction = prediction.unwrap();

        // Verify correct prediction
        if let Some(ref predicted_tree) = prediction.predicted_tree {
            let is_correct = predictor.verify_prediction(&state_change, predicted_tree, &new_tree).unwrap();
            assert!(is_correct);
        }

        // Check stats
        let stats = predictor.stats();
        assert_eq!(stats.total_predictions, 1);
        assert_eq!(stats.correct_predictions, 1);
        assert_eq!(stats.hit_rate, 1.0);
    }
}
