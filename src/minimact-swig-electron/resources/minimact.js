var Minimact=function(t){"use strict";var e,n;!function(t){t.Disconnected="Disconnected",t.Connecting="Connecting",t.Connected="Connected",t.Reconnecting="Reconnecting"}(e||(e={})),function(t){t[t.Invocation=1]="Invocation",t[t.StreamItem=2]="StreamItem",t[t.Completion=3]="Completion",t[t.StreamInvocation=4]="StreamInvocation",t[t.CancelInvocation=5]="CancelInvocation",t[t.Ping=6]="Ping",t[t.Close=7]="Close"}(n||(n={}));class o{constructor(){this.delays=[0,2e3,1e4,3e4],this.maxDelay=6e4}nextRetryDelay(t){return t<this.delays.length?this.delays[t]:this.maxDelay}}class s{static writeHandshake(){const t={protocol:this.protocolName,version:this.protocolVersion};return JSON.stringify(t)+this.RECORD_SEPARATOR}static parseHandshake(t){try{const e=t.endsWith(this.RECORD_SEPARATOR)?t.slice(0,-1):t;return JSON.parse(e)}catch(t){throw new Error(`Failed to parse handshake: ${t}`)}}static writeInvocation(t,e,n){return{type:1,invocationId:t,target:e,arguments:n}}static writeMessage(t,e){return{type:1,target:t,arguments:e}}static writePing(){return{type:6}}static writeClose(t){return{type:7,error:t}}static parseMessage(t){try{const e=t.endsWith(this.RECORD_SEPARATOR)?t.slice(0,-1):t;return JSON.parse(e)}catch(t){throw new Error(`Failed to parse message: ${t}`)}}static serializeMessage(t){return JSON.stringify(t)+this.RECORD_SEPARATOR}static isInvocation(t){return 1===t.type}static isCompletion(t){return 3===t.type}static isPing(t){return 6===t.type}static isClose(t){return 7===t.type}}s.protocolName="json",s.protocolVersion=1,s.RECORD_SEPARATOR="";class i{constructor(){this.events=new Map}on(t,e){this.events.has(t)||this.events.set(t,[]),this.events.get(t).push(e)}off(t,e){const n=this.events.get(t);if(n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}once(t,e){const n=(...o)=>{e(...o),this.off(t,n)};this.on(t,n)}emit(t,...e){const n=this.events.get(t);n&&[...n].forEach(n=>{try{n(...e)}catch(e){console.error(`[SignalM] Error in event handler for '${t}':`,e)}})}removeAllListeners(t){t?this.events.delete(t):this.events.clear()}listenerCount(t){const e=this.events.get(t);return e?e.length:0}eventNames(){return Array.from(this.events.keys())}}class r{constructor(t,n={}){this.ws=null,this.handlers=new Map,this.pendingInvocations=new Map,this.invocationId=0,this.state=e.Disconnected,this.reconnectAttempts=0,this.reconnectTimeoutId=null,this.url=t,this.reconnectPolicy=n.reconnectPolicy||new o,this.debugLogging=n.debug||!1,this.connectionTimeout=n.connectionTimeout||3e4,this.invocationTimeout=n.invocationTimeout||3e4,this.eventEmitter=new i}async start(){if(this.state!==e.Disconnected)throw new Error("Connection is already started");return this.state=e.Connecting,this.log("Starting connection..."),this.connect()}async stop(){this.log("Stopping connection..."),null!==this.reconnectTimeoutId&&(clearTimeout(this.reconnectTimeoutId),this.reconnectTimeoutId=null),this.ws&&(this.ws.close(1e3,"Normal closure"),this.ws=null),this.state=e.Disconnected,this.eventEmitter.emit("disconnected")}async invoke(t,...n){if(this.state!==e.Connected)throw new Error(`Connection is not in Connected state (current: ${this.state})`);const o=this.generateInvocationId(),i=s.writeInvocation(o,t,n);return new Promise((e,r)=>{const a=setTimeout(()=>{this.pendingInvocations.delete(o),r(new Error(`Invocation '${t}' timed out after ${this.invocationTimeout}ms`))},this.invocationTimeout);this.pendingInvocations.set(o,{resolve:e,reject:r,timeout:a});const c=s.serializeMessage(i);this.log(`Invoking '${t}' (id: ${o})`,n),this.ws.send(c)})}send(t,...n){if(this.state!==e.Connected)throw new Error(`Connection is not in Connected state (current: ${this.state})`);const o=s.writeMessage(t,n),i=s.serializeMessage(o);this.log(`Sending '${t}' (fire-and-forget)`,n),this.ws.send(i)}on(t,e){this.handlers.has(t)||this.handlers.set(t,[]),this.handlers.get(t).push(e),this.log(`Registered handler for '${t}'`)}off(t,e){const n=this.handlers.get(t);if(n){const o=n.indexOf(e);-1!==o&&(n.splice(o,1),this.log(`Removed handler for '${t}'`))}}onConnected(t){this.eventEmitter.on("connected",t)}onDisconnected(t){this.eventEmitter.on("disconnected",t)}onReconnecting(t){this.eventEmitter.on("reconnecting",t)}onReconnected(t){this.eventEmitter.on("reconnected",t)}onError(t){this.eventEmitter.on("error",t)}get connectionState(){return this.state}async connect(){return new Promise((t,n)=>{const o=this.buildWebSocketUrl();this.log(`Connecting to ${o}...`);try{this.ws=new WebSocket(o)}catch(t){return void n(t)}const i=setTimeout(()=>{this.state===e.Connecting&&(this.log("Connection timeout"),this.ws?.close(),n(new Error(`Connection timeout after ${this.connectionTimeout}ms`)))},this.connectionTimeout);let r=!1;this.ws.onopen=()=>{const t=s.writeHandshake();this.log("Sending handshake",t),this.ws.send(t)},this.ws.onmessage=o=>{if(r)this.handleMessage(o.data);else try{const a=s.parseHandshake(o.data);if(a.error)return clearTimeout(i),this.log("Handshake failed",a.error),this.ws?.close(),void n(new Error(`Handshake failed: ${a.error}`));r=!0,clearTimeout(i),this.state=e.Connected,this.reconnectAttempts=0,this.log("Handshake complete ‚úì"),this.log("Connected ‚úì"),this.eventEmitter.emit("connected"),t()}catch(t){clearTimeout(i),this.log("Handshake parse error",t),this.ws?.close(),n(new Error(`Handshake error: ${t}`))}},this.ws.onerror=t=>{this.log("WebSocket error",t),this.eventEmitter.emit("error",new Error("WebSocket error"))},this.ws.onclose=t=>{clearTimeout(i),this.handleClose(t)}})}handleMessage(t){const e=t.split("").filter(t=>t.length>0);for(const t of e)try{const e=JSON.parse(t);this.log(`Received message (type: ${e.type})`,e),s.isInvocation(e)?this.handleInvocation(e):s.isCompletion(e)?this.handleCompletion(e):s.isPing(e)?this.handlePing():s.isClose(e)&&(this.log("Server requested close",e.error),this.ws?.close(1e3,"Server closed connection"))}catch(t){this.log("Error parsing message",t),console.error("[SignalM] Error parsing message:",t)}}handleInvocation(t){const e=this.handlers.get(t.target);e?(this.log(`Calling ${e.length} handler(s) for '${t.target}'`),e.forEach(e=>{try{e(...t.arguments||[])}catch(e){console.error(`[SignalM] Error in handler for '${t.target}':`,e)}})):this.log(`No handler registered for '${t.target}'`)}handleCompletion(t){const e=this.pendingInvocations.get(t.invocationId);e?(clearTimeout(e.timeout),this.pendingInvocations.delete(t.invocationId),t.error?(this.log(`Invocation ${t.invocationId} failed: ${t.error}`),e.reject(new Error(t.error))):(this.log(`Invocation ${t.invocationId} completed`,t.result),e.resolve(t.result))):this.log(`Received completion for unknown invocation ${t.invocationId}`)}handlePing(){const t=s.writePing(),e=s.serializeMessage(t);this.log("Received ping, sending pong"),this.ws?.send(e)}handleClose(t){this.log(`Connection closed (code: ${t.code}, reason: ${t.reason})`),this.state=e.Disconnected,this.ws=null,this.pendingInvocations.forEach(t=>{clearTimeout(t.timeout),t.reject(new Error("Connection closed"))}),this.pendingInvocations.clear(),1e3!==t.code&&1001!==t.code?this.attemptReconnect():this.eventEmitter.emit("disconnected")}async attemptReconnect(){const t=this.reconnectPolicy.nextRetryDelay(this.reconnectAttempts);if(null===t)return this.log("Max reconnection attempts exceeded"),void this.eventEmitter.emit("disconnected");this.reconnectAttempts++,this.state=e.Reconnecting,this.log(`Reconnecting in ${t}ms (attempt ${this.reconnectAttempts})...`),this.eventEmitter.emit("reconnecting"),this.reconnectTimeoutId=setTimeout(async()=>{this.reconnectTimeoutId=null;try{await this.connect(),this.log("Reconnected ‚úì"),this.eventEmitter.emit("reconnected")}catch(t){this.log("Reconnection failed",t),this.attemptReconnect()}},t)}buildWebSocketUrl(){if(this.url.startsWith("ws://")||this.url.startsWith("wss://"))return this.url;const t="https:"===window.location.protocol?"wss:":"ws:";return this.url.startsWith("/")?`${t}//${window.location.host}${this.url}`:`${t}//${window.location.host}/${this.url}`}generateInvocationId(){return(++this.invocationId).toString()}log(t,e){this.debugLogging&&(void 0!==e?console.log(`[SignalM] ${t}`,e):console.log(`[SignalM] ${t}`))}}class a{constructor(t="/minimact",e={}){this.debugLogging=e.debugLogging||!1,this.eventHandlers=new Map,this.connection=new r(t,{debug:this.debugLogging}),this.setupEventHandlers()}setupEventHandlers(){this.connection.on("UpdateComponent",(t,e)=>{this.log("UpdateComponent",{componentId:t,html:e}),this.emit("updateComponent",{componentId:t,html:e})}),this.connection.on("ApplyPatches",(t,e)=>{this.log("ApplyPatches",{componentId:t,patches:e}),this.emit("applyPatches",{componentId:t,patches:e})}),this.connection.on("ApplyPrediction",t=>{this.log(`ApplyPrediction (${(100*t.confidence).toFixed(0)}% confident)`,{componentId:t.componentId,patches:t.patches}),this.emit("applyPrediction",{componentId:t.componentId,patches:t.patches,confidence:t.confidence})}),this.connection.on("ApplyCorrection",t=>{this.log("ApplyCorrection (prediction was incorrect)",{componentId:t.componentId,patches:t.patches}),this.emit("applyCorrection",{componentId:t.componentId,patches:t.patches})}),this.connection.on("QueueHint",t=>{this.log(`QueueHint '${t.hintId}' (${(100*t.confidence).toFixed(0)}% confident)`,{componentId:t.componentId,patches:t.patches}),this.emit("queueHint",t)}),this.connection.on("Error",t=>{console.error("[Minimact] Server error:",t),this.emit("error",{message:t})}),this.connection.on("HotReload:TemplateMap",t=>{this.log("HotReload:TemplateMap",t),this.emit("HotReload:TemplateMap",t)}),this.connection.on("HotReload:TemplatePatch",t=>{this.log("HotReload:TemplatePatch",t),this.emit("HotReload:TemplatePatch",t)}),this.connection.on("HotReload:FileChange",t=>{this.log("HotReload:FileChange",t),this.emit("HotReload:FileChange",t)}),this.connection.on("HotReload:Error",t=>{console.error("[Minimact Hot Reload] Error:",t.error),this.emit("HotReload:Error",t)}),this.connection.onReconnecting(()=>{this.log("Reconnecting..."),this.emit("reconnecting",{})}),this.connection.onReconnected(()=>{this.log("Reconnected"),this.emit("reconnected",{connectionId:null})}),this.connection.onDisconnected(()=>{this.log("Connection closed"),this.emit("closed",{})}),this.connection.onConnected(()=>{this.log("Connected to Minimact hub"),this.emit("connected",{connectionId:null})})}async start(){try{await this.connection.start()}catch(t){throw console.error("[Minimact] Failed to connect:",t),t}}async stop(){await this.connection.stop(),this.log("Disconnected from Minimact hub")}async registerComponent(t){try{await this.connection.invoke("RegisterComponent",t),this.log("Registered component",{componentId:t})}catch(t){throw console.error("[Minimact] Failed to register component:",t),t}}async invokeComponentMethod(t,e,n={}){try{const o=JSON.stringify(n);await this.connection.invoke("InvokeComponentMethod",t,e,o),this.log("Invoked method",{componentId:t,methodName:e,args:n})}catch(t){throw console.error("[Minimact] Failed to invoke method:",t),t}}async updateClientState(t,e,n){try{const o=JSON.stringify(n);await this.connection.invoke("UpdateClientState",t,e,o),this.log("Updated client state",{componentId:t,key:e,value:n})}catch(t){console.error("[Minimact] Failed to update client state:",t)}}async updateClientComputedState(t,e){try{await this.connection.invoke("UpdateClientComputedState",t,e),this.log("Updated client-computed state",{componentId:t,computedValues:e})}catch(t){throw console.error("[Minimact] Failed to update client-computed state:",t),t}}async updateComponentState(t,e,n){try{await this.connection.invoke("UpdateComponentState",t,e,n),this.log("Updated component state",{componentId:t,stateKey:e,value:n})}catch(t){throw console.error("[Minimact] Failed to update component state:",t),t}}async updateDomElementState(t,e,n){try{await this.connection.invoke("UpdateDomElementState",t,e,n),this.log("Updated DOM element state",{componentId:t,stateKey:e,snapshot:n})}catch(t){throw console.error("[Minimact] Failed to update DOM element state:",t),t}}async updateComponentStateWithOperation(t,e,n,o){try{await this.connection.invoke("UpdateComponentStateWithOperation",t,e,n,o),this.log("Updated component state with operation",{componentId:t,stateKey:e,operation:o,newValue:n})}catch(t){throw console.error("[Minimact] Failed to update component state with operation:",t),t}}async updateQueryResults(t,e,n){try{await this.connection.invoke("UpdateQueryResults",t,e,n),this.log("Updated query results",{componentId:t,queryKey:e,resultCount:n.length})}catch(t){throw console.error("[Minimact] Failed to update query results:",t),t}}async invoke(t,...e){try{await this.connection.invoke(t,...e),this.log(`Invoked ${t}`,{args:e})}catch(e){throw console.error(`[Minimact] Failed to invoke ${t}:`,e),e}}on(t,e){this.eventHandlers.has(t)||this.eventHandlers.set(t,new Set),this.eventHandlers.get(t).add(e)}off(t,e){const n=this.eventHandlers.get(t);n&&n.delete(e)}emit(t,e){const n=this.eventHandlers.get(t);n&&n.forEach(t=>t(e))}log(t,e){this.debugLogging&&console.log(`[Minimact SignalM] ${t}`,e||"")}get state(){return this.connection.connectionState}get connectionId(){return null}}class c{constructor(t={}){this.debugLogging=t.debugLogging||!1,this.templateState=t.templateState}applyPatches(t,e,n){this.log("Applying patches",{count:e.length,patches:e}),this.componentType=n;for(const n of e)try{this.applyPatch(t,n)}catch(t){console.error("[Minimact] Failed to apply patch:",n,t)}this.componentType=void 0}applyPatch(t,e){const n=e.path.split("."),o=n.length>1?n.slice(1).join("."):"",s=this.getElementByPath(t,o);if(s||"Create"===e.type)switch(e.type){case"Create":this.patchCreate(t,o,e.node),this.templateState&&this.componentType&&this.templateState.removeFromNullPaths(this.componentType,e.path);break;case"Remove":this.patchRemove(s),this.templateState&&this.componentType&&this.templateState.addToNullPaths(this.componentType,e.path);break;case"Replace":this.patchReplace(s,e.node);break;case"UpdateText":this.patchUpdateText(s,e.content);break;case"UpdateProps":this.patchUpdateProps(s,e.props);break;case"ReorderChildren":this.patchReorderChildren(s,e.order)}else console.warn("[Minimact] Target element not found for patch:",e)}patchCreate(t,e,n){const o=this.createElementFromVNode(n);if(""===e||"."===e)t.innerHTML="",t.appendChild(o);else{const n=e.split("."),s=n.slice(0,-1).join("."),i=n[n.length-1],r=this.getElementByPath(t,s);if(r&&this.templateState&&this.componentType){const t=this.templateState.getChildrenAtPath(this.componentType,s);if(!t)return void console.error("[DOMPatcher] Cannot find siblings for insertion at path:",e);let n=0;for(const e of t){if(e===i)break;const t=s?`${s}.${e}`:e;this.templateState.isPathNull(this.componentType,t)||n++}n>=r.childNodes.length?r.appendChild(o):r.insertBefore(o,r.childNodes[n])}}this.log("Created node",{path:e,node:n})}patchRemove(t){t.parentNode&&(t.parentNode.removeChild(t),this.log("Removed node",{element:t}))}patchReplace(t,e){const n=this.createElementFromVNode(e);t.parentNode&&(t.parentNode.replaceChild(n,t),this.log("Replaced node",{oldElement:t,newNode:e}))}patchUpdateText(t,e){t.nodeType,Node.TEXT_NODE,t.textContent=e,this.log("Updated text",{element:t,content:e})}patchUpdateProps(t,e){const n=Array.from(t.attributes);for(const o of n)o.name in e||o.name.startsWith("data-minimact-")||t.removeAttribute(o.name);for(const[n,o]of Object.entries(e))if("style"===n)t.setAttribute("style",o);else if("class"===n||"className"===n)t.className=o;else{if(n.startsWith("on"))continue;t.setAttribute(n,o)}this.log("Updated props",{element:t,props:e})}patchReorderChildren(t,e){const n=new Map;for(const e of Array.from(t.childNodes))if(e instanceof HTMLElement){const t=e.getAttribute("data-key")||e.getAttribute("key");t&&n.set(t,e)}for(let o=0;o<e.length;o++){const s=e[o],i=n.get(s);if(i){const e=t.childNodes[o];e!==i&&t.insertBefore(i,e)}}this.log("Reordered children",{element:t,order:e})}getElementByPath(t,e){return""===e||"."===e?t:this.templateState&&this.componentType?this.templateState.navigateToPath(t,this.componentType,e):(console.error("[DOMPatcher] Cannot navigate path without TemplateStateManager and componentType"),null)}createElementFromVNode(t){switch(t.type){case"Text":return document.createTextNode(t.content);case"Element":{const e=t,n=document.createElement(e.tag);for(const[t,o]of Object.entries(e.props||{}))"className"===t||"class"===t?n.className=o:t.startsWith("on")?n.setAttribute(`data-${t.toLowerCase()}`,o):n.setAttribute(t,o);e.key&&n.setAttribute("data-key",e.key);for(const t of e.children||[])n.appendChild(this.createElementFromVNode(t));return n}case"Fragment":{const e=document.createDocumentFragment(),n=t;for(const t of n.children||[])e.appendChild(this.createElementFromVNode(t));return e}case"RawHtml":{const e=document.createElement("div");return e.innerHTML=t.html,e}default:return console.warn("[Minimact] Unknown VNode type:",t),document.createTextNode("")}}replaceHTML(t,e){t.innerHTML=e,this.log("Replaced entire HTML",{html:e})}log(t,e){this.debugLogging&&console.log(`[Minimact DOMPatcher] ${t}`,e||"")}}class l{constructor(t={}){this.states=new Map,this.subscribers=new Map,this.debugLogging=t.debugLogging||!1}initializeComponent(t,e={}){this.states.set(t,{...e}),this.subscribers.set(t,new Map),this.log("Initialized component state",{componentId:t,initialState:e})}getState(t,e){const n=this.states.get(t);return n?n[e]:void 0}setState(t,e,n){const o=this.states.get(t);if(!o)return void console.warn(`[Minimact] Component ${t} not initialized`);const s=o[e];o[e]=n,this.log("State updated",{componentId:t,key:e,oldValue:s,newValue:n}),this.notifySubscribers(t,e,n,s)}subscribe(t,e,n){const o=this.subscribers.get(t);return o?(o.has(e)||o.set(e,new Set),o.get(e).add(n),this.log("Subscribed to state",{componentId:t,key:e}),()=>{o.get(e)?.delete(n),this.log("Unsubscribed from state",{componentId:t,key:e})}):(console.warn(`[Minimact] Component ${t} not initialized`),()=>{})}notifySubscribers(t,e,n,o){const s=this.subscribers.get(t);if(!s)return;const i=s.get(e);i&&i.forEach(t=>{try{t(n,o)}catch(t){console.error("[Minimact] Error in state subscriber:",t)}})}getComponentState(t){return this.states.get(t)}updateState(t,e){for(const[n,o]of Object.entries(e))this.setState(t,n,o)}clearComponent(t){this.states.delete(t),this.subscribers.delete(t),this.log("Cleared component state",{componentId:t})}bindToElement(t,e,n,o="textContent"){const s=this.getState(t,e);return void 0!==s&&this.updateElement(n,o,s),this.subscribe(t,e,t=>{this.updateElement(n,o,t)})}updateElement(t,e,n){switch(e){case"value":(t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement||t instanceof HTMLSelectElement)&&(t.value=String(n));break;case"textContent":t.textContent=String(n);break;case"innerHTML":t.innerHTML=String(n)}}bindInput(t,e,n){const o=this.getState(t,e);void 0!==o&&(n.value=String(o));const s=n=>{const o=n.target;this.setState(t,e,o.value)};n.addEventListener("input",s);const i=this.subscribe(t,e,t=>{n.value!==String(t)&&(n.value=String(t))});return()=>{n.removeEventListener("input",s),i()}}log(t,e){this.debugLogging&&console.log(`[Minimact ClientState] ${t}`,e||"")}}class h{constructor(t,e,n={}){this.rootElement=t,this.componentMethodInvoker=e,this.debugLogging=n.debugLogging||!1,this.hintQueue=n.hintQueue,this.domPatcher=n.domPatcher,this.playgroundBridge=n.playgroundBridge,this.eventListeners=new Map,this.setupEventDelegation()}setupEventDelegation(){const t=["click","dblclick","input","change","submit","focus","blur","keydown","keyup","keypress","mouseenter","mouseleave","mouseover","mouseout"];for(const e of t){const t=this.createEventListener(e);this.eventListeners.set(e,t),this.rootElement.addEventListener(e,t,!0)}this.log("Event delegation setup complete",{eventTypes:t})}createEventListener(t){return async e=>{const n=e.target,o=this.findHandlerElement(n,t);if(!o)return;const s=this.getEventHandler(o,t);s&&("submit"===t&&e.preventDefault(),this.log("Event triggered",{eventType:t,handler:s,target:n}),await this.executeHandler(s,e,o))}}findHandlerElement(t,e){let n=t;for(;n&&n!==this.rootElement;){const t=`data-on${e}`,o=`on${e}`;if(n.hasAttribute(t)||n.hasAttribute(o))return n;n=n.parentElement}return null}getEventHandler(t,e){const n=`data-on${e}`,o=`on${e}`,s=t.getAttribute(n)||t.getAttribute(o);if(!s)return null;const i=s.split(":"),r=i[0],a=i.slice(1),c=this.findComponentId(t);return c?{componentId:c,methodName:r,args:a}:(console.warn("[Minimact] No component ID found for event handler:",s),null)}findComponentId(t){let e=t;for(;e&&e!==this.rootElement;){const t=e.getAttribute("data-minimact-component-id");if(t)return t;e=e.parentElement}return this.rootElement.getAttribute("data-minimact-component-id")}async executeHandler(t,e,n){const o=performance.now();try{const n={};if(t.args.length>0&&(n.args=t.args.map(t=>{try{return JSON.parse(t)}catch{return t}})),e instanceof MouseEvent&&(n.mouse={clientX:e.clientX,clientY:e.clientY,button:e.button}),e instanceof KeyboardEvent&&(n.keyboard={key:e.key,code:e.code,ctrlKey:e.ctrlKey,shiftKey:e.shiftKey,altKey:e.altKey}),"input"===e.type||"change"===e.type){const t=e.target;n.value=t.value}const s=[];if(void 0!==n.value&&s.push(n.value),n.args&&Array.isArray(n.args)&&s.push(...n.args),this.hintQueue&&this.domPatcher){const e=this.tryMatchHint(t.componentId,t.methodName);if(e){const n=this.findComponentElement(t.componentId);if(n){this.domPatcher.applyPatches(n,e.patches);const i=performance.now()-o;return this.playgroundBridge&&this.playgroundBridge.cacheHit({componentId:t.componentId,hintId:e.hintId,latency:i,confidence:e.confidence,patchCount:e.patches.length}),this.log(`üü¢ CACHE HIT! Applied ${e.patches.length} patches in ${i.toFixed(2)}ms`,{handler:t,confidence:(100*e.confidence).toFixed(0)+"%"}),void this.componentMethodInvoker(t.componentId,t.methodName,s).catch(t=>{console.error("[Minimact] Background server notification failed:",t)})}}}await this.componentMethodInvoker(t.componentId,t.methodName,s);const i=performance.now()-o;this.playgroundBridge&&this.playgroundBridge.cacheMiss({componentId:t.componentId,methodName:t.methodName,latency:i,patchCount:0}),this.log(`üî¥ CACHE MISS - Server latency: ${i.toFixed(2)}ms`,{handler:t,argsObj:n})}catch(e){console.error("[Minimact] Error executing handler:",t,e)}}tryMatchHint(t,e){return this.hintQueue,null}findComponentElement(t){return this.rootElement.querySelector(`[data-minimact-component-id="${t}"]`)}destroy(){for(const[t,e]of this.eventListeners.entries())this.rootElement.removeEventListener(t,e,!0);this.eventListeners.clear(),this.log("Event delegation destroyed")}log(t,e){this.debugLogging&&console.log(`[Minimact EventDelegation] ${t}`,e||"")}}class d{constructor(t,e={}){this.clientState=t,this.components=new Map,this.debugLogging=e.debugLogging||!1}hydrateComponent(t,e,n){this.log("Hydrating component",{componentId:t,componentType:n});const o=e.firstElementChild;if(!o)return void console.error("[Minimact Hydration] No component element found in root");const s={componentId:t,type:n,element:o,clientState:{},serverState:{}};this.components.set(t,s),e.setAttribute("data-minimact-component-id",t),this.clientState.initializeComponent(t),this.hydrateClientZones(t,e),this.bindStateElements(t,e),this.log("Component hydrated",{componentId:t,metadata:s})}hydrateClientZones(t,e){const n=e.querySelectorAll("[data-minimact-client-scope]");this.log("Found client zones",{count:n.length}),n.forEach(e=>{const n=e,o=n.getAttribute("data-state");if(o){const e=this.getInitialValue(n);this.clientState.setState(t,o,e),(n instanceof HTMLInputElement||n instanceof HTMLTextAreaElement||n instanceof HTMLSelectElement)&&this.clientState.bindInput(t,o,n),this.log("Hydrated client zone",{element:n,stateName:o,initialValue:e})}})}bindStateElements(t,e){const n=e.querySelectorAll("[data-bind]");this.log("Found bound elements",{count:n.length}),n.forEach(e=>{const n=e,o=n.getAttribute("data-bind");if(!o)return;const s=this.isInClientScope(n),i=this.determineBindProperty(n);s?(this.clientState.bindToElement(t,o,n,i),this.log("Bound to client state",{element:n,bindKey:o,bindProperty:i})):this.log("Server-bound element (patch-controlled)",{element:n,bindKey:o})})}isInClientScope(t){let e=t;for(;e;){if(e.hasAttribute("data-minimact-client-scope"))return!0;if(e.hasAttribute("data-minimact-server-scope"))return!1;e=e.parentElement}return!1}determineBindProperty(t){return t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement||t instanceof HTMLSelectElement?"value":t.hasAttribute("data-bind-html")?"innerHTML":"textContent"}getInitialValue(t){return t instanceof HTMLInputElement?"checkbox"===t.type?t.checked:"number"===t.type?t.valueAsNumber||0:t.value:t instanceof HTMLTextAreaElement||t instanceof HTMLSelectElement?t.value:t.textContent||""}dehydrateComponent(t){this.components.get(t)&&(this.clientState.clearComponent(t),this.components.delete(t),this.log("Component dehydrated",{componentId:t}))}getComponent(t){return this.components.get(t)}updateServerState(t,e,n){const o=this.components.get(t);o&&(o.serverState[e]=n,this.log("Updated server state",{componentId:t,key:e,value:n}))}hydrateAll(){const t=document.querySelectorAll("[data-minimact-component]");this.log("Hydrating all components",{count:t.length}),t.forEach(t=>{const e=t.getAttribute("data-minimact-component");e&&this.hydrateComponent(e,t)})}log(t,e){this.debugLogging&&console.log(`[Minimact Hydration] ${t}`,e||"")}}class p{static renderTemplate(t,e){let n=t;return e.forEach((t,e)=>{const o=`{${e}}`,s=this.formatValue(t);n=n.replace(o,s)}),n}static renderTemplatePatch(t,e){if(t.conditionalTemplates&&void 0!==t.conditionalBindingIndex){const n=t.conditionalBindingIndex,o=t.bindings[n],s="object"==typeof o&&"stateKey"in o?o.stateKey:o,i=e[s],r=t.conditionalTemplates[String(i)];if(void 0!==r){if(!r.includes("{"))return r;const n=t.bindings.map(t=>{if("object"==typeof t&&"stateKey"in t){const n=e[t.stateKey];return t.transform?this.applyTransform(n,t.transform):n}return e[t]});return this.renderTemplate(r,n)}}const n=t.bindings.map((t,n)=>{if("object"==typeof t&&"stateKey"in t){const n=e[t.stateKey];return t.transform?this.applyTransform(n,t.transform):n}return e[t]});return this.renderTemplate(t.template,n)}static materializePatch(t,e){switch(t.type){case"UpdateTextTemplate":{const n=this.renderTemplatePatch(t.templatePatch,e);return{type:"UpdateText",path:t.path,content:n}}case"UpdatePropsTemplate":{const n=this.renderTemplatePatch(t.templatePatch,e);return{type:"UpdateProps",path:t.path,props:{[t.propName]:n}}}case"UpdateListTemplate":{const n=this.renderLoopTemplate(t.loopTemplate,e);return this.convertLoopToPatches(t.path,n)}case"UpdateAttributeStatic":return{type:"UpdateProps",path:t.path,props:{[t.attrName]:t.value}};case"UpdateAttributeDynamic":{const n=this.renderTemplatePatch(t.templatePatch,e);return{type:"UpdateProps",path:t.path,props:{[t.attrName]:n}}}default:return t}}static materializePatches(t,e){const n=[];for(const o of t){const t=this.materializePatch(o,e);Array.isArray(t)?n.push(...t):n.push(t)}return n}static applyTransform(t,e){if(e.startsWith("toFixed(")){const n=parseInt(e.match(/\d+/)?.[0]||"0");return Number(t).toFixed(n)}if(e.startsWith("* ")){const n=parseFloat(e.substring(2));return Number(t)*n}if(e.startsWith("/ ")){const n=parseFloat(e.substring(2));return Number(t)/n}if(e.startsWith("+ ")){const n=parseFloat(e.substring(2));return Number(t)+n}if(e.startsWith("- ")){const n=parseFloat(e.substring(2));return Number(t)-n}return"toUpperCase()"===e||"toUpperCase"===e?String(t).toUpperCase():"toLowerCase()"===e||"toLowerCase"===e?String(t).toLowerCase():"trim()"===e||"trim"===e?String(t).trim():"!"===e?!t:(console.warn(`[TemplateRenderer] Unknown transform: ${e}`),t)}static formatValue(t){return null==t?"":"string"==typeof t?t:"number"==typeof t||"boolean"==typeof t?String(t):Array.isArray(t)?t.map(t=>this.formatValue(t)).join(", "):"object"==typeof t?JSON.stringify(t):String(t)}static isTemplatePatch(t){return"UpdateTextTemplate"===t.type||"UpdatePropsTemplate"===t.type||"UpdateListTemplate"===t.type||"UpdateAttributeStatic"===t.type||"UpdateAttributeDynamic"===t.type}static extractBindings(t){return"UpdateTextTemplate"===t.type||"UpdatePropsTemplate"===t.type||"UpdateAttributeDynamic"===t.type?t.templatePatch.bindings.map(t=>"object"==typeof t&&"stateKey"in t?t.stateKey:t):(t.type,[])}static validateBindings(t,e){return t.bindings.every(t=>("object"==typeof t&&"stateKey"in t?t.stateKey:t)in e)}static getMissingBindings(t,e){return t.bindings.filter(t=>!(("object"==typeof t&&"stateKey"in t?t.stateKey:t)in e)).map(t=>"object"==typeof t&&"stateKey"in t?t.stateKey:t)}static renderLoopTemplate(t,e){const n=e[t.array_binding];return Array.isArray(n)?n.map((n,o)=>{const s={...e,item:n,index:o,...t.index_var?{[t.index_var]:o}:{}},i=this.flattenItemState(s,n);return this.renderItemTemplate(t.item_template,i)}):(console.warn(`[TemplateRenderer] Expected array for '${t.array_binding}', got:`,n),[])}static flattenItemState(t,e){const n={...t};if("object"==typeof e&&null!==e&&!Array.isArray(e))for(const t in e)n[`item.${t}`]=e[t];return n}static renderItemTemplate(t,e){switch(t.type){case"Text":return{type:"Text",content:this.renderTemplatePatch(t.template_patch,e)};case"Element":{const n={};if(t.props_templates)for(const[o,s]of Object.entries(t.props_templates))n[o]=this.renderTemplatePatch(s,e);const o=(t.children_templates||[]).map(t=>this.renderItemTemplate(t,e)),s=t.key_binding?String(e[t.key_binding]):void 0;return{type:"Element",tag:t.tag,props:n,children:o,key:s}}default:throw new Error(`Unknown item template type: ${t.type}`)}}static convertLoopToPatches(t,e){return e.map((e,n)=>{const o=n.toString(16).padStart(8,"0");return{type:"Create",path:t?`${t}.${o}`:o,node:e}})}}class m{constructor(t={}){this.hints=new Map,this.maxHintAge=5e3,this.debugLogging=t.debugLogging||!1}queueHint(t){const e=`${t.componentId}:${t.hintId}`,n=t.patches.some(t=>p.isTemplatePatch(t));this.hints.set(e,{...t,queuedAt:Date.now(),isTemplate:n});const o=n?"üìê TEMPLATE":"üìÑ CONCRETE";this.log(`${o} hint '${t.hintId}' queued for ${t.componentId}`,t),this.cleanupStaleHints()}matchHint(t,e){const n=Array.from(this.hints.entries()).filter(([e])=>e.startsWith(`${t}:`)).map(([,t])=>t);for(const o of n)if(this.stateMatches(o.predictedState,e)){const n=o.isTemplate?"üìê TEMPLATE":"üìÑ CONCRETE";this.log(`${n} hint '${o.hintId}' matched!`,{hint:o,stateChanges:e});const s=`${t}:${o.hintId}`;this.hints.delete(s);const i=p.materializePatches(o.patches,e);return{hintId:o.hintId,patches:i,confidence:o.confidence}}return null}stateMatches(t,e){for(const[n,o]of Object.entries(t)){if(!(n in e))return!1;if(JSON.stringify(e[n])!==JSON.stringify(o))return!1}return!0}cleanupStaleHints(){const t=Date.now(),e=[];for(const[n,o]of this.hints.entries())t-o.queuedAt>this.maxHintAge&&e.push(n);if(e.length>0){this.log(`Removing ${e.length} stale hint(s)`,e);for(const t of e)this.hints.delete(t)}}clearComponent(t){const e=Array.from(this.hints.keys()).filter(e=>e.startsWith(`${t}:`));for(const t of e)this.hints.delete(t);e.length>0&&this.log(`Cleared ${e.length} hint(s) for component ${t}`)}clearAll(){this.hints.clear(),this.log("Cleared all hints")}getStats(){const t=Array.from(this.hints.values()),e=t.filter(t=>t.isTemplate),n=t.filter(t=>!t.isTemplate);return{totalHints:this.hints.size,templateHints:e.length,concreteHints:n.length,templatePercentage:this.hints.size>0?Math.round(e.length/this.hints.size*100):0,hintsByComponent:t.reduce((t,e)=>(t[e.componentId]=(t[e.componentId]||0)+1,t),{})}}log(t,...e){this.debugLogging&&console.log(`[Minimact HintQueue] ${t}`,...e)}}class u{constructor(t={}){this.debugLogging=t.debugLogging||!1}predictionReceived(t){this.postMessage({type:"minimact:prediction-received",data:t}),this.log("Prediction received",t)}cacheHit(t){this.postMessage({type:"minimact:cache-hit",data:{...t,cacheHit:!0,elapsedMs:t.latency}}),this.log("üü¢ CACHE HIT",t)}cacheMiss(t){this.postMessage({type:"minimact:cache-miss",data:{...t,cacheHit:!1,elapsedMs:t.latency,predictionConfidence:0}}),this.log("üî¥ CACHE MISS",t)}correctionApplied(t){this.postMessage({type:"minimact:correction",data:t}),this.log("Correction applied (prediction was incorrect)",t)}postMessage(t){window.parent&&window.parent!==window&&window.parent.postMessage(t,"*"),window.dispatchEvent(new CustomEvent(t.type,{detail:t.data}))}log(t,e){this.debugLogging&&console.log(`[Minimact PlaygroundBridge] ${t}`,e||"")}}class g{detectEditPattern(t,e){if(t===e)return{type:"complex",confidence:0};const n=this.computeDiff(t,e),o=this.detectTextChange(n);if(o)return o;const s=this.detectClassChange(n);if(s)return s;const i=this.detectAttributeChange(n);if(i)return i;const r=this.detectStyleChange(n);if(r)return r;return this.detectElementChange(n)||{type:"complex",confidence:.5}}computeDiff(t,e){const n=t.split("\n").map(t=>t.trim()).filter(t=>t.length>0),o=e.split("\n").map(t=>t.trim()).filter(t=>t.length>0),s=new Set(n),i=new Set(o);return{added:o.filter(t=>!s.has(t)),removed:n.filter(t=>!i.has(t)),unchanged:o.filter(t=>s.has(t))}}detectTextChange(t){if(1!==t.removed.length||1!==t.added.length)return null;const e=t.removed[0],n=t.added[0],o=e.match(/^<(\w+)[^>]*>(.*)<\/\1>$/),s=n.match(/^<(\w+)[^>]*>(.*)<\/\1>$/);if(!o||!s)return null;const[,i,r]=o,[,a,c]=s;if(i===a&&r!==c){const t=this.extractAttributes(e),o=this.extractAttributes(n);if(JSON.stringify(t)===JSON.stringify(o))return{type:"text-content",path:i,oldValue:r.trim(),newValue:c.trim(),confidence:.99}}return null}detectClassChange(t){if(1!==t.removed.length||1!==t.added.length)return null;const e=t.removed[0],n=t.added[0],o=e.match(/className=["']([^"']+)["']/),s=n.match(/className=["']([^"']+)["']/);if(!o||!s)return null;const i=o[1].split(/\s+/),r=s[1].split(/\s+/),a=t=>t.replace(/className=["'][^"']*["']/,'className="__PLACEHOLDER__"');return a(e)===a(n)?{type:"class-name",oldClasses:i,newClasses:r,confidence:.98}:null}detectAttributeChange(t){if(1!==t.removed.length||1!==t.added.length)return null;const e=t.removed[0],n=t.added[0],o=this.extractAttributes(e),s=this.extractAttributes(n),i=Object.keys(s).find(t=>o[t]!==s[t]);if(!i)return null;const r=Object.keys(o),a=Object.keys(s);return r.length!==a.length?null:r.filter(t=>t!==i&&o[t]===s[t]).length===r.length-1?{type:"attribute",attribute:i,oldValue:o[i],newValue:s[i],confidence:.97}:null}detectStyleChange(t){if(1!==t.removed.length||1!==t.added.length)return null;const e=t.removed[0],n=t.added[0],o=e.match(/style=\{\{([^}]+)\}\}/),s=n.match(/style=\{\{([^}]+)\}\}/);if(!o||!s)return null;const i=this.parseInlineStyle(o[1]),r=this.parseInlineStyle(s[1]),a=Object.keys(r).find(t=>i[t]!==r[t]);return a?Object.keys(i).length!==Object.keys(r).length?null:Object.keys(i).filter(t=>t!==a&&i[t]===r[t]).length===Object.keys(i).length-1?{type:"inline-style",styleProperty:a,oldValue:i[a],newValue:r[a],confidence:.96}:null:null}detectElementChange(t){if(1===t.added.length&&0===t.removed.length){const e=t.added[0];if(e.match(/^<(\w+)/))return{type:"element-added",element:e,confidence:.9}}if(1===t.removed.length&&0===t.added.length){const e=t.removed[0];if(e.match(/^<(\w+)/))return{type:"element-removed",element:e,confidence:.9}}return null}extractAttributes(t){const e={},n=/(\w+)=["']([^"']+)["']/g;let o;for(;null!==(o=n.exec(t));)e[o[1]]=o[2];return e}parseInlineStyle(t){const e={},n=t.split(",");for(const t of n){const[n,o]=t.split(":").map(t=>t.trim());if(n&&o){const t=o.replace(/['"]/g,"");e[n]=t}}return e}buildCacheKey(t,e){switch(e.type){case"text-content":return`${t}:text:${e.path}:${e.oldValue}‚Üí${e.newValue}`;case"class-name":return`${t}:class:${e.oldClasses?.join(",")}‚Üí${e.newClasses?.join(",")}`;case"attribute":return`${t}:attr:${e.attribute}:${e.oldValue}‚Üí${e.newValue}`;case"inline-style":return`${t}:style:${e.styleProperty}:${e.oldValue}‚Üí${e.newValue}`;case"element-added":return`${t}:add:${this.hashElement(e.element)}`;case"element-removed":return`${t}:remove:${this.hashElement(e.element)}`;default:return`${t}:complex`}}hashElement(t){let e=0;for(let n=0;n<t.length;n++)e=(e<<5)-e+t.charCodeAt(n),e&=e;return e.toString(36)}}class f{constructor(){this.templates=new Map,this.componentStates=new Map,this.hexPathIndex=new Map,this.nullPaths=new Map}loadTemplateMap(t,e){console.log(`[TemplateState] Loading ${Object.keys(e.templates).length} templates for ${t}`);const n=new Map,o=new Set;for(const[s,i]of Object.entries(e.templates)){const e=`${t}:${s}`,r={template:i.templateString||i.template,bindings:i.bindings,slots:i.slots,path:i.path,type:i.type};this.templates.set(e,r);const a=s.split(".");if("null"===a[a.length-1]){const t=a.slice(0,-1).join(".");o.add(t),console.log(`[TemplateState] Null path detected: ${t}`);const e=a.slice(0,-1);if(e.length>0){const t=e[e.length-1],o=e.length>1?e.slice(0,-1).join("."):"";n.has(o)||n.set(o,new Set),n.get(o).add(t)}continue}for(let t=0;t<a.length;t++){const e=a[t];if(e.startsWith("@"))continue;const o=t>0?a.slice(0,t).join("."):"";n.has(o)||n.set(o,new Set),n.get(o).add(e)}}this.nullPaths.set(t,o);const s=new Map;for(const[t,e]of n.entries())s.set(t,Array.from(e).sort());this.hexPathIndex.set(t,s),console.log(`[TemplateState] Built hierarchical hex path index for ${t}:`,s),this.componentStates.has(t)||this.componentStates.set(t,new Map)}getChildrenAtPath(t,e){const n=this.hexPathIndex.get(t);if(!n)return void console.warn(`[TemplateState] No hierarchy found for component ${t}`);const o=n.get(e);return console.log(`[TemplateState] getChildrenAtPath(${t}, "${e}") -> ${o?.length||0} children:`,o),o}isPathNull(t,e){return this.nullPaths.get(t)?.has(e)??!1}navigateToPath(t,e,n){if(""===n||"."===n)return t;let o=t;const s=n.split(".");let i="";for(let t=0;t<s.length;t++){const n=s[t];i=i?`${i}.${n}`:n;const r=t>0?s.slice(0,t).join("."):"",a=this.getChildrenAtPath(e,r);if(!a)return console.error(`[TemplateState] No children found at parent path "${r}"`),null;let c=0;for(const t of a){const o=r?`${r}.${t}`:t;if(t===n)break;this.isPathNull(e,o)||c++}if(c>=o.childNodes.length)return console.error(`[TemplateState] DOM index ${c} out of bounds (${o.childNodes.length} children) at path "${i}"`),null;o=o.childNodes[c]}return o}removeFromNullPaths(t,e){const n=this.nullPaths.get(t);n&&(n.delete(e),console.log(`[TemplateState] Removed ${e} from null paths for ${t}`))}addToNullPaths(t,e){let n=this.nullPaths.get(t);n||(n=new Set,this.nullPaths.set(t,n)),n.add(e),console.log(`[TemplateState] Added ${e} to null paths for ${t}`)}registerTemplate(t,e,n){const o=`${t}:${e}`;this.templates.set(o,n)}getTemplate(t,e){const n=`${t}:${e}`;return this.templates.get(n)}getComponentTemplates(t){const e=new Map;for(const[n,o]of this.templates.entries())if(n.startsWith(`${t}:`)){const s=n.substring(t.length+1);e.set(s,o)}return e}getTemplatesBoundTo(t,e){const n=[];for(const[o,s]of this.templates.entries())o.startsWith(`${t}:`)&&s.bindings.includes(e)&&n.push(s);return n}updateState(t,e,n){let o=this.componentStates.get(t);o||(o=new Map,this.componentStates.set(t,o)),o.set(e,n)}getStateValue(t,e){return this.componentStates.get(t)?.get(e)}render(t,e){const n=this.getTemplate(t,e);if(!n)return null;const o=n.bindings.map(e=>this.getStateValue(t,e));return this.renderWithParams(n.template,o)}renderWithParams(t,e){let n=t;return e.forEach((t,e)=>{const o=`{${e}}`,s=null!=t?String(t):"";n=n.replace(o,s)}),n}applyTemplatePatch(t){const{componentId:e,path:n,template:o,params:s,bindings:i,slots:r,attribute:a}=t,c=[];for(const t of i){const n=this.getStateValue(e,t);c.push(void 0!==n?n:s[c.length])}const l=this.renderWithParams(o,c),h=`${e}:${this.buildNodePathKey(n)}`,d=this.templates.get(h);return d?(d.template=o,d.bindings=i,d.slots=r,a&&(d.attribute=a)):this.templates.set(h,{template:o,bindings:i,slots:r,path:n,type:a?"attribute":"dynamic",attribute:a}),console.log(`[TemplateState] Applied template patch: "${o}" ‚Üí "${l}"`),{text:l,path:n}}buildNodePathKey(t){return t.replace(/\./g,"_")}clearComponent(t){const e=[];for(const n of this.templates.keys())n.startsWith(`${t}:`)&&e.push(n);for(const t of e)this.templates.delete(t);this.componentStates.delete(t)}clear(){this.templates.clear(),this.componentStates.clear()}getStats(){const t=this.componentStates.size,e=this.templates.size;let n=0;for(const t of this.templates.values())n+=2*(t.template?.length||0),n+=20*(t.bindings?.length||0),n+=4*(t.slots?.length||0),n+=2*(t.path?.length||0);return{componentCount:t,templateCount:e,memoryKB:Math.round(n/1024),avgTemplatesPerComponent:e/Math.max(t,1)}}}const y=new f;class b{constructor(t,e={}){this.ws=null,this.previousVNodes=new Map,this.previousTsx=new Map,this.tsxPredictionCache=new Map,this.pendingVerifications=new Map,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.nullPaths=new Map,this.minimact=t,this.config={enabled:!0,wsUrl:this.getDefaultWsUrl(),debounceMs:50,showNotifications:!0,logLevel:"info",...e},this.metrics={lastUpdateTime:0,updateCount:0,averageLatency:0,cacheHits:0,cacheMisses:0,errors:0},this.detector=new g,this.config.enabled&&this.connect()}getDefaultWsUrl(){return`${"https:"===window.location.protocol?"wss:":"ws:"}//${window.location.host}/minimact-hmr`}connect(){if(this.config.wsUrl)try{this.ws=new WebSocket(this.config.wsUrl),this.ws.onopen=()=>{this.log("info","‚úÖ Hot reload connected"),this.reconnectAttempts=0,this.showToast("üî• Hot reload enabled","success")},this.ws.onmessage=t=>{this.handleMessage(JSON.parse(t.data))},this.ws.onerror=t=>{this.log("error","Hot reload connection error:",t)},this.ws.onclose=()=>{this.log("warn","Hot reload disconnected"),this.attemptReconnect()}}catch(t){this.log("error","Failed to connect to hot reload server:",t)}}attemptReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts)return void this.log("error","Max reconnection attempts reached");this.reconnectAttempts++;const t=Math.min(1e3*Math.pow(2,this.reconnectAttempts),1e4);this.log("info",`Reconnecting in ${t}ms... (attempt ${this.reconnectAttempts})`),setTimeout(()=>{this.connect()},t)}async handleMessage(t){const e=performance.now();switch(t.type){case"template-map":this.handleTemplateMap(t);break;case"template-patch":await this.handleTemplatePatch(t);break;case"file-change":await this.handleFileChange(t);break;case"error":this.handleError(t);break;case"connected":this.log("info","Hot reload server ready");break;case"rerender-complete":this.log("debug","Server re-render complete")}const n=performance.now()-e;this.updateMetrics(n)}async handleFileChange(t){if(!t.componentId||!t.code)return;const e=performance.now();this.log("debug",`üìù File changed: ${t.filePath}`);try{const n=this.previousTsx.get(t.componentId)||"";if(!n)return this.previousTsx.set(t.componentId,t.code),void this.log("debug","First load - cached TSX");const o=this.detector.detectEditPattern(n,t.code);if(this.log("debug",`Detected pattern: ${o.type} (confidence: ${(100*o.confidence).toFixed(0)}%)`),o.confidence>.9){const n=this.detector.buildCacheKey(t.componentId,o),s=this.tsxPredictionCache.get(n);if(s){const n=this.minimact.getComponent(t.componentId);if(n){this.minimact.domPatcher.applyPatches(n.element,s);const o=performance.now()-e;return this.log("info",`üöÄ INSTANT! Applied cached patches in ${o.toFixed(1)}ms`),this.metrics.cacheHits++,this.showToast(`‚ö° ${o.toFixed(0)}ms`,"success",800),this.flashComponent(n.element),this.previousTsx.set(t.componentId,t.code),void this.verifyWithServer(t.componentId,t.code)}}else this.log("debug",`No cache hit for key: ${n}`)}this.log("info","‚ö†Ô∏è No prediction - requesting server render"),this.metrics.cacheMisses++,await this.requestServerRerender(t.componentId,t.code);const s=performance.now()-e;this.log("info",`‚úÖ Server render complete in ${s.toFixed(1)}ms`),this.showToast(`üîÑ ${s.toFixed(0)}ms`,"info",1e3),this.previousTsx.set(t.componentId,t.code)}catch(t){this.log("error","Hot reload failed:",t),this.metrics.errors++,this.showToast("‚ùå Hot reload failed","error")}}async requestServerRerender(t,e){return new Promise((n,o)=>{const s=setTimeout(()=>{o(new Error("Server rerender timeout"))},5e3);this.ws?.send(JSON.stringify({type:"request-rerender",componentId:t,code:e,timestamp:Date.now()}));const i=e=>{const o=JSON.parse(e.data);"rerender-complete"===o.type&&o.componentId===t&&(clearTimeout(s),this.ws?.removeEventListener("message",i),n())};this.ws?.addEventListener("message",i)})}async verifyWithServer(t,e){try{this.ws?.send(JSON.stringify({type:"verify-tsx",componentId:t,code:e,timestamp:Date.now()})),this.log("debug",`Verification requested for ${t}`)}catch(t){this.log("warn","Verification request failed:",t)}}handleTemplateMap(t){if(!t.templateMap||!t.componentId)return;const e=performance.now(),n=t.componentId,o=t.templateMap.templates;console.log(`[HotReload] üîç Processing template map for ${n}:`,{newTemplateCount:Object.keys(o).length,newTemplateKeys:Object.keys(o).slice(0,5)});const s=Object.keys(o)[0];s&&console.log("[HotReload] üîç First template structure:",s,o[s]);const i=new Map;console.log("[HotReload] üîç Checking for existing templates...");for(const[t,e]of Object.entries(o)){const o=y.getTemplate(n,t),s=e.templateString||e.template;if(o){const e=o.template!==s;console.log(`[HotReload] ${e?"üî•":"‚úÖ"} Template "${t}": old="${o.template}" new="${s}" changed=${e}`),i.set(t,o)}else console.log(`[HotReload] ‚ùå No existing template for ${t}, new="${s}"`)}console.log(`[HotReload] üìã Found ${i.size} existing templates out of ${Object.keys(o).length}`),y.loadTemplateMap(n,t.templateMap);const r=this.minimact.componentRegistry.getByType(n);if(console.log(`[HotReload] üîç Found ${r.length} instance(s) of type "${n}"`),0===r.length)return void console.warn(`[HotReload] ‚ö†Ô∏è No instances found for component type "${n}"`);for(const t of r){console.log(`[HotReload] üì¶ Processing instance ${t.instanceId.substring(0,8)}...`);const e=[];let n=0;for(const[s,r]of Object.entries(o)){const o=i.get(s);if(o&&o.template!==r.template){n++,console.log(`[HotReload] üî• Template changed #${n}: "${o.template}" ‚Üí "${r.template}"`);const s=r.bindings.map(e=>y.getStateValue(t.instanceId,e)),i=y.renderWithParams(r.template,s);"attribute"===r.type&&r.attribute?e.push({type:"UpdateProp",path:r.path,prop:r.attribute,value:i}):e.push({type:"UpdateText",path:r.path,text:i})}}console.log(`[HotReload] üìä Instance summary: ${n} changed, ${e.length} patches`),e.length>0&&(this.minimact.domPatcher.applyPatches(t.element,e),this.flashComponent(t.element),console.log(`[HotReload] ‚úÖ Applied ${e.length} patches to instance ${t.instanceId.substring(0,8)}`))}const a=performance.now()-e,c=Object.keys(o).length;this.log("info",`üì¶ Loaded ${c} templates for ${n} in ${a.toFixed(1)}ms`);const l=y.getStats();this.log("debug",`Template stats: ${l.templateCount} total, ~${l.memoryKB}KB`)}async handleTemplatePatch(t){if(!t.templatePatch||!t.componentId)return;const e=performance.now(),n=t.templatePatch,o=t.componentId;console.log(`[HotReload] üîß Applying template patch to ${o}:`,n);try{if("UpdateAttributeStatic"===n.type){const t=n.attrName,s=n.value;if(!t||void 0===s)return void console.warn("[HotReload] ‚ö†Ô∏è UpdateAttributeStatic missing attrName or value:",n);const i=this.minimact.componentRegistry.getByType(o);if(console.log(`[HotReload] üîç Found ${i.length} instance(s) to update`),0===i.length)return void console.warn(`[HotReload] ‚ö†Ô∏è No instances found for type "${o}"`);for(const r of i){const i=this.findElementByPath(r.element,n.path,o);if(i&&i.nodeType===Node.ELEMENT_NODE){i.setAttribute(t,s);const n=performance.now()-e;console.log(`[HotReload] üöÄ INSTANT! Updated static attribute ${t}="${s}" in ${n.toFixed(1)}ms`),this.log("info",`üöÄ INSTANT! Static attribute updated in ${n.toFixed(1)}ms`),this.metrics.cacheHits++,this.showToast(`‚ö° ${n.toFixed(0)}ms`,"success",800),this.flashComponent(r.element)}else console.warn("[HotReload] ‚ö†Ô∏è Element not found at path:",n.path)}return}const t=y.applyTemplatePatch(n);if(t){console.log("[HotReload] üìù Template patch result:",t);const s=this.minimact.componentRegistry.getByType(o);if(console.log(`[HotReload] üîç Found ${s.length} instance(s) to update`),0===s.length)return void console.warn(`[HotReload] ‚ö†Ô∏è No instances found for type "${o}"`);for(const i of s){const s=this.findElementByPath(i.element,t.path,o);if(s){"UpdateTextTemplate"===n.type?(s.nodeType,Node.TEXT_NODE,s.textContent=t.text):"UpdatePropTemplate"===n.type&&n.attribute&&s.setAttribute(n.attribute,t.text);const o=performance.now()-e;console.log(`[HotReload] üöÄ INSTANT! Updated instance ${i.instanceId.substring(0,8)} in ${o.toFixed(1)}ms: "${t.text}"`),this.log("info",`üöÄ INSTANT! Template updated in ${o.toFixed(1)}ms: "${t.text}"`),this.metrics.cacheHits++,this.showToast(`‚ö° ${o.toFixed(0)}ms`,"success",800),this.flashComponent(i.element)}else console.warn("[HotReload] ‚ö†Ô∏è Element not found at path:",t.path)}}else console.warn("[HotReload] ‚ö†Ô∏è Template patch returned no result")}catch(e){this.log("error","Template patch failed:",e),this.metrics.errors++,await this.requestServerRerender(t.componentId,"")}}isPathNull(t,e){return this.nullPaths.get(t)?.has(e)??!1}setPathNull(t,e){this.nullPaths.has(t)||this.nullPaths.set(t,new Set),this.nullPaths.get(t).add(e)}setPathNonNull(t,e){this.nullPaths.get(t)?.delete(e)}updateNullPaths(t,e){this.nullPaths.set(t,new Set(e))}findElementByPath(t,e,n){if(""===e||"."===e)return t;const o=e.split("."),s=o[o.length-1],i=s?.startsWith("@"),r=i?o.slice(0,-1):o;let a=t;for(let t=0;t<r.length;t++){const e=r[t];if(!a||!a.childNodes)return null;const o=t>0?r.slice(0,t).join("."):"",s=y.getChildrenAtPath(n,o);if(!s)return console.warn(`[HotReload] No children found for parent path "${o}" in ${n}`),null;let i=0,c=!1;for(const t of s){const s=o?`${o}.${t}`:t;if(y.isPathNull(n,s)){if(t===e)return console.warn(`[HotReload] Target path "${s}" is currently null (not rendered)`),null}else{if(t===e){a=a.childNodes[i]||null,c=!0;break}i++}}if(!c||!a)return console.warn(`[HotReload] Element "${e}" not found in DOM at parent path "${o}"`),null}return a}populateTsxCache(t){if(!t.tsxPattern||!t.patches)return;const e=this.detector.buildCacheKey(t.componentId,t.tsxPattern);this.tsxPredictionCache.set(e,t.patches),this.log("debug",`üì¶ Cached TSX pattern: ${e} (${t.patches.length} patches)`)}handleError(t){this.log("error",`Server error: ${t.error}`),this.metrics.errors++,this.showToast(`‚ùå ${t.error}`,"error")}computePatches(t,e){const n=[];if("string"==typeof t&&"string"==typeof e)t!==e&&n.push({type:"text",value:e});else if("object"==typeof t&&"object"==typeof e){if(t.tag!==e.tag)return n.push({type:"replace",vnode:e}),n;const o=t.attributes||{},s=e.attributes||{};for(const t in s)o[t]!==s[t]&&n.push({type:"setAttribute",name:t,value:s[t]});for(const t in o)t in s||n.push({type:"removeAttribute",name:t});const i=t.children||[],r=e.children||[];for(let t=0;t<Math.max(i.length,r.length);t++)if(t>=i.length)n.push({type:"appendChild",vnode:r[t]});else if(t>=r.length)n.push({type:"removeChild",index:t});else{const e=this.computePatches(i[t],r[t]);e.length>0&&n.push({type:"patchChild",index:t,patches:e})}}return n}vnodesMatch(t,e){return JSON.stringify(t)===JSON.stringify(e)}flashComponent(t){t.style.transition="box-shadow 0.3s ease",t.style.boxShadow="0 0 10px 2px rgba(255, 165, 0, 0.6)",setTimeout(()=>{t.style.boxShadow="",setTimeout(()=>{t.style.transition=""},300)},300)}updateMetrics(t){this.metrics.updateCount++,this.metrics.lastUpdateTime=Date.now(),this.metrics.averageLatency=(this.metrics.averageLatency*(this.metrics.updateCount-1)+t)/this.metrics.updateCount}showToast(t,e="info",n=2e3){if(!this.config.showNotifications)return;const o=document.createElement("div");o.textContent=t,o.style.cssText=`\n      position: fixed;\n      bottom: 20px;\n      right: 20px;\n      padding: 12px 20px;\n      background: ${"success"===e?"#10b981":"error"===e?"#ef4444":"#3b82f6"};\n      color: white;\n      border-radius: 6px;\n      font-family: system-ui, -apple-system, sans-serif;\n      font-size: 14px;\n      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n      z-index: 10000;\n      animation: slideIn 0.3s ease;\n    `,document.body.appendChild(o),setTimeout(()=>{o.style.animation="slideOut 0.3s ease",setTimeout(()=>o.remove(),300)},n)}log(t,...e){const n={debug:0,info:1,warn:2,error:3},o=n[this.config.logLevel];if(n[t]>=o){const n="[Minimact HMR]";console[t](n,...e)}}getMetrics(){return{...this.metrics}}enable(){this.config.enabled||(this.config.enabled=!0,this.connect())}disable(){this.config.enabled=!1,this.ws&&(this.ws.close(),this.ws=null)}dispose(){this.disable(),this.previousVNodes.clear(),this.pendingVerifications.clear()}}const v=document.createElement("style");v.textContent="\n  @keyframes slideIn {\n    from {\n      transform: translateX(400px);\n      opacity: 0;\n    }\n    to {\n      transform: translateX(0);\n      opacity: 1;\n    }\n  }\n\n  @keyframes slideOut {\n    from {\n      transform: translateX(0);\n      opacity: 1;\n    }\n    to {\n      transform: translateX(400px);\n      opacity: 0;\n    }\n  }\n",document.head.appendChild(v);class w{constructor(){this.typeToInstances=new Map,this.instanceToMeta=new Map}register(t){const{type:e,instanceId:n}=t;this.instanceToMeta.set(n,t),this.typeToInstances.has(e)||this.typeToInstances.set(e,new Set),this.typeToInstances.get(e).add(t),console.log(`[Registry] ‚úÖ Registered ${e} instance ${n.substring(0,8)}...`)}unregister(t){const e=this.instanceToMeta.get(t);if(!e)return;this.instanceToMeta.delete(t);const n=this.typeToInstances.get(e.type);n&&(n.delete(e),0===n.size&&this.typeToInstances.delete(e.type)),console.log(`[Registry] ‚ùå Unregistered ${e.type} instance ${t.substring(0,8)}...`)}getByType(t){const e=this.typeToInstances.get(t);return e?Array.from(e):[]}getByInstanceId(t){return this.instanceToMeta.get(t)}getTypes(){return Array.from(this.typeToInstances.keys())}getInstanceCount(){return this.instanceToMeta.size}getStats(){const t={};for(const[e,n]of this.typeToInstances.entries())t[e]=n.size;return{types:this.typeToInstances.size,instances:this.instanceToMeta.size,typeBreakdown:t}}clear(){this.typeToInstances.clear(),this.instanceToMeta.clear(),console.log("[Registry] üßπ Cleared all components")}}const C={};let T=!1;function S(t,e){T&&console.log(`[ClientComputed] ${t}`,e||"")}function I(t){const e=C[t];if(!e)return S("No computed variables for component",{componentId:t}),{};const n={};for(const[t,o]of Object.entries(e))try{const e=o.computeFn();o.lastValue=e,n[t]=e}catch(e){console.error(`[ClientComputed] Error computing '${t}':`,e),n[t]=void 0}return S("Computed all variables",{componentId:t,result:n}),n}function M(t,e){const n=C[t];if(!n)return{};const o={};for(const[s,i]of Object.entries(n))if(!i.dependencies||i.dependencies.includes(e))try{const n=i.computeFn();i.lastValue=n,o[s]=n,S("Recomputed dependent variable",{componentId:t,varName:s,changedStateKey:e,value:n})}catch(t){console.error(`[ClientComputed] Error recomputing '${s}':`,t),o[s]=void 0}return o}function $(t){return!!C[t]&&Object.keys(C[t]).length>0}class R{constructor(t,e,n,o,s={}){this.taskId=t,this.componentId=e,this.signalR=n,this.context=o,this.status="idle",this.progress=0,this.chunks=[],this.chunkCount=0,this._options=s,this.streaming=s.stream||!1,this._createPromise()}_createPromise(){this._promise=new Promise((t,e)=>{this._resolve=t,this._reject=e})}get promise(){return this._promise}get idle(){return"idle"===this.status}get running(){return"running"===this.status}get complete(){return"complete"===this.status}get failed(){return"error"===this.status}get cancelled(){return"cancelled"===this.status}start(...t){this.status="running",this.startedAt=new Date,this.completedAt=void 0,this.progress=0,this.error=void 0,this.streaming?(this.chunks=[],this.chunkCount=0,this.partial=void 0):this.result=void 0,this._triggerRerender(),this.signalR.invoke("StartServerTask",this.componentId,this.taskId,t||[]).catch(t=>{console.error(`[Minimact] Failed to start task ${this.taskId}:`,t),this.status="error",this.error=t,this.completedAt=new Date,this.duration=this.completedAt.getTime()-(this.startedAt?.getTime()||0),this._reject?.(t),this._triggerRerender()})}retry(...t){"error"===this.status||"cancelled"===this.status?(this._createPromise(),this.status="running",this.startedAt=new Date,this.completedAt=void 0,this.progress=0,this.error=void 0,this.streaming?(this.chunks=[],this.chunkCount=0,this.partial=void 0):this.result=void 0,this._triggerRerender(),this.signalR.invoke("RetryServerTask",this.componentId,this.taskId,t||[]).catch(t=>{console.error(`[Minimact] Failed to retry task ${this.taskId}:`,t),this.status="error",this.error=t,this.completedAt=new Date,this.duration=this.completedAt.getTime()-(this.startedAt?.getTime()||0),this._reject?.(t),this._triggerRerender()})):console.warn("[Minimact] Can only retry failed or cancelled tasks")}cancel(){"running"===this.status?this.signalR.invoke("CancelServerTask",this.componentId,this.taskId).then(()=>{this.status="cancelled",this.completedAt=new Date,this.duration=this.completedAt.getTime()-(this.startedAt?.getTime()||0),this._reject?.(new Error("Task cancelled by user")),this._triggerRerender()}).catch(t=>{console.error(`[Minimact] Failed to cancel task ${this.taskId}:`,t)}):console.warn("[Minimact] Can only cancel running tasks")}_updateFromServer(t){const e=this.status;this.status=t.status,this.progress=t.progress||0,this.result=t.result,t.error&&(this.error=new Error(t.error)),t.startedAt&&(this.startedAt=new Date(t.startedAt)),t.completedAt&&(this.completedAt=new Date(t.completedAt)),t.duration&&(this.duration=t.duration),"complete"===this.status&&"complete"!==e?this._resolve&&this._resolve(this.result):"error"===this.status&&"error"!==e?this._reject&&this._reject(this.error):"cancelled"===this.status&&"cancelled"!==e&&this._reject&&this._reject(new Error("Task cancelled")),e===this.status&&this.progress===t.progress||this._triggerRerender()}_triggerRerender(){if(!this.context||!this.context.hintQueue)return;const t={[this.taskId]:{status:this.status,progress:this.progress,chunkCount:this.chunkCount}},e=this.context.hintQueue.matchHint(this.context.componentId,t);e?(console.log(`[Minimact] üü¢ Task state change predicted! Applying ${e.patches.length} patches`),this.context.domPatcher.applyPatches(this.context.element,e.patches)):console.log("[Minimact] üî¥ Task state change not predicted")}}class E{constructor(t,e,n,o,s){this.reducerId=t,this.componentId=e,this.signalR=n,this.context=o,this.dispatching=!1,this.state=s}dispatch(t){this.dispatching=!0,this.error=void 0,this.lastDispatchedAt=new Date,t&&"object"==typeof t&&"type"in t&&(this.lastActionType=String(t.type)),this._triggerRerender(),this.signalR.invoke("DispatchServerReducer",this.componentId,this.reducerId,t).catch(t=>{console.error(`[Minimact] Failed to dispatch action to reducer ${this.reducerId}:`,t),this.dispatching=!1,this.error=t,this._triggerRerender()})}dispatchAsync(t){return this.dispatching=!0,this.error=void 0,this.lastDispatchedAt=new Date,t&&"object"==typeof t&&"type"in t&&(this.lastActionType=String(t.type)),this._pendingPromise=new Promise((t,e)=>{this._pendingResolve=t,this._pendingReject=e}),this._triggerRerender(),this.signalR.invoke("DispatchServerReducer",this.componentId,this.reducerId,t).catch(t=>{console.error(`[Minimact] Failed to dispatch action to reducer ${this.reducerId}:`,t),this.dispatching=!1,this.error=t,this._pendingReject?.(t),this._triggerRerender()}),this._pendingPromise}_updateFromServer(t,e){const n=this.state;this.state=t,this.dispatching=!1,e?(this.error=new Error(e),this._pendingReject?.(this.error)):(this.error=void 0,this._pendingResolve?.(t)),this._pendingPromise=void 0,this._pendingResolve=void 0,this._pendingReject=void 0,n!==t&&this._triggerRerender()}_triggerRerender(){if(!this.context||!this.context.hintQueue)return;const t={[this.reducerId]:{state:this.state,dispatching:this.dispatching,error:this.error?.message}},e=this.context.hintQueue.matchHint(this.context.componentId,t);e?(console.log(`[Minimact] üü¢ Reducer state change predicted! Applying ${e.patches.length} patches`),this.context.domPatcher.applyPatches(this.context.element,e.patches)):console.log("[Minimact] üî¥ Reducer state change not predicted")}}let P=null,A=null,k=0,x=0,H=0,N=0,L=0;function D(t,e){if(""===e||"."===e)return t;let n=t;const o=e.split(".").map(t=>parseInt(t,16));for(const t of o){if(!n||!n.childNodes)return null;n=n.childNodes[t]||null}return n}function F(t){if(!A)throw new Error("useState must be called within a component render");const e=A,n="state_"+k++;e.state.has(n)||e.state.set(n,t);const o=e.state.get(n),s=t=>{const o=performance.now(),s="function"==typeof t?t(e.state.get(n)):t,i={[n]:s},r=e.hintQueue.matchHint(e.componentId,i);if(r){const t=performance.now()-o;console.log(`[Minimact] üü¢ CACHE HIT! Hint '${r.hintId}' matched - applying ${r.patches.length} patches in ${t.toFixed(2)}ms`),e.domPatcher.applyPatches(e.element,r.patches),e.playgroundBridge&&e.playgroundBridge.cacheHit({componentId:e.componentId,hintId:r.hintId,latency:t,confidence:r.confidence,patchCount:r.patches.length})}else{const t=performance.now()-o;console.log("[Minimact] üî¥ CACHE MISS - No prediction for state change:",i),e.playgroundBridge&&e.playgroundBridge.cacheMiss({componentId:e.componentId,methodName:`setState(${n})`,latency:t,patchCount:0})}e.state.set(n,s),y.updateState(e.componentId,n,s);const a=y.getTemplatesBoundTo(e.componentId,n);for(const t of a){const o=t.path.replace(/\./g,"_"),s=y.render(e.componentId,o);if(null!==s){const o=D(e.element,t.path);o&&(o.nodeType===Node.TEXT_NODE?o.textContent=s:o instanceof HTMLElement&&(t.attribute?o.setAttribute(t.attribute,s):o.textContent=s),console.log(`[Minimact] üìã Template updated: "${s}" (${n} changed)`))}}e.signalR.updateComponentState(e.componentId,n,s).catch(t=>{console.error("[Minimact] Failed to sync state to server:",t)})};return Array.isArray(o)?[o,U(s,o,n,e)]:[o,s]}function O(t,e){if(!A)throw new Error("useEffect must be called within a component render");const n=A,o=x++;if(n.effects[o]){const s=n.effects[o];(!e||!s.deps||e.length!==s.deps.length||e.some((t,e)=>t!==s.deps[e]))&&(s.cleanup&&s.cleanup(),s.callback=t,s.deps=e,queueMicrotask(()=>{const e=t();"function"==typeof e&&(s.cleanup=e)}))}else n.effects[o]={callback:t,deps:e,cleanup:void 0},queueMicrotask(()=>{const e=t();"function"==typeof e&&(n.effects[o].cleanup=e)})}function _(t){if(!A)throw new Error("useRef must be called within a component render");const e=A,n="ref_"+H++;return e.refs.has(n)||e.refs.set(n,{current:t}),e.refs.get(n)}function U(t,e,n,o){const s=t;return s.append=t=>{const s=[...e,t];o.state.set(n,s),y.updateState(o.componentId,n,s),o.signalR.updateComponentStateWithOperation(o.componentId,n,s,{type:"Append",item:t}).catch(t=>{console.error("[Minimact] Failed to sync array append to server:",t)}),console.log(`[Minimact] üîµ Array append: ${n}`,t)},s.prepend=t=>{const s=[t,...e];o.state.set(n,s),y.updateState(o.componentId,n,s),o.signalR.updateComponentStateWithOperation(o.componentId,n,s,{type:"Prepend",item:t}).catch(t=>{console.error("[Minimact] Failed to sync array prepend to server:",t)}),console.log(`[Minimact] üîµ Array prepend: ${n}`,t)},s.insertAt=(t,s)=>{const i=[...e];i.splice(t,0,s),o.state.set(n,i),y.updateState(o.componentId,n,i),o.signalR.updateComponentStateWithOperation(o.componentId,n,i,{type:"InsertAt",index:t,item:s}).catch(t=>{console.error("[Minimact] Failed to sync array insert to server:",t)}),console.log(`[Minimact] üîµ Array insertAt(${t}): ${n}`,s)},s.removeAt=t=>{const s=e.filter((e,n)=>n!==t);o.state.set(n,s),y.updateState(o.componentId,n,s),o.signalR.updateComponentStateWithOperation(o.componentId,n,s,{type:"RemoveAt",index:t}).catch(t=>{console.error("[Minimact] Failed to sync array remove to server:",t)}),console.log(`[Minimact] üîµ Array removeAt(${t}): ${n}`)},s.updateAt=(t,s)=>{const i=[...e];i[t]="function"==typeof s?s(e[t]):{...e[t],...s},o.state.set(n,i),y.updateState(o.componentId,n,i),o.signalR.updateComponentStateWithOperation(o.componentId,n,i,{type:"UpdateAt",index:t,item:i[t]}).catch(t=>{console.error("[Minimact] Failed to sync array update to server:",t)}),console.log(`[Minimact] üîµ Array updateAt(${t}): ${n}`,i[t])},s.clear=()=>{t([])},s.removeWhere=n=>{const o=e.filter(t=>!n(t));t(o)},s.updateWhere=(n,o)=>{const s=e.map(t=>n(t)?{...t,...o}:t);t(s)},s.appendMany=n=>{const o=[...e,...n];t(o)},s.removeMany=n=>{const o=e.filter((t,e)=>!n.includes(e));t(o)},s}function j(t,e={}){if(!A)throw new Error("useServerTask must be called within a component render");const n=A,o="serverTask_"+N++;if(n.serverTasks||(n.serverTasks=new Map),!n.serverTasks.has(o)){const t=new R(o,n.componentId,n.signalR,n,e);n.serverTasks.set(o,t)}return n.serverTasks.get(o)}let V=null;class W{constructor(t={}){this.channels=new Map,this.debugLogging=!1,this.debugLogging=t.debugLogging||!1}subscribe(t,e){this.channels.has(t)||this.channels.set(t,{subscribers:new Set,lastMessage:null});const n=this.channels.get(t);e&&n.subscribers.add(e);const o=n.lastMessage||{value:void 0,timestamp:Date.now()};return this.log(`Subscribed to '${t}'`,{hasCallback:!!e}),o}unsubscribe(t,e){const n=this.channels.get(t);n&&(n.subscribers.delete(e),this.log(`Unsubscribed from '${t}'`))}publish(t,e,n={}){this.channels.has(t)||this.channels.set(t,{subscribers:new Set,lastMessage:null});const o=this.channels.get(t),s={value:e,error:n.error,waiting:n.waiting,source:n.source,timestamp:Date.now(),isStale:!1};o.lastMessage=s,o.subscribers.forEach(e=>{try{e(s)}catch(e){console.error(`[Minimact PubSub] Error in subscriber for '${t}':`,e)}}),this.log(`Published to '${t}'`,{subscribers:o.subscribers.size,value:e})}clear(t){this.channels.delete(t),this.log(`Cleared channel '${t}'`)}clearAll(){this.channels.clear(),this.log("Cleared all channels")}getStats(){return{totalChannels:this.channels.size,channels:Array.from(this.channels.entries()).map(([t,e])=>({name:t,subscribers:e.subscribers.size,hasLastMessage:!!e.lastMessage}))}}log(t,e){this.debugLogging&&console.log(`[Minimact PubSub] ${t}`,e||"")}}let B=null;function z(t){return B||(B=new W(t)),B}class K{constructor(t=document.body,e={}){if(this.hotReload=null,this.eventDelegation=null,"string"==typeof t){const e=document.querySelector(t);if(!e)throw new Error(`[Minimact] Root element not found: ${t}`);this.rootElement=e}else this.rootElement=t;var n;this.options={hubUrl:e.hubUrl||"/minimact",enableDebugLogging:e.enableDebugLogging||!1,reconnectInterval:e.reconnectInterval||5e3,enableHotReload:!1!==e.enableHotReload,hotReloadWsUrl:e.hotReloadWsUrl},this.signalR=new a(this.options.hubUrl,{reconnectInterval:this.options.reconnectInterval,debugLogging:this.options.enableDebugLogging}),this.domPatcher=new c({debugLogging:this.options.enableDebugLogging,templateState:y}),this.clientState=new l({debugLogging:this.options.enableDebugLogging}),this.hydration=new d(this.clientState,{debugLogging:this.options.enableDebugLogging}),this.hintQueue=new m({debugLogging:this.options.enableDebugLogging}),this.playgroundBridge=new u({debugLogging:this.options.enableDebugLogging}),this.componentRegistry=new w,this.options.enableHotReload&&(this.hotReload=new b(this,{enabled:!0,wsUrl:this.options.hotReloadWsUrl,debounceMs:50,showNotifications:!0,logLevel:this.options.enableDebugLogging?"debug":"info"})),n=this.options.enableDebugLogging,T=n,this.log("Minimact initialized",{rootElement:this.rootElement,options:this.options})}async start(){this.setupSignalRHandlers(),await this.signalR.start(),this.hydration.hydrateAll(),console.log("[Minimact] üîç Registering hydrated components..."),this.registerHydratedComponents(),console.log("[Minimact] üìä Registry stats:",this.componentRegistry.getStats()),this.eventDelegation=new h(this.rootElement,(t,e,n)=>this.signalR.invokeComponentMethod(t,e,n),{debugLogging:this.options.enableDebugLogging}),await this.registerAllComponents(),this.log("Minimact started")}async stop(){this.eventDelegation&&(this.eventDelegation.destroy(),this.eventDelegation=null),await this.signalR.stop(),this.log("Minimact stopped")}setupSignalRHandlers(){this.signalR.on("updateComponent",({componentId:t,html:e})=>{const n=this.hydration.getComponent(t);n&&(this.domPatcher.replaceHTML(n.element,e),this.log("Component HTML updated",{componentId:t}))}),this.signalR.on("applyPatches",({componentId:t,patches:e})=>{const n=this.hydration.getComponent(t);n&&(this.domPatcher.applyPatches(n.element,e,n.type),this.log("Patches applied",{componentId:t,patchCount:e.length}))}),this.signalR.on("applyPrediction",({componentId:t,patches:e,confidence:n})=>{const o=this.hydration.getComponent(t);o&&(this.domPatcher.applyPatches(o.element,e,o.type),this.log(`Prediction applied (${(100*n).toFixed(0)}% confident)`,{componentId:t,patchCount:e.length}))}),this.signalR.on("applyCorrection",({componentId:t,patches:e})=>{const n=this.hydration.getComponent(t);n&&(this.domPatcher.applyPatches(n.element,e,n.type),this.log("Correction applied (prediction was incorrect)",{componentId:t,patchCount:e.length}))}),this.signalR.on("queueHint",t=>{this.hintQueue.queueHint(t),this.log(`Hint '${t.hintId}' queued for component ${t.componentId}`,{patchCount:t.patches.length,confidence:(100*t.confidence).toFixed(0)+"%"}),this.playgroundBridge.predictionReceived({componentId:t.componentId,hintId:t.hintId,patchCount:t.patches.length,confidence:t.confidence})}),this.signalR.on("reconnected",async()=>{this.log("Reconnected - re-registering components"),await this.registerAllComponents()}),this.signalR.on("UpdateServerReducerState",({componentId:t,reducerId:e,state:n,error:o})=>{const s=this.hydration.getComponent(t);if(s&&s.context.serverReducers){const i=s.context.serverReducers.get(e);i&&(i._updateFromServer(n,o),this.log("Server reducer state updated",{componentId:t,reducerId:e}))}}),this.signalR.on("HotReload:TemplateMap",t=>{console.log("[Minimact] üì® HotReload:TemplateMap received:",t),console.log("[Minimact] üîç HotReload manager exists?",!!this.hotReload),this.hotReload?(this.log("Received template map",{componentId:t.componentId}),this.hotReload.handleMessage({type:"template-map",...t})):console.warn("[Minimact] ‚ö†Ô∏è HotReload manager not initialized, cannot process template map")}),this.signalR.on("HotReload:TemplatePatch",t=>{this.hotReload&&(this.log("Received template patch",{componentId:t.componentId}),this.hotReload.handleMessage({type:"template-patch",...t}))}),this.signalR.on("HotReload:FileChange",t=>{this.hotReload&&(this.log("Received file change",{componentId:t.componentId}),this.hotReload.handleMessage({type:"file-change",...t}))}),this.signalR.on("HotReload:Error",t=>{this.hotReload&&console.error("[Minimact Hot Reload] Error:",t.error)}),this.signalR.on("error",({message:t})=>{console.error("[Minimact] Server error:",t)})}async registerAllComponents(){const t=document.querySelectorAll("[data-minimact-component]");for(const e of Array.from(t)){const t=e.getAttribute("data-minimact-component");if(t)try{await this.signalR.registerComponent(t),this.log("Registered component",{componentId:t})}catch(e){console.error("[Minimact] Failed to register component:",t,e)}}}hydrateComponent(t,e){this.hydration.hydrateComponent(t,e)}getComponent(t){return this.hydration.getComponent(t)}registerHydratedComponents(){const t=window.__MINIMACT_VIEWMODEL__;if(!t||!t._componentType||!t._componentId)return void console.warn("[Minimact] ViewModel metadata missing _componentType or _componentId");const e=t._componentType,n=t._componentId,o=document.querySelector(`[data-minimact-component-id="${n}"]`);if(!o)return void console.warn(`[Minimact] Component element not found for ${n}`);const s=this.hydration.getComponent(n);s?(s.type=e,this.componentRegistry.register({type:e,instanceId:n,element:o,context:s.context}),console.log(`[Minimact] Registered ${e} (${n.substring(0,8)}...) in registry`)):console.warn(`[Minimact] Component not hydrated for ${n}`)}getClientState(t,e){return this.clientState.getState(t,e)}setClientState(t,e,n){this.clientState.setState(t,e,n),this.recomputeAndSyncClientState(t,e)}subscribeToState(t,e,n){return this.clientState.subscribe(t,e,n)}async recomputeAndSyncClientState(t,e){if(!$(t))return;const n=e?M(t,e):I(t);if(Object.keys(n).length>0)try{await this.signalR.updateClientComputedState(t,n),this.log("Client-computed state synced",{componentId:t,computed:n})}catch(t){console.error("[Minimact] Failed to sync client-computed state:",t)}}get connectionState(){return this.signalR.state.toString()}get connectionId(){return this.signalR.connectionId}log(t,e){this.options.enableDebugLogging&&console.log(`[Minimact] ${t}`,e||"")}}if("undefined"!=typeof window)if("loading"===document.readyState)document.addEventListener("DOMContentLoaded",()=>{if(document.body.hasAttribute("data-minimact-auto-init")){const t=new K(document.body,{enableDebugLogging:document.body.hasAttribute("data-minimact-debug")});t.start().catch(console.error),window.minimact=t}});else if(document.body.hasAttribute("data-minimact-auto-init")){const t=new K(document.body,{enableDebugLogging:document.body.hasAttribute("data-minimact-debug")});t.start().catch(console.error),window.minimact=t}return"undefined"!=typeof window&&(window.Minimact=K),t.ClientStateManager=l,t.DOMPatcher=c,t.EventDelegation=h,t.HintQueue=m,t.HotReloadManager=b,t.HydrationManager=d,t.Minimact=K,t.MinimactComponentRegistry=w,t.SignalMManager=a,t.TemplateRenderer=p,t.TemplateStateManager=f,t.clearClientComputedComponent=function(t){delete C[t],S("Cleared component",{componentId:t})},t.clearComponentContext=function(){A=null},t.clearContextHookContext=function(){V=null},t.computeAllForComponent=I,t.computeDependentVariables=M,t.computeVariable=function(t,e){const n=C[t]?.[e];if(n)try{const o=n.computeFn();return n.lastValue=o,S("Computed variable",{componentId:t,varName:e,value:o}),o}catch(t){return void console.error(`[ClientComputed] Error computing '${e}':`,t)}else console.warn(`[ClientComputed] Variable '${e}' not registered for component '${t}'`)},t.createContext=function(t,e={}){if("url"===e.scope&&!e.urlPattern)throw new Error(`Context '${t}' with scope 'url' requires urlPattern`);return{key:t,options:{scope:e.scope||"request",urlPattern:e.urlPattern,expiry:e.expiry,defaultValue:e.defaultValue}}},t.default=K,t.getAllLastValues=function(t){const e=C[t];if(!e)return{};const n={};for(const[t,o]of Object.entries(e))n[t]=o.lastValue;return n},t.getClientComputedDebugInfo=function(){const t={};for(const[e,n]of Object.entries(C)){const o=Object.keys(n);t[e]={variableCount:o.length,variables:o}}return{componentCount:Object.keys(C).length,components:t}},t.getComputedVariableNames=function(t){const e=C[t];return e?Object.keys(e):[]},t.getLastValue=function(t,e){return C[t]?.[e]?.lastValue},t.hasClientComputed=$,t.registerClientComputed=function(t,e,n,o){C[t]||(C[t]={}),C[t][e]={varName:e,computeFn:n,dependencies:o},S("Registered client-computed variable",{componentId:t,varName:e,dependencies:o})},t.setComponentContext=function(t){A=t,k=0,x=0,H=0,N=0,L=0,function(t){P=t}(t)},t.setContextHookContext=function(t){V=t},t.templateState=y,t.useAnimationFrame=function(t){return requestAnimationFrame(e=>{try{t(e)}catch(t){console.error("[Minimact useAnimationFrame] Error in animation frame:",t)}})},t.useComputed=function(t,e,n=[],o={}){if(!P)throw new Error("[Minimact] useComputed must be called within a component render");const{memoize:s=!0,expiry:i,debounce:r,throttle:a,initialValue:c}=o,l=P,[h,d]=F(void 0!==c?c:null),p=_(null),m=_(null);function u(e){const n=()=>{l.signalR?l.signalR.updateClientComputedState(l.componentId,{[t]:e}).catch(e=>{console.error(`[Minimact] Failed to sync computed state '${t}':`,e)}):console.warn(`[Minimact] SignalR not available, cannot sync useComputed('${t}')`)};if(r)return null!==m.current&&clearTimeout(m.current),void(m.current=window.setTimeout(()=>{n(),m.current=null},r));n()}return O(()=>{if(s&&p.current&&n.length===p.current.deps.length&&!n.some((t,e)=>!Object.is(t,p.current.deps[e]))){if(!i)return;if(Date.now()-p.current.timestamp<i)return}let o;try{o=e()}catch(e){throw console.error(`[Minimact] Error in useComputed('${t}'):`,e),e}o instanceof Promise?o.then(t=>{s&&(p.current={value:t,timestamp:Date.now(),deps:[...n]}),d(t),u(t)}).catch(e=>{console.error(`[Minimact] Async error in useComputed('${t}'):`,e)}):(s&&(p.current={value:o,timestamp:Date.now(),deps:[...n]}),d(o),u(o))},n),h},t.useContext=function(t){if(!V)throw new Error("[Minimact] useContext must be called within a component render");const e=V,n=`context_${t.key}`;let o=e.state.get(n);return void 0===o&&void 0!==t.options.defaultValue&&(o=t.options.defaultValue),[o,o=>{e.state.set(n,o);const s={[n]:o},i=e.hintQueue.matchHint(e.componentId,s);i&&e.domPatcher.applyPatches(e.element,i.patches),e.signalR.invoke("UpdateContext",{key:t.key,value:o,scope:t.options.scope,urlPattern:t.options.urlPattern,expiry:t.options.expiry}).catch(e=>{console.error(`[Minimact] Failed to update context '${t.key}':`,e)})},()=>{e.state.set(n,void 0);const o={[n]:void 0},s=e.hintQueue.matchHint(e.componentId,o);s&&e.domPatcher.applyPatches(e.element,s.patches),e.signalR.invoke("ClearContext",{key:t.key,scope:t.options.scope,urlPattern:t.options.urlPattern}).catch(e=>{console.error(`[Minimact] Failed to clear context '${t.key}':`,e)})}]},t.useEffect=O,t.useIdleCallback=function(t,e){return"requestIdleCallback"in window?requestIdleCallback(e=>{try{t(e)}catch(t){console.error("[Minimact useIdleCallback] Error in idle callback:",t)}},e):setTimeout(()=>{t({didTimeout:!1,timeRemaining:()=>50})},1)},t.useMacroTask=function(t,e=0){setTimeout(()=>{try{t()}catch(t){console.error("[Minimact useMacroTask] Error in macrotask:",t)}},e)},t.useMarkdown=function(t){return F(t)},t.useMicroTask=function(t){queueMicrotask(()=>{try{t()}catch(t){console.error("[Minimact useMicroTask] Error in microtask:",t)}})},t.usePaginatedServerTask=function(t,e){const n=e.pageSize||20,[o,s]=F(1),[i,r]=F([]),[a,c]=F(0),[l,h]=F(null),d=_(new Map),p=_([]),m=(b=e.dependencies)&&0!==b.length?1===b.length&&"object"==typeof b[0]?b[0]:b.reduce((t,e,n)=>(t[`dep${n}`]=e,t),{}):{},u=j(0,{runtime:e.runtime,parallel:e.parallel}),g=j(0,{runtime:e.runtime}),f=async(t,o=!0)=>{if(o&&d.current.has(t)){const n=d.current.get(t);return r(n),s(t),d.current.delete(t),console.log(`[usePaginatedServerTask] üü¢ Cache hit for page ${t}`),e.prefetchNext&&t<v&&y(t+1),void(e.prefetchPrev&&t>1&&y(t-1))}const i={page:t,pageSize:n,filters:m};p.current=[i],u.start(i);try{const n=await u.promise;r(n),s(t),h(null),console.log(`[usePaginatedServerTask] üî¥ Fetched page ${t} from server`),e.prefetchNext&&t<v&&y(t+1),e.prefetchPrev&&t>1&&y(t-1)}catch(e){h(e.message||"Failed to fetch page"),console.error(`[usePaginatedServerTask] Error fetching page ${t}:`,e)}},y=async t=>{if(d.current.has(t))return;const e={page:t,pageSize:n,filters:m};u.start(e);try{const e=await u.promise;d.current.set(t,e),console.log(`[usePaginatedServerTask] ‚ö° Prefetched page ${t}`)}catch(e){console.error(`[usePaginatedServerTask] Prefetch failed for page ${t}:`,e)}};var b;O(()=>{g.start(m),g.promise.then(t=>{c(t)}).catch(t=>{console.error("[usePaginatedServerTask] Failed to get total count:",t)})},[JSON.stringify(m)]),O(()=>{f(1,!1)},[]),O(()=>{e.dependencies&&e.dependencies.length>0&&(d.current.clear(),f(1,!1))},[JSON.stringify(m)]);const v=Math.ceil(a/n),w=o<v,C=o>1;return{items:i,total:a,totalPages:v,page:o,pageSize:n,pending:"running"===u.status,error:l||u.error?.message,hasNext:w,hasPrev:C,next:()=>{w&&f(o+1)},prev:()=>{C&&f(o-1)},goto:t=>{t>=1&&t<=v&&f(t)},refresh:()=>{d.current.clear(),f(o,!1)},_fetchTask:u,_countTask:g}},t.usePub=function(t){const e=z();return(n,o={})=>{e.publish(t,n,o)}},t.useRef=_,t.useServerReducer=function(t){if(!A)throw new Error("useServerReducer must be called within a component render");const e=A,n="serverReducer_"+L++;if(e.serverReducers||(e.serverReducers=new Map),!e.serverReducers.has(n)){const o=new E(n,e.componentId,e.signalR,e,t);e.serverReducers.set(n,o)}return e.serverReducers.get(n)},t.useServerTask=j,t.useSignalR=function(t,e,n={}){const o=new a(t,{reconnectInterval:n.reconnectInterval,debugLogging:n.debugLogging}),s={data:null,error:null,connected:!1,connectionId:null};return o.on("connected",({connectionId:t})=>{s.connected=!0,s.connectionId=t||null,s.error=null}),o.on("reconnected",({connectionId:t})=>{s.connected=!0,s.connectionId=t||null,s.error=null}),o.on("closed",({error:t})=>{s.connected=!1,s.connectionId=null,t&&(s.error=t.toString())}),o.on("error",({message:t})=>{s.error=t}),e&&o.on("message",t=>{s.data=t,e(t)}),!1!==n.autoConnect&&o.start().catch(t=>{s.error=t.message,console.error("[Minimact useSignalR] Auto-connect failed:",t)}),{state:s,send:async(t,...e)=>{try{await o.invoke(t,...e)}catch(t){throw s.error=t.message,t}},on:(t,e)=>{o.on(t,e)},off:(t,e)=>{o.off(t,e)},connect:async()=>{await o.start()},disconnect:async()=>{await o.stop()}}},t.useState=F,t.useSub=function(t,e){return z().subscribe(t,e)},Object.defineProperty(t,"__esModule",{value:!0}),t}({});
//# sourceMappingURL=core.min.js.map
