{"version":3,"file":"x.esm.js","sources":["../src/transform-handler.ts","../src/projection-engine.ts","../src/integration.ts","../src/use-state-x.ts","../src/index.ts"],"sourcesContent":["/**\r\n * Transform Handler\r\n * Manages transform functions (inline and registry-based)\r\n */\r\n\r\nimport type { TargetProjection, TransformFunction, TransformRegistryEntry } from './types';\r\n\r\n/**\r\n * Global transform registry\r\n * Stores reusable transform functions accessible by ID\r\n */\r\nexport class TransformHandler {\r\n  private static registry = new Map<string, TransformRegistryEntry>();\r\n\r\n  /**\r\n   * Register a reusable transform function\r\n   *\r\n   * @example\r\n   * TransformHandler.registerTransform('currency-usd', v => `$${v.toFixed(2)}`, 'Format as USD currency');\r\n   * TransformHandler.registerTransform('percentage', v => `${(v * 100).toFixed(0)}%`);\r\n   */\r\n  static registerTransform(\r\n    id: string,\r\n    fn: TransformFunction,\r\n    description?: string\r\n  ): void {\r\n    if (this.registry.has(id)) {\r\n      console.warn(`[useStateX] Transform '${id}' already registered. Overwriting.`);\r\n    }\r\n\r\n    this.registry.set(id, { id, fn, description });\r\n  }\r\n\r\n  /**\r\n   * Register multiple transforms at once\r\n   *\r\n   * @example\r\n   * TransformHandler.registerTransforms({\r\n   *   'currency-usd': v => `$${v.toFixed(2)}`,\r\n   *   'percentage': v => `${(v * 100).toFixed(0)}%`,\r\n   *   'uppercase': v => v.toUpperCase()\r\n   * });\r\n   */\r\n  static registerTransforms(transforms: Record<string, TransformFunction>): void {\r\n    Object.entries(transforms).forEach(([id, fn]) => {\r\n      this.registerTransform(id, fn);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get a registered transform by ID\r\n   */\r\n  static getTransform(id: string): TransformFunction | undefined {\r\n    return this.registry.get(id)?.fn;\r\n  }\r\n\r\n  /**\r\n   * Check if a transform ID is registered\r\n   */\r\n  static hasTransform(id: string): boolean {\r\n    return this.registry.has(id);\r\n  }\r\n\r\n  /**\r\n   * Get all registered transform IDs\r\n   */\r\n  static getRegisteredIds(): string[] {\r\n    return Array.from(this.registry.keys());\r\n  }\r\n\r\n  /**\r\n   * Get all registered transforms with metadata\r\n   */\r\n  static getAllTransforms(): TransformRegistryEntry[] {\r\n    return Array.from(this.registry.values());\r\n  }\r\n\r\n  /**\r\n   * Clear all registered transforms\r\n   * Useful for testing\r\n   */\r\n  static clearRegistry(): void {\r\n    this.registry.clear();\r\n  }\r\n\r\n  /**\r\n   * Apply a transform to a value\r\n   * Handles both inline transforms and registry-based transforms\r\n   *\r\n   * @param config - Target projection config\r\n   * @param value - Value to transform\r\n   * @returns Transformed value or stringified value if no transform\r\n   */\r\n  static applyTransform<T>(\r\n    config: TargetProjection<T>,\r\n    value: T\r\n  ): string | number | boolean {\r\n    try {\r\n      // 1. Check if transform ID is provided (Registry approach)\r\n      if (config.transformId) {\r\n        const fn = this.getTransform(config.transformId);\r\n\r\n        if (fn) {\r\n          const result = fn(value);\r\n          return result;\r\n        }\r\n\r\n        console.warn(\r\n          `[useStateX] Transform '${config.transformId}' not found in registry. ` +\r\n          `Falling back to inline transform or toString.`\r\n        );\r\n      }\r\n\r\n      // 2. Use inline transform (Static Analysis approach)\r\n      if (config.transform) {\r\n        const result = config.transform(value);\r\n        return result;\r\n      }\r\n\r\n      // 3. Fallback to toString\r\n      return String(value);\r\n    } catch (error) {\r\n      console.error('[useStateX] Transform error:', error);\r\n\r\n      // Rethrow so caller can handle\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate a transform function\r\n   * Ensures it's pure and serializable (for Babel static analysis)\r\n   *\r\n   * @param fn - Function to validate\r\n   * @returns Validation result\r\n   */\r\n  static validateTransform(fn: Function): {\r\n    isValid: boolean;\r\n    isPure: boolean;\r\n    isSerializable: boolean;\r\n    warnings: string[];\r\n  } {\r\n    const warnings: string[] = [];\r\n    let isPure = true;\r\n    let isSerializable = true;\r\n\r\n    const fnString = fn.toString();\r\n\r\n    // Check for common impure patterns\r\n    if (fnString.includes('Math.random')) {\r\n      warnings.push('Transform uses Math.random() - not pure');\r\n      isPure = false;\r\n    }\r\n\r\n    if (fnString.includes('Date.now')) {\r\n      warnings.push('Transform uses Date.now() - not pure');\r\n      isPure = false;\r\n    }\r\n\r\n    if (fnString.includes('new Date()')) {\r\n      warnings.push('Transform uses new Date() - not pure');\r\n      isPure = false;\r\n    }\r\n\r\n    // Check for closure variables (basic heuristic)\r\n    if (fnString.includes('=>') || fnString.includes('function')) {\r\n      // Check if it references variables outside the function scope\r\n      // This is a simplified check - real analysis would need AST parsing\r\n      const varNames = fnString.match(/(?:const|let|var)\\s+(\\w+)/g);\r\n      if (varNames && varNames.length > 1) {\r\n        warnings.push('Transform may reference external variables - may not be serializable');\r\n        isSerializable = false;\r\n      }\r\n    }\r\n\r\n    // Check for complex logic (multiple statements)\r\n    if (fnString.includes('{') && fnString.includes(';')) {\r\n      warnings.push('Transform has multiple statements - may not be serializable via Babel');\r\n      isSerializable = false;\r\n    }\r\n\r\n    const isValid = warnings.length === 0;\r\n\r\n    return {\r\n      isValid,\r\n      isPure,\r\n      isSerializable,\r\n      warnings\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Pre-register common transforms\r\n */\r\nTransformHandler.registerTransforms({\r\n  // Currency formatting\r\n  'currency-usd': v => `$${Number(v).toFixed(2)}`,\r\n  'currency-eur': v => `€${Number(v).toFixed(2)}`,\r\n  'currency-gbp': v => `£${Number(v).toFixed(2)}`,\r\n\r\n  // Percentage formatting\r\n  'percentage': v => `${(Number(v) * 100).toFixed(0)}%`,\r\n  'percentage-1': v => `${(Number(v) * 100).toFixed(1)}%`,\r\n  'percentage-2': v => `${(Number(v) * 100).toFixed(2)}%`,\r\n\r\n  // String transformations\r\n  'uppercase': v => String(v).toUpperCase(),\r\n  'lowercase': v => String(v).toLowerCase(),\r\n  'capitalize': v => {\r\n    const str = String(v);\r\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\r\n  },\r\n  'trim': v => String(v).trim(),\r\n\r\n  // Number formatting\r\n  'number-0': v => Number(v).toFixed(0),\r\n  'number-1': v => Number(v).toFixed(1),\r\n  'number-2': v => Number(v).toFixed(2),\r\n  'number-comma': v => Number(v).toLocaleString(),\r\n\r\n  // Date formatting (basic - for complex dates, use external library)\r\n  'date-short': v => new Date(v).toLocaleDateString(),\r\n  'date-long': v => new Date(v).toLocaleDateString(undefined, {\r\n    weekday: 'long',\r\n    year: 'numeric',\r\n    month: 'long',\r\n    day: 'numeric'\r\n  }),\r\n  'time-short': v => new Date(v).toLocaleTimeString(),\r\n  'datetime-short': v => new Date(v).toLocaleString(),\r\n\r\n  // Boolean formatting\r\n  'yes-no': v => v ? 'Yes' : 'No',\r\n  'true-false': v => v ? 'True' : 'False',\r\n  'on-off': v => v ? 'On' : 'Off',\r\n  'check-x': v => v ? '✓' : '✗',\r\n  'check-circle': v => v ? '●' : '○',\r\n\r\n  // Array formatting\r\n  'array-length': v => Array.isArray(v) ? v.length.toString() : '0',\r\n  'array-join': v => Array.isArray(v) ? v.join(', ') : '',\r\n  'array-count': v => Array.isArray(v) ? `${v.length} items` : '0 items',\r\n\r\n  // Misc\r\n  'stringify': v => JSON.stringify(v),\r\n  'to-string': v => String(v),\r\n  'empty-dash': v => v ? String(v) : '-',\r\n  'empty-na': v => v ? String(v) : 'N/A'\r\n});\r\n","/**\r\n * Projection Engine\r\n * Applies state projections to DOM elements based on target configuration\r\n */\r\n\r\nimport type {\r\n  TargetProjection,\r\n  ProjectionResult,\r\n  ApplyMode\r\n} from './types';\r\nimport { TransformHandler } from './transform-handler';\r\n\r\n/**\r\n * Projection Engine\r\n * Handles the core logic of transforming state values and applying them to DOM\r\n */\r\nexport class ProjectionEngine {\r\n  /**\r\n   * Apply a state projection to all matching targets within a root element\r\n   *\r\n   * @param rootElement - Component root element to search within\r\n   * @param stateKey - State key (for logging/debugging)\r\n   * @param value - Current state value\r\n   * @param targets - Target projection configuration\r\n   * @param context - Context object for applyIf conditions\r\n   * @returns Array of projection results\r\n   */\r\n  static applyProjections<T>(\r\n    rootElement: HTMLElement,\r\n    stateKey: string,\r\n    value: T,\r\n    targets: Record<string, TargetProjection<T>>,\r\n    context?: any\r\n  ): ProjectionResult[] {\r\n    const results: ProjectionResult[] = [];\r\n\r\n    // Process each target selector\r\n    for (const [selector, config] of Object.entries(targets)) {\r\n      const startTime = performance.now();\r\n\r\n      try {\r\n        // 1. Evaluate applyIf condition (if provided)\r\n        let shouldApply = true;\r\n        let applyIfResult: boolean | undefined = undefined;\r\n\r\n        if (config.applyIf) {\r\n          try {\r\n            applyIfResult = config.applyIf(context);\r\n            shouldApply = applyIfResult;\r\n          } catch (error) {\r\n            console.error(`[useStateX] applyIf error for selector '${selector}':`, error);\r\n            results.push({\r\n              selector,\r\n              applied: false,\r\n              error: error as Error,\r\n              applyIfResult: false,\r\n              latency: performance.now() - startTime\r\n            });\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // 2. Skip if applyIf returned false and skipIfFalse is enabled\r\n        if (!shouldApply && config.skipIfFalse) {\r\n          results.push({\r\n            selector,\r\n            applied: false,\r\n            applyIfResult,\r\n            latency: performance.now() - startTime\r\n          });\r\n          continue;\r\n        }\r\n\r\n        // 3. Query for target element(s)\r\n        const elements = rootElement.querySelectorAll(selector);\r\n\r\n        if (elements.length === 0) {\r\n          console.warn(`[useStateX] No elements found for selector '${selector}'`);\r\n          results.push({\r\n            selector,\r\n            applied: false,\r\n            applyIfResult,\r\n            latency: performance.now() - startTime\r\n          });\r\n          continue;\r\n        }\r\n\r\n        // 4. Transform the value (if shouldApply is true)\r\n        let transformedValue: string | number | boolean | undefined;\r\n\r\n        if (shouldApply) {\r\n          try {\r\n            transformedValue = TransformHandler.applyTransform(config, value);\r\n          } catch (error) {\r\n            console.error(`[useStateX] Transform error for selector '${selector}':`, error);\r\n            results.push({\r\n              selector,\r\n              applied: false,\r\n              error: error as Error,\r\n              applyIfResult,\r\n              latency: performance.now() - startTime\r\n            });\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // 5. Apply to each matching element\r\n        elements.forEach((element) => {\r\n          if (shouldApply && transformedValue !== undefined) {\r\n            this.applyToElement(\r\n              element as HTMLElement,\r\n              transformedValue,\r\n              config.applyAs || 'textContent',\r\n              config.property\r\n            );\r\n          } else {\r\n            // Clear the element if applyIf returned false\r\n            this.clearElement(\r\n              element as HTMLElement,\r\n              config.applyAs || 'textContent',\r\n              config.property\r\n            );\r\n          }\r\n        });\r\n\r\n        // 6. Record success\r\n        results.push({\r\n          selector,\r\n          applied: shouldApply,\r\n          transformedValue: shouldApply ? transformedValue : undefined,\r\n          element: elements[0] as HTMLElement,\r\n          applyIfResult,\r\n          latency: performance.now() - startTime\r\n        });\r\n\r\n      } catch (error) {\r\n        console.error(`[useStateX] Projection error for selector '${selector}':`, error);\r\n        results.push({\r\n          selector,\r\n          applied: false,\r\n          error: error as Error,\r\n          latency: performance.now() - startTime\r\n        });\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Apply transformed value to a single DOM element\r\n   */\r\n  private static applyToElement(\r\n    element: HTMLElement,\r\n    value: string | number | boolean,\r\n    applyAs: ApplyMode,\r\n    property?: string\r\n  ): void {\r\n    switch (applyAs) {\r\n      case 'textContent':\r\n        element.textContent = String(value);\r\n        break;\r\n\r\n      case 'innerHTML':\r\n        // Security warning for innerHTML\r\n        if (typeof value === 'string' && this.containsPotentialXSS(value)) {\r\n          console.warn(\r\n            '[useStateX] Potential XSS detected in innerHTML projection. ' +\r\n            'Ensure value is sanitized.',\r\n            { element, value }\r\n          );\r\n        }\r\n        element.innerHTML = String(value);\r\n        break;\r\n\r\n      case 'attribute':\r\n        if (!property) {\r\n          console.error('[useStateX] property is required for applyAs=\"attribute\"');\r\n          return;\r\n        }\r\n        element.setAttribute(property, String(value));\r\n        break;\r\n\r\n      case 'class':\r\n        if (!property) {\r\n          console.error('[useStateX] property is required for applyAs=\"class\"');\r\n          return;\r\n        }\r\n        // Toggle class based on boolean value\r\n        if (value) {\r\n          element.classList.add(property);\r\n        } else {\r\n          element.classList.remove(property);\r\n        }\r\n        break;\r\n\r\n      case 'style':\r\n        if (!property) {\r\n          console.error('[useStateX] property is required for applyAs=\"style\"');\r\n          return;\r\n        }\r\n        // Set inline style property\r\n        (element.style as any)[property] = String(value);\r\n        break;\r\n\r\n      default:\r\n        console.error(`[useStateX] Unknown applyAs mode: ${applyAs}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear element content/attributes based on applyAs mode\r\n   */\r\n  private static clearElement(\r\n    element: HTMLElement,\r\n    applyAs: ApplyMode,\r\n    property?: string\r\n  ): void {\r\n    switch (applyAs) {\r\n      case 'textContent':\r\n        element.textContent = '';\r\n        break;\r\n\r\n      case 'innerHTML':\r\n        element.innerHTML = '';\r\n        break;\r\n\r\n      case 'attribute':\r\n        if (property) {\r\n          element.removeAttribute(property);\r\n        }\r\n        break;\r\n\r\n      case 'class':\r\n        if (property) {\r\n          element.classList.remove(property);\r\n        }\r\n        break;\r\n\r\n      case 'style':\r\n        if (property) {\r\n          (element.style as any)[property] = '';\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Basic XSS detection (heuristic)\r\n   * For production, use a proper HTML sanitizer like DOMPurify\r\n   */\r\n  private static containsPotentialXSS(html: string): boolean {\r\n    const dangerous = [\r\n      /<script/i,\r\n      /javascript:/i,\r\n      /on\\w+\\s*=/i, // Event handlers like onclick=\r\n      /<iframe/i,\r\n      /<object/i,\r\n      /<embed/i\r\n    ];\r\n\r\n    return dangerous.some(pattern => pattern.test(html));\r\n  }\r\n\r\n  /**\r\n   * Sanitize HTML (basic - recommend using DOMPurify in production)\r\n   */\r\n  static sanitizeHTML(html: string): string {\r\n    // Create a temporary element\r\n    const temp = document.createElement('div');\r\n    temp.textContent = html; // This escapes HTML entities\r\n    return temp.innerHTML;\r\n  }\r\n}\r\n","/**\r\n * Integration Layer\r\n * Connects useStateX with Minimact's ComponentContext\r\n */\r\n\r\nimport type { ComponentContext } from '@minimact/core';\r\nimport type {\r\n  StateXConfig,\r\n  UseStateXReturn,\r\n  SetStateXFunction,\r\n  StateXProjection,\r\n  ProjectionUpdateEvent,\r\n  StateXContext\r\n} from './types';\r\nimport { ProjectionEngine } from './projection-engine';\r\nimport { TransformHandler } from './transform-handler';\r\n\r\n// Extend ComponentContext to include StateX fields\r\ndeclare module '@minimact/core' {\r\n  interface ComponentContext extends StateXContext {\r\n    stateProjections?: Map<string, StateXProjection>;\r\n    dependencyGraph?: any;\r\n    projectionContext?: any;\r\n    stateXDevToolsBridge?: any;\r\n    stateXSyncTimeouts?: Map<string, number>;\r\n  }\r\n}\r\n\r\n// Global context tracking (provided by Minimact core)\r\nlet currentContext: ComponentContext | null = null;\r\nlet stateXIndex = 0;\r\n\r\n/**\r\n * Set the current component context (called by Minimact before render)\r\n * @internal\r\n */\r\nexport function setComponentContext(context: ComponentContext): void {\r\n  currentContext = context;\r\n  stateXIndex = 0;\r\n}\r\n\r\n/**\r\n * Clear the current component context (called by Minimact after render)\r\n * @internal\r\n */\r\nexport function clearComponentContext(): void {\r\n  currentContext = null;\r\n  stateXIndex = 0;\r\n}\r\n\r\n/**\r\n * Get the current component context (for testing)\r\n * @internal\r\n */\r\nexport function getCurrentContext(): ComponentContext | null {\r\n  return currentContext;\r\n}\r\n\r\n/**\r\n * useStateX Hook (Integrated Mode)\r\n *\r\n * Works within Minimact component context with full integration:\r\n * - HintQueue for template patch matching\r\n * - SignalR for server synchronization\r\n * - PlaygroundBridge for DevTools\r\n * - DOMPatcher for surgical updates\r\n *\r\n * @example\r\n * ```tsx\r\n * const [price, setPrice] = useStateX(99, {\r\n *   targets: {\r\n *     '.price-display': {\r\n *       transform: v => `$${v.toFixed(2)}`,\r\n *       applyIf: ctx => ctx.user.canSeePrice\r\n *     }\r\n *   }\r\n * });\r\n * ```\r\n */\r\nexport function useStateX<T>(\r\n  initialValue: T,\r\n  config: StateXConfig<T>\r\n): UseStateXReturn<T> {\r\n  // Ensure we're in a component context\r\n  if (!currentContext) {\r\n    throw new Error(\r\n      '[useStateX] must be called within a component render. ' +\r\n      'Ensure @minimact/x integration is properly set up.'\r\n    );\r\n  }\r\n\r\n  const context = currentContext;\r\n  const index = stateXIndex++;\r\n  const stateKey = `stateX_${index}`;\r\n\r\n  // Initialize stateProjections map if not exists\r\n  if (!context.stateProjections) {\r\n    context.stateProjections = new Map();\r\n  }\r\n\r\n  // Initialize projection metadata if not exists\r\n  if (!context.stateProjections.has(stateKey)) {\r\n    const projection: StateXProjection = {\r\n      stateKey,\r\n      config,\r\n      currentValue: initialValue,\r\n      lastUpdated: Date.now(),\r\n      affectedTargets: Object.keys(config.targets),\r\n      projectionResults: []\r\n    };\r\n\r\n    context.stateProjections.set(stateKey, projection);\r\n\r\n    // Store initial value in underlying state\r\n    if (!context.state) {\r\n      context.state = new Map();\r\n    }\r\n    context.state.set(stateKey, initialValue);\r\n\r\n    // Apply initial projections (if not conditional)\r\n    const projectionContext = config.context ? config.context() : context.projectionContext || {};\r\n    const initialResults = ProjectionEngine.applyProjections(\r\n      context.element,\r\n      stateKey,\r\n      initialValue,\r\n      config.targets,\r\n      projectionContext\r\n    );\r\n\r\n    projection.projectionResults = initialResults;\r\n  }\r\n\r\n  // Get current value\r\n  const currentValue = context.state.get(stateKey) as T;\r\n\r\n  // Create setState function\r\n  const setState: SetStateXFunction<T> = (newValue: T | ((prev: T) => T)) => {\r\n    const startTime = performance.now();\r\n\r\n    // Compute actual new value\r\n    const actualNewValue = typeof newValue === 'function'\r\n      ? (newValue as (prev: T) => T)(context.state.get(stateKey) as T)\r\n      : newValue;\r\n\r\n    // Check if value actually changed (using custom equals or Object.is)\r\n    const equals = config.equals || Object.is;\r\n    const oldValue = context.state.get(stateKey) as T;\r\n\r\n    if (equals(oldValue, actualNewValue)) {\r\n      // Value hasn't changed, skip update\r\n      return;\r\n    }\r\n\r\n    // Update state\r\n    context.state.set(stateKey, actualNewValue);\r\n\r\n    // Get projection context (custom or component context)\r\n    const projectionContext = config.context ? config.context() : context.projectionContext || {};\r\n\r\n    // Apply projections to DOM\r\n    const results = ProjectionEngine.applyProjections(\r\n      context.element,\r\n      stateKey,\r\n      actualNewValue,\r\n      config.targets,\r\n      projectionContext\r\n    );\r\n\r\n    // Update projection metadata\r\n    const projection = context.stateProjections!.get(stateKey)!;\r\n    projection.currentValue = actualNewValue;\r\n    projection.lastUpdated = Date.now();\r\n    projection.projectionResults = results;\r\n\r\n    // Notify DevTools (if bridge exists)\r\n    if (context.stateXDevToolsBridge) {\r\n      results.forEach(result => {\r\n        const event: ProjectionUpdateEvent = {\r\n          componentId: context.componentId,\r\n          stateKey,\r\n          selector: result.selector,\r\n          oldValue,\r\n          newValue: actualNewValue,\r\n          transformedValue: result.transformedValue!,\r\n          applied: result.applied,\r\n          applyIfResult: result.applyIfResult,\r\n          latency: result.latency || 0,\r\n          timestamp: Date.now()\r\n        };\r\n\r\n        context.stateXDevToolsBridge.projectionUpdate(event);\r\n      });\r\n    }\r\n\r\n    // Check hint queue for template patches (if available)\r\n    if (context.hintQueue) {\r\n      const stateChanges: Record<string, any> = {\r\n        [stateKey]: actualNewValue\r\n      };\r\n\r\n      const hint = context.hintQueue.matchHint(context.componentId, stateChanges);\r\n\r\n      if (hint) {\r\n        // Template patch matched! Apply it\r\n        const latency = performance.now() - startTime;\r\n        console.log(\r\n          `[useStateX] 🟢 Template patch matched! Hint '${hint.hintId}' - ` +\r\n          `applying ${hint.patches.length} patches in ${latency.toFixed(2)}ms`\r\n        );\r\n\r\n        if (context.domPatcher) {\r\n          context.domPatcher.applyPatches(context.element, hint.patches);\r\n        }\r\n\r\n        // Notify playground\r\n        if (context.playgroundBridge) {\r\n          context.playgroundBridge.cacheHit({\r\n            componentId: context.componentId,\r\n            hintId: hint.hintId,\r\n            latency,\r\n            confidence: hint.confidence,\r\n            patchCount: hint.patches.length\r\n          });\r\n        }\r\n      } else {\r\n        // Cache miss\r\n        if (context.playgroundBridge) {\r\n          context.playgroundBridge.cacheMiss({\r\n            componentId: context.componentId,\r\n            methodName: `useStateX(${stateKey})`,\r\n            latency: performance.now() - startTime,\r\n            patchCount: 0\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Sync to server (based on sync strategy)\r\n    const syncStrategy = config.sync || 'immediate';\r\n\r\n    if (syncStrategy === 'immediate') {\r\n      // Immediate sync\r\n      if (context.signalR) {\r\n        context.signalR.invoke('UpdateComponentState', {\r\n          componentId: context.componentId,\r\n          stateKey,\r\n          value: actualNewValue\r\n        }).catch((err: Error) => {\r\n          console.error('[useStateX] Failed to sync state to server:', err);\r\n        });\r\n      }\r\n    } else if (syncStrategy === 'debounced') {\r\n      // Debounced sync\r\n      const delay = config.syncDelay || 300;\r\n\r\n      // Initialize timeouts map if not exists\r\n      if (!context.stateXSyncTimeouts) {\r\n        context.stateXSyncTimeouts = new Map();\r\n      }\r\n\r\n      // Clear previous timeout\r\n      const existingTimeout = context.stateXSyncTimeouts.get(stateKey);\r\n      if (existingTimeout) {\r\n        clearTimeout(existingTimeout);\r\n      }\r\n\r\n      // Set new timeout\r\n      const timeoutId = window.setTimeout(() => {\r\n        if (context.signalR) {\r\n          context.signalR.invoke('UpdateComponentState', {\r\n            componentId: context.componentId,\r\n            stateKey,\r\n            value: actualNewValue\r\n          }).catch((err: Error) => {\r\n            console.error('[useStateX] Failed to sync state to server:', err);\r\n          });\r\n        }\r\n        context.stateXSyncTimeouts!.delete(stateKey);\r\n      }, delay);\r\n\r\n      context.stateXSyncTimeouts.set(stateKey, timeoutId);\r\n    }\r\n    // 'manual' strategy: Developer calls syncStateToServer manually\r\n  };\r\n\r\n  return [currentValue, setState];\r\n}\r\n\r\n/**\r\n * Manually sync state to server (for sync: 'manual' strategy)\r\n *\r\n * @param stateKey - State key to sync (optional, syncs all if not provided)\r\n */\r\nexport function syncStateToServer(stateKey?: string): void {\r\n  if (!currentContext) {\r\n    throw new Error('[useStateX] No active component context');\r\n  }\r\n\r\n  if (!currentContext.signalR) {\r\n    console.warn('[useStateX] SignalR not available, cannot sync to server');\r\n    return;\r\n  }\r\n\r\n  const context = currentContext;\r\n\r\n  if (stateKey) {\r\n    // Sync specific state\r\n    const value = context.state.get(stateKey);\r\n    if (value !== undefined) {\r\n      context.signalR.invoke('UpdateComponentState', {\r\n        componentId: context.componentId,\r\n        stateKey,\r\n        value\r\n      }).catch((err: Error) => {\r\n        console.error(`[useStateX] Failed to sync state '${stateKey}' to server:`, err);\r\n      });\r\n    }\r\n  } else {\r\n    // Sync all stateX states\r\n    if (context.stateProjections) {\r\n      context.stateProjections.forEach((projection: StateXProjection, key: string) => {\r\n        const value = context.state.get(key);\r\n        if (value !== undefined) {\r\n          context.signalR.invoke('UpdateComponentState', {\r\n            componentId: context.componentId,\r\n            stateKey: key,\r\n            value\r\n          }).catch((err: Error) => {\r\n            console.error(`[useStateX] Failed to sync state '${key}' to server:`, err);\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Cleanup all state projections for a component\r\n * Called by Minimact on component unmount\r\n * @internal\r\n */\r\nexport function cleanupStateProjections(context: ComponentContext): void {\r\n  // Clear any pending sync timeouts\r\n  if (context.stateXSyncTimeouts) {\r\n    context.stateXSyncTimeouts.forEach((timeoutId: number) => {\r\n      clearTimeout(timeoutId);\r\n    });\r\n    context.stateXSyncTimeouts.clear();\r\n  }\r\n\r\n  // Clear projection metadata\r\n  if (context.stateProjections) {\r\n    context.stateProjections.clear();\r\n  }\r\n}\r\n","/**\r\n * useStateX Hook\r\n * CSS for State Logic - Declarative state projection system\r\n */\r\n\r\nimport type {\r\n  StateXConfig,\r\n  UseStateXReturn,\r\n  SetStateXFunction,\r\n  StateXProjection,\r\n  ProjectionUpdateEvent\r\n} from './types';\r\nimport { ProjectionEngine } from './projection-engine';\r\n\r\n// Will be provided by integration layer\r\nlet currentContext: any = null;\r\nlet stateXIndex = 0;\r\n\r\n/**\r\n * Set the current component context (called by integration layer)\r\n * @internal\r\n */\r\nexport function setComponentContext(context: any): void {\r\n  currentContext = context;\r\n  stateXIndex = 0;\r\n}\r\n\r\n/**\r\n * Clear the current component context (called by integration layer)\r\n * @internal\r\n */\r\nexport function clearComponentContext(): void {\r\n  currentContext = null;\r\n  stateXIndex = 0;\r\n}\r\n\r\n/**\r\n * Get the current component context (for testing)\r\n * @internal\r\n */\r\nexport function getCurrentContext(): any {\r\n  return currentContext;\r\n}\r\n\r\n/**\r\n * useStateX Hook\r\n *\r\n * Declarative state management with automatic DOM projection\r\n *\r\n * @example\r\n * ```tsx\r\n * const [price, setPrice] = useStateX(99, {\r\n *   targets: {\r\n *     '.price-display': {\r\n *       transform: v => `$${v.toFixed(2)}`,\r\n *       applyIf: ctx => ctx.user.canSeePrice\r\n *     }\r\n *   }\r\n * });\r\n * ```\r\n *\r\n * @param initialValue - Initial state value\r\n * @param config - State projection configuration\r\n * @returns Tuple of [currentValue, setState]\r\n */\r\nexport function useStateX<T>(\r\n  initialValue: T,\r\n  config: StateXConfig<T>\r\n): UseStateXReturn<T> {\r\n  // Ensure we're in a component context\r\n  if (!currentContext) {\r\n    throw new Error(\r\n      '[useStateX] must be called within a component render. ' +\r\n      'Ensure minimact-x integration is properly set up.'\r\n    );\r\n  }\r\n\r\n  const context = currentContext;\r\n  const index = stateXIndex++;\r\n  const stateKey = `stateX_${index}`;\r\n\r\n  // Initialize stateProjections map if not exists\r\n  if (!context.stateProjections) {\r\n    context.stateProjections = new Map();\r\n  }\r\n\r\n  // Initialize projection metadata if not exists\r\n  if (!context.stateProjections.has(stateKey)) {\r\n    const projection: StateXProjection = {\r\n      stateKey,\r\n      config,\r\n      currentValue: initialValue,\r\n      lastUpdated: Date.now(),\r\n      affectedTargets: Object.keys(config.targets),\r\n      projectionResults: []\r\n    };\r\n\r\n    context.stateProjections.set(stateKey, projection);\r\n\r\n    // Store initial value in underlying state\r\n    if (!context.state) {\r\n      context.state = new Map();\r\n    }\r\n    context.state.set(stateKey, initialValue);\r\n  }\r\n\r\n  // Get current value\r\n  const currentValue = context.state.get(stateKey) as T;\r\n\r\n  // Create setState function\r\n  const setState: SetStateXFunction<T> = (newValue: T | ((prev: T) => T)) => {\r\n    const startTime = performance.now();\r\n\r\n    // Compute actual new value\r\n    const actualNewValue = typeof newValue === 'function'\r\n      ? (newValue as (prev: T) => T)(context.state.get(stateKey) as T)\r\n      : newValue;\r\n\r\n    // Check if value actually changed (using custom equals or Object.is)\r\n    const equals = config.equals || Object.is;\r\n    const oldValue = context.state.get(stateKey) as T;\r\n\r\n    if (equals(oldValue, actualNewValue)) {\r\n      // Value hasn't changed, skip update\r\n      return;\r\n    }\r\n\r\n    // Update state\r\n    context.state.set(stateKey, actualNewValue);\r\n\r\n    // Get projection context (custom or component context)\r\n    const projectionContext = config.context ? config.context() : context.projectionContext || {};\r\n\r\n    // Apply projections to DOM\r\n    const results = ProjectionEngine.applyProjections(\r\n      context.element,\r\n      stateKey,\r\n      actualNewValue,\r\n      config.targets,\r\n      projectionContext\r\n    );\r\n\r\n    // Update projection metadata\r\n    const projection = context.stateProjections.get(stateKey)!;\r\n    projection.currentValue = actualNewValue;\r\n    projection.lastUpdated = Date.now();\r\n    projection.projectionResults = results;\r\n\r\n    // Notify DevTools (if bridge exists)\r\n    if (context.stateXDevToolsBridge) {\r\n      results.forEach(result => {\r\n        const event: ProjectionUpdateEvent = {\r\n          componentId: context.componentId,\r\n          stateKey,\r\n          selector: result.selector,\r\n          oldValue,\r\n          newValue: actualNewValue,\r\n          transformedValue: result.transformedValue!,\r\n          applied: result.applied,\r\n          applyIfResult: result.applyIfResult,\r\n          latency: result.latency || 0,\r\n          timestamp: Date.now()\r\n        };\r\n\r\n        context.stateXDevToolsBridge.projectionUpdate(event);\r\n      });\r\n    }\r\n\r\n    // Check hint queue for template patches (if available)\r\n    if (context.hintQueue) {\r\n      const stateChanges: Record<string, any> = {\r\n        [stateKey]: actualNewValue\r\n      };\r\n\r\n      const hint = context.hintQueue.matchHint(context.componentId, stateChanges);\r\n\r\n      if (hint) {\r\n        // Template patch matched! Apply it\r\n        const latency = performance.now() - startTime;\r\n        console.log(\r\n          `[useStateX] 🟢 Template patch matched! Hint '${hint.hintId}' - ` +\r\n          `applying ${hint.patches.length} patches in ${latency.toFixed(2)}ms`\r\n        );\r\n\r\n        context.domPatcher?.applyPatches(context.element, hint.patches);\r\n\r\n        // Notify playground\r\n        if (context.playgroundBridge) {\r\n          context.playgroundBridge.cacheHit({\r\n            componentId: context.componentId,\r\n            hintId: hint.hintId,\r\n            latency,\r\n            confidence: hint.confidence,\r\n            patchCount: hint.patches.length\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Sync to server (based on sync strategy)\r\n    const syncStrategy = config.sync || 'immediate';\r\n\r\n    if (syncStrategy === 'immediate') {\r\n      // Immediate sync\r\n      if (context.signalR) {\r\n        context.signalR.updateComponentState(context.componentId, stateKey, actualNewValue)\r\n          .catch((err: Error) => {\r\n            console.error('[useStateX] Failed to sync state to server:', err);\r\n          });\r\n      }\r\n    } else if (syncStrategy === 'debounced') {\r\n      // Debounced sync\r\n      const delay = config.syncDelay || 300;\r\n\r\n      // Clear previous timeout\r\n      if (!context.stateXSyncTimeouts) {\r\n        context.stateXSyncTimeouts = new Map();\r\n      }\r\n\r\n      const existingTimeout = context.stateXSyncTimeouts.get(stateKey);\r\n      if (existingTimeout) {\r\n        clearTimeout(existingTimeout);\r\n      }\r\n\r\n      // Set new timeout\r\n      const timeoutId = setTimeout(() => {\r\n        if (context.signalR) {\r\n          context.signalR.updateComponentState(context.componentId, stateKey, actualNewValue)\r\n            .catch((err: Error) => {\r\n              console.error('[useStateX] Failed to sync state to server:', err);\r\n            });\r\n        }\r\n        context.stateXSyncTimeouts.delete(stateKey);\r\n      }, delay);\r\n\r\n      context.stateXSyncTimeouts.set(stateKey, timeoutId);\r\n    }\r\n    // 'manual' strategy: Developer calls sync manually\r\n  };\r\n\r\n  return [currentValue, setState];\r\n}\r\n\r\n/**\r\n * Manually sync state to server (for sync: 'manual' strategy)\r\n *\r\n * @param stateKey - State key to sync (optional, syncs all if not provided)\r\n */\r\nexport function syncStateToServer(stateKey?: string): void {\r\n  if (!currentContext) {\r\n    throw new Error('[useStateX] No active component context');\r\n  }\r\n\r\n  if (!currentContext.signalR) {\r\n    console.warn('[useStateX] SignalR not available, cannot sync to server');\r\n    return;\r\n  }\r\n\r\n  const context = currentContext;\r\n\r\n  if (stateKey) {\r\n    // Sync specific state\r\n    const value = context.state.get(stateKey);\r\n    if (value !== undefined) {\r\n      context.signalR.updateComponentState(context.componentId, stateKey, value)\r\n        .catch((err: Error) => {\r\n          console.error(`[useStateX] Failed to sync state '${stateKey}' to server:`, err);\r\n        });\r\n    }\r\n  } else {\r\n    // Sync all stateX states\r\n    if (context.stateProjections) {\r\n      context.stateProjections.forEach((projection: StateXProjection, key: string) => {\r\n        const value = context.state.get(key);\r\n        if (value !== undefined) {\r\n          context.signalR.updateComponentState(context.componentId, key, value)\r\n            .catch((err: Error) => {\r\n              console.error(`[useStateX] Failed to sync state '${key}' to server:`, err);\r\n            });\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Cleanup all state projections for a component\r\n * @internal\r\n */\r\nexport function cleanupStateProjections(context: any): void {\r\n  // Clear any pending sync timeouts\r\n  if (context.stateXSyncTimeouts) {\r\n    context.stateXSyncTimeouts.forEach((timeoutId: number) => {\r\n      clearTimeout(timeoutId);\r\n    });\r\n    context.stateXSyncTimeouts.clear();\r\n  }\r\n\r\n  // Clear projection metadata\r\n  if (context.stateProjections) {\r\n    context.stateProjections.clear();\r\n  }\r\n}\r\n","/**\r\n * Minimact X 🌵 + ✨\r\n *\r\n * CSS for State Logic - Declarative state projection addon for Minimact\r\n *\r\n * **Core Philosophy:**\r\n * Just as CSS externalizes styling from HTML, useStateX externalizes\r\n * state-to-DOM bindings from JSX. This enables build-time analysis,\r\n * predictive rendering, and superior developer experience.\r\n *\r\n * @packageDocumentation\r\n */\r\n\r\n// ============================================================\r\n// CORE HOOK (Integrated Mode - DEFAULT)\r\n// ============================================================\r\n\r\n/**\r\n * Main hook - declarative state with DOM projection\r\n * Integrated with Minimact's ComponentContext for full features\r\n *\r\n * @example\r\n * ```tsx\r\n * const [price, setPrice] = useStateX(99, {\r\n *   targets: {\r\n *     '.price-display': {\r\n *       transform: v => `$${v.toFixed(2)}`,\r\n *       applyIf: ctx => ctx.user.canSeePrice\r\n *     }\r\n *   }\r\n * });\r\n * ```\r\n */\r\nexport {\r\n  useStateX,\r\n  syncStateToServer,\r\n  setComponentContext,\r\n  clearComponentContext,\r\n  getCurrentContext,\r\n  cleanupStateProjections\r\n} from './integration';\r\n\r\n/**\r\n * Standalone mode (no Minimact integration)\r\n * For testing or use outside of Minimact components\r\n * @deprecated Use integrated mode for production\r\n */\r\nexport {\r\n  useStateX as useStateXStandalone,\r\n  syncStateToServer as syncStateToServerStandalone\r\n} from './use-state-x';\r\n\r\n// ============================================================\r\n// TRANSFORM HANDLING\r\n// ============================================================\r\n\r\n/**\r\n * Transform registry and handler\r\n * Register reusable transforms globally\r\n *\r\n * @example\r\n * ```typescript\r\n * TransformHandler.registerTransform('currency-usd', v => `$${v.toFixed(2)}`);\r\n * ```\r\n */\r\nexport { TransformHandler } from './transform-handler';\r\n\r\n/**\r\n * Projection engine (advanced usage)\r\n * Direct DOM projection without hook\r\n */\r\nexport { ProjectionEngine } from './projection-engine';\r\n\r\n// ============================================================\r\n// TYPE DEFINITIONS\r\n// ============================================================\r\n\r\n/**\r\n * All TypeScript types and interfaces\r\n */\r\nexport type {\r\n  // Configuration types\r\n  StateXConfig,\r\n  TargetProjection,\r\n  ApplyMode,\r\n  SyncStrategy,\r\n\r\n  // Function types\r\n  SetStateXFunction,\r\n  UseStateXReturn,\r\n  TransformFunction,\r\n\r\n  // Registry types\r\n  TransformRegistryEntry,\r\n\r\n  // Result types\r\n  ProjectionResult,\r\n  StateXProjection,\r\n\r\n  // Dependency graph types\r\n  StateXDependencyGraph,\r\n  DependencyMetadata,\r\n\r\n  // Context extension\r\n  StateXContext,\r\n\r\n  // DevTools types\r\n  StateXDevToolsBridge,\r\n  ProjectionUpdateEvent,\r\n  TransformErrorEvent,\r\n\r\n  // Misc\r\n  ManualSyncOptions\r\n} from './types';\r\n\r\n// ============================================================\r\n// VERSION & METADATA\r\n// ============================================================\r\n\r\nexport const VERSION = '0.1.0';\r\nexport const MES_CERTIFICATION = 'Gold'; // Minimact Extension Standards\r\n\r\n/**\r\n * Package metadata for debugging\r\n */\r\nexport const PACKAGE_INFO = {\r\n  name: 'minimact-x',\r\n  version: VERSION,\r\n  certification: MES_CERTIFICATION,\r\n  features: [\r\n    'Declarative state projections',\r\n    'CSS-like selector targeting',\r\n    'Pure transform functions',\r\n    'Conditional rendering (applyIf)',\r\n    'Template Patch System integration',\r\n    'Server synchronization (immediate/debounced/manual)',\r\n    'Transform registry (reusable transforms)',\r\n    'DevTools integration',\r\n    'Babel static analysis support',\r\n    'XSS protection',\r\n    'Dependency graph tracking',\r\n    'MES Gold certified'\r\n  ],\r\n  philosophy: 'CSS for State Logic - Predictive Declarative UI Architecture'\r\n} as const;\r\n\r\n/**\r\n * Quick start helper - register common transforms\r\n *\r\n * @example\r\n * ```typescript\r\n * import { setupMinimactX } from '@minimact/x';\r\n *\r\n * // Automatically registers all built-in transforms\r\n * setupMinimactX();\r\n * ```\r\n */\r\nexport function setupMinimactX(): void {\r\n  console.log(\r\n    `[Minimact X] v${VERSION} initialized ✨\\n` +\r\n    `MES Certification: ${MES_CERTIFICATION}\\n` +\r\n    `Philosophy: ${PACKAGE_INFO.philosophy}`\r\n  );\r\n\r\n  // Transforms are auto-registered in TransformHandler\r\n  // This function is just for explicit initialization\r\n}\r\n"],"names":["useStateX","syncStateToServer"],"mappings":"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"}