var Minimact=function(e){"use strict";var t,n;!function(e){e.Disconnected="Disconnected",e.Connecting="Connecting",e.Connected="Connected",e.Reconnecting="Reconnecting"}(t||(t={})),function(e){e[e.Invocation=1]="Invocation",e[e.StreamItem=2]="StreamItem",e[e.Completion=3]="Completion",e[e.StreamInvocation=4]="StreamInvocation",e[e.CancelInvocation=5]="CancelInvocation",e[e.Ping=6]="Ping",e[e.Close=7]="Close"}(n||(n={}));class o{constructor(){this.delays=[0,2e3,1e4,3e4],this.maxDelay=6e4}nextRetryDelay(e){return e<this.delays.length?this.delays[e]:this.maxDelay}}class s{static writeHandshake(){const e={protocol:this.protocolName,version:this.protocolVersion};return JSON.stringify(e)+this.RECORD_SEPARATOR}static parseHandshake(e){try{const t=e.endsWith(this.RECORD_SEPARATOR)?e.slice(0,-1):e;return JSON.parse(t)}catch(e){throw new Error(`Failed to parse handshake: ${e}`)}}static writeInvocation(e,t,n){return{type:1,invocationId:e,target:t,arguments:n}}static writeMessage(e,t){return{type:1,target:e,arguments:t}}static writePing(){return{type:6}}static writeClose(e){return{type:7,error:e}}static parseMessage(e){try{const t=e.endsWith(this.RECORD_SEPARATOR)?e.slice(0,-1):e;return JSON.parse(t)}catch(e){throw new Error(`Failed to parse message: ${e}`)}}static serializeMessage(e){return JSON.stringify(e)+this.RECORD_SEPARATOR}static isInvocation(e){return 1===e.type}static isCompletion(e){return 3===e.type}static isPing(e){return 6===e.type}static isClose(e){return 7===e.type}}s.protocolName="json",s.protocolVersion=1,s.RECORD_SEPARATOR="";class i{constructor(){this.events=new Map}on(e,t){this.events.has(e)||this.events.set(e,[]),this.events.get(e).push(t)}off(e,t){const n=this.events.get(e);if(n){const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}once(e,t){const n=(...o)=>{t(...o),this.off(e,n)};this.on(e,n)}emit(e,...t){const n=this.events.get(e);n&&[...n].forEach(n=>{try{n(...t)}catch(t){console.error(`[SignalM] Error in event handler for '${e}':`,t)}})}removeAllListeners(e){e?this.events.delete(e):this.events.clear()}listenerCount(e){const t=this.events.get(e);return t?t.length:0}eventNames(){return Array.from(this.events.keys())}}class r{constructor(e,n={}){this.ws=null,this.handlers=new Map,this.pendingInvocations=new Map,this.invocationId=0,this.state=t.Disconnected,this.reconnectAttempts=0,this.reconnectTimeoutId=null,this.url=e,this.reconnectPolicy=n.reconnectPolicy||new o,this.debugLogging=n.debug||!1,this.connectionTimeout=n.connectionTimeout||3e4,this.invocationTimeout=n.invocationTimeout||3e4,this.eventEmitter=new i}async start(){if(this.state!==t.Disconnected)throw new Error("Connection is already started");return this.state=t.Connecting,this.log("Starting connection..."),this.connect()}async stop(){this.log("Stopping connection..."),null!==this.reconnectTimeoutId&&(clearTimeout(this.reconnectTimeoutId),this.reconnectTimeoutId=null),this.ws&&(this.ws.close(1e3,"Normal closure"),this.ws=null),this.state=t.Disconnected,this.eventEmitter.emit("disconnected")}async invoke(e,...n){if(this.state!==t.Connected)throw new Error(`Connection is not in Connected state (current: ${this.state})`);const o=this.generateInvocationId(),i=s.writeInvocation(o,e,n);return new Promise((t,r)=>{const a=setTimeout(()=>{this.pendingInvocations.delete(o),r(new Error(`Invocation '${e}' timed out after ${this.invocationTimeout}ms`))},this.invocationTimeout);this.pendingInvocations.set(o,{resolve:t,reject:r,timeout:a});const c=s.serializeMessage(i);this.log(`Invoking '${e}' (id: ${o})`,n),this.ws.send(c)})}send(e,...n){if(this.state!==t.Connected)throw new Error(`Connection is not in Connected state (current: ${this.state})`);const o=s.writeMessage(e,n),i=s.serializeMessage(o);this.log(`Sending '${e}' (fire-and-forget)`,n),this.ws.send(i)}on(e,t){this.handlers.has(e)||this.handlers.set(e,[]),this.handlers.get(e).push(t),this.log(`Registered handler for '${e}'`)}off(e,t){const n=this.handlers.get(e);if(n){const o=n.indexOf(t);-1!==o&&(n.splice(o,1),this.log(`Removed handler for '${e}'`))}}onConnected(e){this.eventEmitter.on("connected",e)}onDisconnected(e){this.eventEmitter.on("disconnected",e)}onReconnecting(e){this.eventEmitter.on("reconnecting",e)}onReconnected(e){this.eventEmitter.on("reconnected",e)}onError(e){this.eventEmitter.on("error",e)}get connectionState(){return this.state}async connect(){return new Promise((e,n)=>{const o=this.buildWebSocketUrl();this.log(`Connecting to ${o}...`);try{this.ws=new WebSocket(o)}catch(e){return void n(e)}const i=setTimeout(()=>{this.state===t.Connecting&&(this.log("Connection timeout"),this.ws?.close(),n(new Error(`Connection timeout after ${this.connectionTimeout}ms`)))},this.connectionTimeout);let r=!1;this.ws.onopen=()=>{const e=s.writeHandshake();this.log("Sending handshake",e),this.ws.send(e)},this.ws.onmessage=o=>{if(r)this.handleMessage(o.data);else try{const a=s.parseHandshake(o.data);if(a.error)return clearTimeout(i),this.log("Handshake failed",a.error),this.ws?.close(),void n(new Error(`Handshake failed: ${a.error}`));r=!0,clearTimeout(i),this.state=t.Connected,this.reconnectAttempts=0,this.log("Handshake complete ‚úì"),this.log("Connected ‚úì"),this.eventEmitter.emit("connected"),e()}catch(e){clearTimeout(i),this.log("Handshake parse error",e),this.ws?.close(),n(new Error(`Handshake error: ${e}`))}},this.ws.onerror=e=>{this.log("WebSocket error",e),this.eventEmitter.emit("error",new Error("WebSocket error"))},this.ws.onclose=e=>{clearTimeout(i),this.handleClose(e)}})}handleMessage(e){const t=e.split("").filter(e=>e.length>0);for(const e of t)try{const t=JSON.parse(e);this.log(`Received message (type: ${t.type})`,t),s.isInvocation(t)?this.handleInvocation(t):s.isCompletion(t)?this.handleCompletion(t):s.isPing(t)?this.handlePing():s.isClose(t)&&(this.log("Server requested close",t.error),this.ws?.close(1e3,"Server closed connection"))}catch(e){this.log("Error parsing message",e),console.error("[SignalM] Error parsing message:",e)}}handleInvocation(e){const t=this.handlers.get(e.target);t?(this.log(`Calling ${t.length} handler(s) for '${e.target}'`),t.forEach(t=>{try{t(...e.arguments||[])}catch(t){console.error(`[SignalM] Error in handler for '${e.target}':`,t)}})):this.log(`No handler registered for '${e.target}'`)}handleCompletion(e){const t=this.pendingInvocations.get(e.invocationId);t?(clearTimeout(t.timeout),this.pendingInvocations.delete(e.invocationId),e.error?(this.log(`Invocation ${e.invocationId} failed: ${e.error}`),t.reject(new Error(e.error))):(this.log(`Invocation ${e.invocationId} completed`,e.result),t.resolve(e.result))):this.log(`Received completion for unknown invocation ${e.invocationId}`)}handlePing(){const e=s.writePing(),t=s.serializeMessage(e);this.log("Received ping, sending pong"),this.ws?.send(t)}handleClose(e){this.log(`Connection closed (code: ${e.code}, reason: ${e.reason})`),this.state=t.Disconnected,this.ws=null,this.pendingInvocations.forEach(e=>{clearTimeout(e.timeout),e.reject(new Error("Connection closed"))}),this.pendingInvocations.clear(),1e3!==e.code&&1001!==e.code?this.attemptReconnect():this.eventEmitter.emit("disconnected")}async attemptReconnect(){const e=this.reconnectPolicy.nextRetryDelay(this.reconnectAttempts);if(null===e)return this.log("Max reconnection attempts exceeded"),void this.eventEmitter.emit("disconnected");this.reconnectAttempts++,this.state=t.Reconnecting,this.log(`Reconnecting in ${e}ms (attempt ${this.reconnectAttempts})...`),this.eventEmitter.emit("reconnecting"),this.reconnectTimeoutId=setTimeout(async()=>{this.reconnectTimeoutId=null;try{await this.connect(),this.log("Reconnected ‚úì"),this.eventEmitter.emit("reconnected")}catch(e){this.log("Reconnection failed",e),this.attemptReconnect()}},e)}buildWebSocketUrl(){if(this.url.startsWith("ws://")||this.url.startsWith("wss://"))return this.url;const e="https:"===window.location.protocol?"wss:":"ws:";return this.url.startsWith("/")?`${e}//${window.location.host}${this.url}`:`${e}//${window.location.host}/${this.url}`}generateInvocationId(){return(++this.invocationId).toString()}log(e,t){this.debugLogging&&(void 0!==t?console.log(`[SignalM] ${e}`,t):console.log(`[SignalM] ${e}`))}}class a{constructor(e="/minimact",t={}){this.debugLogging=t.debugLogging||!1,this.eventHandlers=new Map,this.connection=new r(e,{debug:this.debugLogging}),this.setupEventHandlers()}setupEventHandlers(){this.connection.on("UpdateComponent",(e,t)=>{this.log("UpdateComponent",{componentId:e,html:t}),this.emit("updateComponent",{componentId:e,html:t})}),this.connection.on("ApplyPatches",(e,t)=>{this.log("ApplyPatches",{componentId:e,patches:t}),this.emit("applyPatches",{componentId:e,patches:t})}),this.connection.on("ApplyPrediction",e=>{this.log(`ApplyPrediction (${(100*e.confidence).toFixed(0)}% confident)`,{componentId:e.componentId,patches:e.patches}),this.emit("applyPrediction",{componentId:e.componentId,patches:e.patches,confidence:e.confidence})}),this.connection.on("ApplyCorrection",e=>{this.log("ApplyCorrection (prediction was incorrect)",{componentId:e.componentId,patches:e.patches}),this.emit("applyCorrection",{componentId:e.componentId,patches:e.patches})}),this.connection.on("QueueHint",e=>{this.log(`QueueHint '${e.hintId}' (${(100*e.confidence).toFixed(0)}% confident)`,{componentId:e.componentId,patches:e.patches}),this.emit("queueHint",e)}),this.connection.on("Error",e=>{console.error("[Minimact] Server error:",e),this.emit("error",{message:e})}),this.connection.on("HotReload:TemplateMap",e=>{this.log("HotReload:TemplateMap",e),this.emit("HotReload:TemplateMap",e)}),this.connection.on("HotReload:TemplatePatch",e=>{this.log("HotReload:TemplatePatch",e),this.emit("HotReload:TemplatePatch",e)}),this.connection.on("HotReload:FileChange",e=>{this.log("HotReload:FileChange",e),this.emit("HotReload:FileChange",e)}),this.connection.on("HotReload:Error",e=>{console.error("[Minimact Hot Reload] Error:",e.error),this.emit("HotReload:Error",e)}),this.connection.onReconnecting(()=>{this.log("Reconnecting..."),this.emit("reconnecting",{})}),this.connection.onReconnected(()=>{this.log("Reconnected"),this.emit("reconnected",{connectionId:null})}),this.connection.onDisconnected(()=>{this.log("Connection closed"),this.emit("closed",{})}),this.connection.onConnected(()=>{this.log("Connected to Minimact hub"),this.emit("connected",{connectionId:null})})}async start(){try{await this.connection.start()}catch(e){throw console.error("[Minimact] Failed to connect:",e),e}}async stop(){await this.connection.stop(),this.log("Disconnected from Minimact hub")}async registerComponent(e){try{await this.connection.invoke("RegisterComponent",e),this.log("Registered component",{componentId:e})}catch(e){throw console.error("[Minimact] Failed to register component:",e),e}}async invokeComponentMethod(e,t,n={}){try{const o=JSON.stringify(n);await this.connection.invoke("InvokeComponentMethod",e,t,o),this.log("Invoked method",{componentId:e,methodName:t,args:n})}catch(e){throw console.error("[Minimact] Failed to invoke method:",e),e}}async updateClientState(e,t,n){try{const o=JSON.stringify(n);await this.connection.invoke("UpdateClientState",e,t,o),this.log("Updated client state",{componentId:e,key:t,value:n})}catch(e){console.error("[Minimact] Failed to update client state:",e)}}async updateClientComputedState(e,t){try{await this.connection.invoke("UpdateClientComputedState",e,t),this.log("Updated client-computed state",{componentId:e,computedValues:t})}catch(e){throw console.error("[Minimact] Failed to update client-computed state:",e),e}}async updateComponentState(e,t,n){try{await this.connection.invoke("UpdateComponentState",e,t,n),this.log("Updated component state",{componentId:e,stateKey:t,value:n})}catch(e){throw console.error("[Minimact] Failed to update component state:",e),e}}async updateDomElementState(e,t,n){try{await this.connection.invoke("UpdateDomElementState",e,t,n),this.log("Updated DOM element state",{componentId:e,stateKey:t,snapshot:n})}catch(e){throw console.error("[Minimact] Failed to update DOM element state:",e),e}}async updateComponentStateWithOperation(e,t,n,o){try{await this.connection.invoke("UpdateComponentStateWithOperation",e,t,n,o),this.log("Updated component state with operation",{componentId:e,stateKey:t,operation:o,newValue:n})}catch(e){throw console.error("[Minimact] Failed to update component state with operation:",e),e}}async updateQueryResults(e,t,n){try{await this.connection.invoke("UpdateQueryResults",e,t,n),this.log("Updated query results",{componentId:e,queryKey:t,resultCount:n.length})}catch(e){throw console.error("[Minimact] Failed to update query results:",e),e}}async invoke(e,...t){try{await this.connection.invoke(e,...t),this.log(`Invoked ${e}`,{args:t})}catch(t){throw console.error(`[Minimact] Failed to invoke ${e}:`,t),t}}on(e,t){this.eventHandlers.has(e)||this.eventHandlers.set(e,new Set),this.eventHandlers.get(e).add(t)}off(e,t){const n=this.eventHandlers.get(e);n&&n.delete(t)}emit(e,t){const n=this.eventHandlers.get(e);n&&n.forEach(e=>e(t))}log(e,t){this.debugLogging&&console.log(`[Minimact SignalM] ${e}`,t||"")}get state(){return this.connection.connectionState}get connectionId(){return null}}class c{constructor(e={}){this.debugLogging=e.debugLogging||!1}applyPatches(e,t){this.log("Applying patches",{count:t.length,patches:t});for(const n of t)try{this.applyPatch(e,n)}catch(e){console.error("[Minimact] Failed to apply patch:",n,e)}}applyPatch(e,t){const n=this.getElementByPath(e,t.path);if(n||"Create"===t.type)switch(t.type){case"Create":this.patchCreate(e,t.path,t.node);break;case"Remove":this.patchRemove(n);break;case"Replace":this.patchReplace(n,t.node);break;case"UpdateText":this.patchUpdateText(n,t.content);break;case"UpdateProps":this.patchUpdateProps(n,t.props);break;case"ReorderChildren":this.patchReorderChildren(n,t.order)}else console.warn("[Minimact] Target element not found for patch:",t)}patchCreate(e,t,n){const o=this.createElementFromVNode(n),s=n.path;if(!s)return void console.error("[DOMPatcher] Node has no path for Create");const i=s.split(".").map(e=>parseInt(e,10));if(0===i.length)return void console.error("[DOMPatcher] Invalid empty path for Create");if(1===i.length&&0===i[0])return e.innerHTML="",e.appendChild(o),void this.log("Created root node",{node:n});const r=i.slice(0,-1),a=i[i.length-1],c=this.getElementByPath(e,r);c?(a>=c.childNodes.length?c.appendChild(o):c.insertBefore(o,c.childNodes[a]),this.log("Created node",{path:s,node:n})):console.error("[DOMPatcher] Parent not found for Create at path:",s)}patchRemove(e){e.parentNode&&(e.parentNode.removeChild(e),this.log("Removed node",{element:e}))}patchReplace(e,t){const n=this.createElementFromVNode(t);e.parentNode&&(e.parentNode.replaceChild(n,e),this.log("Replaced node",{oldElement:e,newNode:t}))}patchUpdateText(e,t){e.nodeType,Node.TEXT_NODE,e.textContent=t,this.log("Updated text",{element:e,content:t})}patchUpdateProps(e,t){const n=Array.from(e.attributes);for(const o of n)o.name in t||o.name.startsWith("data-minimact-")||e.removeAttribute(o.name);for(const[n,o]of Object.entries(t))if("style"===n)e.setAttribute("style",o);else if("class"===n||"className"===n)e.className=o;else{if(n.startsWith("on"))continue;e.setAttribute(n,o)}this.log("Updated props",{element:e,props:t})}patchReorderChildren(e,t){const n=new Map;for(const t of Array.from(e.childNodes))if(t instanceof HTMLElement){const e=t.getAttribute("data-key")||t.getAttribute("key");e&&n.set(e,t)}for(let o=0;o<t.length;o++){const s=t[o],i=n.get(s);if(i){const t=e.childNodes[o];t!==i&&e.insertBefore(i,t)}}this.log("Reordered children",{element:e,order:t})}getElementByPath(e,t){if(!t||Array.isArray(t)&&0===t.length)return e;const n=Array.isArray(t)?t:[];let o=e;for(const e of n){if(e>=o.childNodes.length)return console.error(`[DOMPatcher] Index ${e} out of bounds (${o.childNodes.length} children)`),null;o=o.childNodes[e]}return o}createElementFromVNode(e){switch(e.type){case"Text":return document.createTextNode(e.content);case"Element":{const t=e,n=document.createElement(t.tag);for(const[e,o]of Object.entries(t.props||{}))"className"===e||"class"===e?n.className=o:e.startsWith("on")?n.setAttribute(`data-${e.toLowerCase()}`,o):n.setAttribute(e,o);t.key&&n.setAttribute("data-key",t.key);for(const e of t.children||[])n.appendChild(this.createElementFromVNode(e));return n}case"Fragment":{const t=document.createDocumentFragment(),n=e;for(const e of n.children||[])t.appendChild(this.createElementFromVNode(e));return t}case"RawHtml":{const t=document.createElement("div");return t.innerHTML=e.html,t}default:return console.warn("[Minimact] Unknown VNode type:",e),document.createTextNode("")}}replaceHTML(e,t){e.innerHTML=t,this.log("Replaced entire HTML",{html:t})}log(e,t){this.debugLogging&&console.log(`[Minimact DOMPatcher] ${e}`,t||"")}}class l{constructor(e={}){this.states=new Map,this.subscribers=new Map,this.debugLogging=e.debugLogging||!1}initializeComponent(e,t={}){this.states.set(e,{...t}),this.subscribers.set(e,new Map),this.log("Initialized component state",{componentId:e,initialState:t})}getState(e,t){const n=this.states.get(e);return n?n[t]:void 0}setState(e,t,n){const o=this.states.get(e);if(!o)return void console.warn(`[Minimact] Component ${e} not initialized`);const s=o[t];o[t]=n,this.log("State updated",{componentId:e,key:t,oldValue:s,newValue:n}),this.notifySubscribers(e,t,n,s)}subscribe(e,t,n){const o=this.subscribers.get(e);return o?(o.has(t)||o.set(t,new Set),o.get(t).add(n),this.log("Subscribed to state",{componentId:e,key:t}),()=>{o.get(t)?.delete(n),this.log("Unsubscribed from state",{componentId:e,key:t})}):(console.warn(`[Minimact] Component ${e} not initialized`),()=>{})}notifySubscribers(e,t,n,o){const s=this.subscribers.get(e);if(!s)return;const i=s.get(t);i&&i.forEach(e=>{try{e(n,o)}catch(e){console.error("[Minimact] Error in state subscriber:",e)}})}getComponentState(e){return this.states.get(e)}updateState(e,t){for(const[n,o]of Object.entries(t))this.setState(e,n,o)}clearComponent(e){this.states.delete(e),this.subscribers.delete(e),this.log("Cleared component state",{componentId:e})}bindToElement(e,t,n,o="textContent"){const s=this.getState(e,t);return void 0!==s&&this.updateElement(n,o,s),this.subscribe(e,t,e=>{this.updateElement(n,o,e)})}updateElement(e,t,n){switch(t){case"value":(e instanceof HTMLInputElement||e instanceof HTMLTextAreaElement||e instanceof HTMLSelectElement)&&(e.value=String(n));break;case"textContent":e.textContent=String(n);break;case"innerHTML":e.innerHTML=String(n)}}bindInput(e,t,n){const o=this.getState(e,t);void 0!==o&&(n.value=String(o));const s=n=>{const o=n.target;this.setState(e,t,o.value)};n.addEventListener("input",s);const i=this.subscribe(e,t,e=>{n.value!==String(e)&&(n.value=String(e))});return()=>{n.removeEventListener("input",s),i()}}log(e,t){this.debugLogging&&console.log(`[Minimact ClientState] ${e}`,t||"")}}class d{constructor(e,t,n={}){this.rootElement=e,this.componentMethodInvoker=t,this.debugLogging=n.debugLogging||!1,this.hintQueue=n.hintQueue,this.domPatcher=n.domPatcher,this.playgroundBridge=n.playgroundBridge,this.eventListeners=new Map,this.setupEventDelegation()}setupEventDelegation(){const e=["click","dblclick","input","change","submit","focus","blur","keydown","keyup","keypress","mouseenter","mouseleave","mouseover","mouseout"];for(const t of e){const e=this.createEventListener(t);this.eventListeners.set(t,e),this.rootElement.addEventListener(t,e,!0)}this.log("Event delegation setup complete",{eventTypes:e})}createEventListener(e){return async t=>{const n=t.target,o=this.findHandlerElement(n,e);if(!o)return;const s=this.getEventHandler(o,e);s&&("submit"===e&&t.preventDefault(),this.log("Event triggered",{eventType:e,handler:s,target:n}),await this.executeHandler(s,t,o))}}findHandlerElement(e,t){let n=e;for(;n&&n!==this.rootElement;){const e=`data-on${t}`,o=`on${t}`;if(n.hasAttribute(e)||n.hasAttribute(o))return n;n=n.parentElement}return null}getEventHandler(e,t){const n=`data-on${t}`,o=`on${t}`,s=e.getAttribute(n)||e.getAttribute(o);if(!s)return null;let i=!1,r=s;s.startsWith("@client:")&&(i=!0,r=s.substring(8));const a=r.split(":"),c=a[0],l=a.slice(1),d=this.findComponentId(e);return d||i?{componentId:d||"",methodName:c,args:l,isClientOnly:i}:(console.warn("[Minimact] No component ID found for event handler:",s),null)}findComponentId(e){let t=e;for(;t&&t!==this.rootElement;){const e=t.getAttribute("data-minimact-component-id");if(e)return e;t=t.parentElement}return this.rootElement.getAttribute("data-minimact-component-id")}async executeHandler(e,t,n){const o=performance.now();try{if(e.isClientOnly){const n=window.MinimactHandlers?.[e.methodName];if(n&&"function"==typeof n){this.log(`üü¶ CLIENT HANDLER: ${e.methodName}`,{handler:e}),n(t);const s=performance.now()-o;return void this.log(`üü¶ CLIENT HANDLER completed in ${s.toFixed(2)}ms`,{handler:e})}return void console.warn(`[Minimact] Client handler '${e.methodName}' not found in window.MinimactHandlers`)}const n={};if(e.args.length>0&&(n.args=e.args.map(e=>{try{return JSON.parse(e)}catch{return e}})),t instanceof MouseEvent&&(n.mouse={clientX:t.clientX,clientY:t.clientY,button:t.button}),t instanceof KeyboardEvent&&(n.keyboard={key:t.key,code:t.code,ctrlKey:t.ctrlKey,shiftKey:t.shiftKey,altKey:t.altKey}),"input"===t.type||"change"===t.type){const e=t.target;n.value=e.value}const s=[];if(void 0!==n.value&&s.push(n.value),n.args&&Array.isArray(n.args)&&s.push(...n.args),this.hintQueue&&this.domPatcher){const t=this.tryMatchHint(e.componentId,e.methodName);if(t){const n=this.findComponentElement(e.componentId);if(n){this.domPatcher.applyPatches(n,t.patches);const i=performance.now()-o;return this.playgroundBridge&&this.playgroundBridge.cacheHit({componentId:e.componentId,hintId:t.hintId,latency:i,confidence:t.confidence,patchCount:t.patches.length}),this.log(`üü¢ CACHE HIT! Applied ${t.patches.length} patches in ${i.toFixed(2)}ms`,{handler:e,confidence:(100*t.confidence).toFixed(0)+"%"}),void this.componentMethodInvoker(e.componentId,e.methodName,s).catch(e=>{console.error("[Minimact] Background server notification failed:",e)})}}}await this.componentMethodInvoker(e.componentId,e.methodName,s);const i=performance.now()-o;this.playgroundBridge&&this.playgroundBridge.cacheMiss({componentId:e.componentId,methodName:e.methodName,latency:i,patchCount:0}),this.log(`üî¥ CACHE MISS - Server latency: ${i.toFixed(2)}ms`,{handler:e,argsObj:n})}catch(t){console.error("[Minimact] Error executing handler:",e,t)}}tryMatchHint(e,t){return this.hintQueue,null}findComponentElement(e){return this.rootElement.querySelector(`[data-minimact-component-id="${e}"]`)}destroy(){for(const[e,t]of this.eventListeners.entries())this.rootElement.removeEventListener(e,t,!0);this.eventListeners.clear(),this.log("Event delegation destroyed")}log(e,t){this.debugLogging&&console.log(`[Minimact EventDelegation] ${e}`,t||"")}}class h{constructor(e,t={}){this.clientState=e,this.components=new Map,this.debugLogging=t.debugLogging||!1}hydrateComponent(e,t,n){if(this.log("Hydrating component",{componentId:e,componentType:n}),!t.firstElementChild)return void console.error("[Minimact Hydration] No component element found in root");const o={componentId:e,type:n,element:t,clientState:{},serverState:{}};this.components.set(e,o),t.setAttribute("data-minimact-component-id",e),this.clientState.initializeComponent(e),this.hydrateClientZones(e,t),this.bindStateElements(e,t),this.log("Component hydrated",{componentId:e,metadata:o})}hydrateClientZones(e,t){const n=t.querySelectorAll("[data-minimact-client-scope]");this.log("Found client zones",{count:n.length}),n.forEach(t=>{const n=t,o=n.getAttribute("data-state");if(o){const t=this.getInitialValue(n);this.clientState.setState(e,o,t),(n instanceof HTMLInputElement||n instanceof HTMLTextAreaElement||n instanceof HTMLSelectElement)&&this.clientState.bindInput(e,o,n),this.log("Hydrated client zone",{element:n,stateName:o,initialValue:t})}})}bindStateElements(e,t){const n=t.querySelectorAll("[data-bind]");this.log("Found bound elements",{count:n.length}),n.forEach(t=>{const n=t,o=n.getAttribute("data-bind");if(!o)return;const s=this.isInClientScope(n),i=this.determineBindProperty(n);s?(this.clientState.bindToElement(e,o,n,i),this.log("Bound to client state",{element:n,bindKey:o,bindProperty:i})):this.log("Server-bound element (patch-controlled)",{element:n,bindKey:o})})}isInClientScope(e){let t=e;for(;t;){if(t.hasAttribute("data-minimact-client-scope"))return!0;if(t.hasAttribute("data-minimact-server-scope"))return!1;t=t.parentElement}return!1}determineBindProperty(e){return e instanceof HTMLInputElement||e instanceof HTMLTextAreaElement||e instanceof HTMLSelectElement?"value":e.hasAttribute("data-bind-html")?"innerHTML":"textContent"}getInitialValue(e){return e instanceof HTMLInputElement?"checkbox"===e.type?e.checked:"number"===e.type?e.valueAsNumber||0:e.value:e instanceof HTMLTextAreaElement||e instanceof HTMLSelectElement?e.value:e.textContent||""}dehydrateComponent(e){this.components.get(e)&&(this.clientState.clearComponent(e),this.components.delete(e),this.log("Component dehydrated",{componentId:e}))}getComponent(e){return this.components.get(e)}updateServerState(e,t,n){const o=this.components.get(e);o&&(o.serverState[t]=n,this.log("Updated server state",{componentId:e,key:t,value:n}))}hydrateAll(){const e=document.querySelectorAll("[data-minimact-component]");this.log("Hydrating all components",{count:e.length}),e.forEach(e=>{const t=e.getAttribute("data-minimact-component");t&&this.hydrateComponent(t,e)})}log(e,t){this.debugLogging&&console.log(`[Minimact Hydration] ${e}`,t||"")}}class p{static renderTemplate(e,t){let n=e;return t.forEach((e,t)=>{const o=`{${t}}`,s=this.formatValue(e);n=n.replace(o,s)}),n}static renderTemplatePatch(e,t){if(e.conditionalTemplates&&void 0!==e.conditionalBindingIndex){const n=e.conditionalBindingIndex,o=e.bindings[n],s="object"==typeof o&&"stateKey"in o?o.stateKey:o,i=t[s],r=e.conditionalTemplates[String(i)];if(void 0!==r){if(!r.includes("{"))return r;const n=e.bindings.map(e=>{if("object"==typeof e&&"stateKey"in e){const n=t[e.stateKey];return e.transform?this.applyTransform(n,e.transform):n}return t[e]});return this.renderTemplate(r,n)}}const n=e.bindings.map((e,n)=>{if("object"==typeof e&&"stateKey"in e){const n=t[e.stateKey];return e.transform?this.applyTransform(n,e.transform):n}return t[e]});return this.renderTemplate(e.template,n)}static materializePatch(e,t){switch(e.type){case"UpdateTextTemplate":{const n=this.renderTemplatePatch(e.templatePatch,t);return{type:"UpdateText",path:e.path,content:n}}case"UpdatePropsTemplate":{const n=this.renderTemplatePatch(e.templatePatch,t);return{type:"UpdateProps",path:e.path,props:{[e.propName]:n}}}case"UpdateListTemplate":{const n=this.renderLoopTemplate(e.loopTemplate,t);return this.convertLoopToPatches(e.path,n)}case"UpdateAttributeStatic":return{type:"UpdateProps",path:e.path,props:{[e.attrName]:e.value}};case"UpdateAttributeDynamic":{const n=this.renderTemplatePatch(e.templatePatch,t);return{type:"UpdateProps",path:e.path,props:{[e.attrName]:n}}}default:return e}}static materializePatches(e,t){const n=[];for(const o of e){const e=this.materializePatch(o,t);Array.isArray(e)?n.push(...e):n.push(e)}return n}static applyTransform(e,t){if(t.startsWith("toFixed(")){const n=parseInt(t.match(/\d+/)?.[0]||"0");return Number(e).toFixed(n)}if(t.startsWith("* ")){const n=parseFloat(t.substring(2));return Number(e)*n}if(t.startsWith("/ ")){const n=parseFloat(t.substring(2));return Number(e)/n}if(t.startsWith("+ ")){const n=parseFloat(t.substring(2));return Number(e)+n}if(t.startsWith("- ")){const n=parseFloat(t.substring(2));return Number(e)-n}return"toUpperCase()"===t||"toUpperCase"===t?String(e).toUpperCase():"toLowerCase()"===t||"toLowerCase"===t?String(e).toLowerCase():"trim()"===t||"trim"===t?String(e).trim():"!"===t?!e:(console.warn(`[TemplateRenderer] Unknown transform: ${t}`),e)}static formatValue(e){return null==e?"":"string"==typeof e?e:"number"==typeof e||"boolean"==typeof e?String(e):Array.isArray(e)?e.map(e=>this.formatValue(e)).join(", "):"object"==typeof e?JSON.stringify(e):String(e)}static isTemplatePatch(e){return"UpdateTextTemplate"===e.type||"UpdatePropsTemplate"===e.type||"UpdateListTemplate"===e.type||"UpdateAttributeStatic"===e.type||"UpdateAttributeDynamic"===e.type}static extractBindings(e){return"UpdateTextTemplate"===e.type||"UpdatePropsTemplate"===e.type||"UpdateAttributeDynamic"===e.type?e.templatePatch.bindings.map(e=>"object"==typeof e&&"stateKey"in e?e.stateKey:e):(e.type,[])}static validateBindings(e,t){return e.bindings.every(e=>("object"==typeof e&&"stateKey"in e?e.stateKey:e)in t)}static getMissingBindings(e,t){return e.bindings.filter(e=>!(("object"==typeof e&&"stateKey"in e?e.stateKey:e)in t)).map(e=>"object"==typeof e&&"stateKey"in e?e.stateKey:e)}static renderLoopTemplate(e,t){const n=t[e.array_binding];return Array.isArray(n)?n.map((n,o)=>{const s={...t,item:n,index:o,...e.index_var?{[e.index_var]:o}:{}},i=this.flattenItemState(s,n);return this.renderItemTemplate(e.item_template,i)}):(console.warn(`[TemplateRenderer] Expected array for '${e.array_binding}', got:`,n),[])}static flattenItemState(e,t){const n={...e};if("object"==typeof t&&null!==t&&!Array.isArray(t))for(const e in t)n[`item.${e}`]=t[e];return n}static renderItemTemplate(e,t){switch(e.type){case"Text":return{type:"Text",content:this.renderTemplatePatch(e.template_patch,t)};case"Element":{const n={};if(e.props_templates)for(const[o,s]of Object.entries(e.props_templates))n[o]=this.renderTemplatePatch(s,t);const o=(e.children_templates||[]).map(e=>this.renderItemTemplate(e,t)),s=e.key_binding?String(t[e.key_binding]):void 0;return{type:"Element",tag:e.tag,props:n,children:o,key:s}}default:throw new Error(`Unknown item template type: ${e.type}`)}}static convertLoopToPatches(e,t){return t.map((t,n)=>{const o=n.toString(16).padStart(8,"0");return{type:"Create",path:e?`${e}.${o}`:o,node:t}})}}class m{constructor(e={}){this.hints=new Map,this.maxHintAge=5e3,this.debugLogging=e.debugLogging||!1}queueHint(e){const t=`${e.componentId}:${e.hintId}`,n=e.patches.some(e=>p.isTemplatePatch(e));this.hints.set(t,{...e,queuedAt:Date.now(),isTemplate:n});const o=n?"üìê TEMPLATE":"üìÑ CONCRETE";this.log(`${o} hint '${e.hintId}' queued for ${e.componentId}`,e),this.cleanupStaleHints()}matchHint(e,t){const n=Array.from(this.hints.entries()).filter(([t])=>t.startsWith(`${e}:`)).map(([,e])=>e);for(const o of n)if(this.stateMatches(o.predictedState,t)){const n=o.isTemplate?"üìê TEMPLATE":"üìÑ CONCRETE";this.log(`${n} hint '${o.hintId}' matched!`,{hint:o,stateChanges:t});const s=`${e}:${o.hintId}`;this.hints.delete(s);const i=p.materializePatches(o.patches,t);return{hintId:o.hintId,patches:i,confidence:o.confidence}}return null}stateMatches(e,t){for(const[n,o]of Object.entries(e)){if(!(n in t))return!1;if(JSON.stringify(t[n])!==JSON.stringify(o))return!1}return!0}cleanupStaleHints(){const e=Date.now(),t=[];for(const[n,o]of this.hints.entries())e-o.queuedAt>this.maxHintAge&&t.push(n);if(t.length>0){this.log(`Removing ${t.length} stale hint(s)`,t);for(const e of t)this.hints.delete(e)}}clearComponent(e){const t=Array.from(this.hints.keys()).filter(t=>t.startsWith(`${e}:`));for(const e of t)this.hints.delete(e);t.length>0&&this.log(`Cleared ${t.length} hint(s) for component ${e}`)}clearAll(){this.hints.clear(),this.log("Cleared all hints")}getStats(){const e=Array.from(this.hints.values()),t=e.filter(e=>e.isTemplate),n=e.filter(e=>!e.isTemplate);return{totalHints:this.hints.size,templateHints:t.length,concreteHints:n.length,templatePercentage:this.hints.size>0?Math.round(t.length/this.hints.size*100):0,hintsByComponent:e.reduce((e,t)=>(e[t.componentId]=(e[t.componentId]||0)+1,e),{})}}log(e,...t){this.debugLogging&&console.log(`[Minimact HintQueue] ${e}`,...t)}}class u{constructor(e={}){this.debugLogging=e.debugLogging||!1}predictionReceived(e){this.postMessage({type:"minimact:prediction-received",data:e}),this.log("Prediction received",e)}cacheHit(e){this.postMessage({type:"minimact:cache-hit",data:{...e,cacheHit:!0,elapsedMs:e.latency}}),this.log("üü¢ CACHE HIT",e)}cacheMiss(e){this.postMessage({type:"minimact:cache-miss",data:{...e,cacheHit:!1,elapsedMs:e.latency,predictionConfidence:0}}),this.log("üî¥ CACHE MISS",e)}correctionApplied(e){this.postMessage({type:"minimact:correction",data:e}),this.log("Correction applied (prediction was incorrect)",e)}postMessage(e){window.parent&&window.parent!==window&&window.parent.postMessage(e,"*"),window.dispatchEvent(new CustomEvent(e.type,{detail:e.data}))}log(e,t){this.debugLogging&&console.log(`[Minimact PlaygroundBridge] ${e}`,t||"")}}class g{detectEditPattern(e,t){if(e===t)return{type:"complex",confidence:0};const n=this.computeDiff(e,t),o=this.detectTextChange(n);if(o)return o;const s=this.detectClassChange(n);if(s)return s;const i=this.detectAttributeChange(n);if(i)return i;const r=this.detectStyleChange(n);if(r)return r;return this.detectElementChange(n)||{type:"complex",confidence:.5}}computeDiff(e,t){const n=e.split("\n").map(e=>e.trim()).filter(e=>e.length>0),o=t.split("\n").map(e=>e.trim()).filter(e=>e.length>0),s=new Set(n),i=new Set(o);return{added:o.filter(e=>!s.has(e)),removed:n.filter(e=>!i.has(e)),unchanged:o.filter(e=>s.has(e))}}detectTextChange(e){if(1!==e.removed.length||1!==e.added.length)return null;const t=e.removed[0],n=e.added[0],o=t.match(/^<(\w+)[^>]*>(.*)<\/\1>$/),s=n.match(/^<(\w+)[^>]*>(.*)<\/\1>$/);if(!o||!s)return null;const[,i,r]=o,[,a,c]=s;if(i===a&&r!==c){const e=this.extractAttributes(t),o=this.extractAttributes(n);if(JSON.stringify(e)===JSON.stringify(o))return{type:"text-content",path:i,oldValue:r.trim(),newValue:c.trim(),confidence:.99}}return null}detectClassChange(e){if(1!==e.removed.length||1!==e.added.length)return null;const t=e.removed[0],n=e.added[0],o=t.match(/className=["']([^"']+)["']/),s=n.match(/className=["']([^"']+)["']/);if(!o||!s)return null;const i=o[1].split(/\s+/),r=s[1].split(/\s+/),a=e=>e.replace(/className=["'][^"']*["']/,'className="__PLACEHOLDER__"');return a(t)===a(n)?{type:"class-name",oldClasses:i,newClasses:r,confidence:.98}:null}detectAttributeChange(e){if(1!==e.removed.length||1!==e.added.length)return null;const t=e.removed[0],n=e.added[0],o=this.extractAttributes(t),s=this.extractAttributes(n),i=Object.keys(s).find(e=>o[e]!==s[e]);if(!i)return null;const r=Object.keys(o),a=Object.keys(s);return r.length!==a.length?null:r.filter(e=>e!==i&&o[e]===s[e]).length===r.length-1?{type:"attribute",attribute:i,oldValue:o[i],newValue:s[i],confidence:.97}:null}detectStyleChange(e){if(1!==e.removed.length||1!==e.added.length)return null;const t=e.removed[0],n=e.added[0],o=t.match(/style=\{\{([^}]+)\}\}/),s=n.match(/style=\{\{([^}]+)\}\}/);if(!o||!s)return null;const i=this.parseInlineStyle(o[1]),r=this.parseInlineStyle(s[1]),a=Object.keys(r).find(e=>i[e]!==r[e]);return a?Object.keys(i).length!==Object.keys(r).length?null:Object.keys(i).filter(e=>e!==a&&i[e]===r[e]).length===Object.keys(i).length-1?{type:"inline-style",styleProperty:a,oldValue:i[a],newValue:r[a],confidence:.96}:null:null}detectElementChange(e){if(1===e.added.length&&0===e.removed.length){const t=e.added[0];if(t.match(/^<(\w+)/))return{type:"element-added",element:t,confidence:.9}}if(1===e.removed.length&&0===e.added.length){const t=e.removed[0];if(t.match(/^<(\w+)/))return{type:"element-removed",element:t,confidence:.9}}return null}extractAttributes(e){const t={},n=/(\w+)=["']([^"']+)["']/g;let o;for(;null!==(o=n.exec(e));)t[o[1]]=o[2];return t}parseInlineStyle(e){const t={},n=e.split(",");for(const e of n){const[n,o]=e.split(":").map(e=>e.trim());if(n&&o){const e=o.replace(/['"]/g,"");t[n]=e}}return t}buildCacheKey(e,t){switch(t.type){case"text-content":return`${e}:text:${t.path}:${t.oldValue}‚Üí${t.newValue}`;case"class-name":return`${e}:class:${t.oldClasses?.join(",")}‚Üí${t.newClasses?.join(",")}`;case"attribute":return`${e}:attr:${t.attribute}:${t.oldValue}‚Üí${t.newValue}`;case"inline-style":return`${e}:style:${t.styleProperty}:${t.oldValue}‚Üí${t.newValue}`;case"element-added":return`${e}:add:${this.hashElement(t.element)}`;case"element-removed":return`${e}:remove:${this.hashElement(t.element)}`;default:return`${e}:complex`}}hashElement(e){let t=0;for(let n=0;n<e.length;n++)t=(t<<5)-t+e.charCodeAt(n),t&=t;return t.toString(36)}}class f{constructor(){this.templates=new Map,this.conditionalElements=new Map,this.componentStates=new Map}loadTemplateMap(e,t){console.log(`[TemplateState] Loading ${Object.keys(t.templates).length} templates for ${e}`);for(const[n,o]of Object.entries(t.templates)){const t=`${e}:${n}`,s={template:o.templateString||o.template,bindings:o.bindings,slots:o.slots,path:o.path,type:o.type};this.templates.set(t,s)}if(t.conditionalElements){const n=Object.keys(t.conditionalElements).length;console.log(`[TemplateState] Loading ${n} conditional element templates for ${e}`);for(const[n,o]of Object.entries(t.conditionalElements)){const t=`${e}:${n}`;this.conditionalElements.set(t,o)}}this.componentStates.has(e)||this.componentStates.set(e,new Map)}registerTemplate(e,t,n){const o=`${e}:${t}`;this.templates.set(o,n)}getTemplate(e,t){const n=`${e}:${t}`;return this.templates.get(n)}getComponentTemplates(e){const t=new Map;for(const[n,o]of this.templates.entries())if(n.startsWith(`${e}:`)){const s=n.substring(e.length+1);t.set(s,o)}return t}getTemplatesBoundTo(e,t){const n=[];for(const[o,s]of this.templates.entries())o.startsWith(`${e}:`)&&s.bindings.includes(t)&&n.push(s);return n}getConditionalElementsBoundTo(e,t){const n=[];for(const[o,s]of this.conditionalElements.entries())if(o.startsWith(`${e}:`)&&s.conditionBindings.includes(t)){const t=o.substring(e.length+1);n.push({pathKey:t,template:s})}return n}getAllComponentState(e){const t=this.componentStates.get(e);if(!t)return{};const n={};for(const[e,o]of t.entries())n[e]=o;return n}updateState(e,t,n){let o=this.componentStates.get(e);o||(o=new Map,this.componentStates.set(e,o)),o.set(t,n)}getStateValue(e,t){return this.componentStates.get(e)?.get(t)}render(e,t){const n=this.getTemplate(e,t);if(!n)return null;const o=n.bindings.map(t=>this.getStateValue(e,t));return this.renderWithParams(n.template,o)}renderWithParams(e,t){let n=e;return t.forEach((e,t)=>{const o=`{${t}}`,s=null!=e?String(e):"";n=n.replace(o,s)}),n}applyTemplatePatch(e){const{componentId:t,path:n,template:o,params:s,bindings:i,slots:r,attribute:a}=e,c=[];for(const e of i){const n=this.getStateValue(t,e);c.push(void 0!==n?n:s[c.length])}const l=this.renderWithParams(o,c),d=`${t}:${this.buildNodePathKey(n)}`,h=this.templates.get(d);return h?(h.template=o,h.bindings=i,h.slots=r,a&&(h.attribute=a)):this.templates.set(d,{template:o,bindings:i,slots:r,path:n.join("."),type:a?"attribute":"dynamic",attribute:a}),console.log(`[TemplateState] Applied template patch: "${o}" ‚Üí "${l}"`),{text:l,path:n}}buildNodePathKey(e){return e.join("_")}clearComponent(e){const t=[];for(const n of this.templates.keys())n.startsWith(`${e}:`)&&t.push(n);for(const e of t)this.templates.delete(e);this.componentStates.delete(e)}clear(){this.templates.clear(),this.componentStates.clear()}getStats(){const e=this.componentStates.size,t=this.templates.size;let n=0;for(const e of this.templates.values())n+=2*(e.template?.length||0),n+=20*(e.bindings?.length||0),n+=4*(e.slots?.length||0),n+=2*(e.path?.length||0);return{componentCount:e,templateCount:t,memoryKB:Math.round(n/1024),avgTemplatesPerComponent:t/Math.max(e,1)}}}const y=new f;class b{constructor(e,t={}){this.ws=null,this.previousVNodes=new Map,this.previousTsx=new Map,this.tsxPredictionCache=new Map,this.pendingVerifications=new Map,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.nullPaths=new Map,this.minimact=e,this.config={enabled:!0,wsUrl:this.getDefaultWsUrl(),debounceMs:50,showNotifications:!0,logLevel:"info",...t},this.metrics={lastUpdateTime:0,updateCount:0,averageLatency:0,cacheHits:0,cacheMisses:0,errors:0},this.detector=new g,this.config.enabled&&this.connect()}getDefaultWsUrl(){return`${"https:"===window.location.protocol?"wss:":"ws:"}//${window.location.host}/minimact-hmr`}connect(){if(this.config.wsUrl)try{this.ws=new WebSocket(this.config.wsUrl),this.ws.onopen=()=>{this.log("info","‚úÖ Hot reload connected"),this.reconnectAttempts=0,this.showToast("üî• Hot reload enabled","success")},this.ws.onmessage=e=>{this.handleMessage(JSON.parse(e.data))},this.ws.onerror=e=>{this.log("error","Hot reload connection error:",e)},this.ws.onclose=()=>{this.log("warn","Hot reload disconnected"),this.attemptReconnect()}}catch(e){this.log("error","Failed to connect to hot reload server:",e)}}attemptReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts)return void this.log("error","Max reconnection attempts reached");this.reconnectAttempts++;const e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),1e4);this.log("info",`Reconnecting in ${e}ms... (attempt ${this.reconnectAttempts})`),setTimeout(()=>{this.connect()},e)}async handleMessage(e){const t=performance.now();switch(e.type){case"template-map":this.handleTemplateMap(e);break;case"template-patch":await this.handleTemplatePatch(e);break;case"file-change":await this.handleFileChange(e);break;case"error":this.handleError(e);break;case"connected":this.log("info","Hot reload server ready");break;case"rerender-complete":this.log("debug","Server re-render complete")}const n=performance.now()-t;this.updateMetrics(n)}async handleFileChange(e){if(!e.componentId||!e.code)return;const t=performance.now();this.log("debug",`üìù File changed: ${e.filePath}`);try{const n=this.previousTsx.get(e.componentId)||"";if(!n)return this.previousTsx.set(e.componentId,e.code),void this.log("debug","First load - cached TSX");const o=this.detector.detectEditPattern(n,e.code);if(this.log("debug",`Detected pattern: ${o.type} (confidence: ${(100*o.confidence).toFixed(0)}%)`),o.confidence>.9){const n=this.detector.buildCacheKey(e.componentId,o),s=this.tsxPredictionCache.get(n);if(s){const n=this.minimact.getComponent(e.componentId);if(n){this.minimact.domPatcher.applyPatches(n.element,s);const o=performance.now()-t;return this.log("info",`üöÄ INSTANT! Applied cached patches in ${o.toFixed(1)}ms`),this.metrics.cacheHits++,this.showToast(`‚ö° ${o.toFixed(0)}ms`,"success",800),this.flashComponent(n.element),this.previousTsx.set(e.componentId,e.code),void this.verifyWithServer(e.componentId,e.code)}}else this.log("debug",`No cache hit for key: ${n}`)}this.log("info","‚ö†Ô∏è No prediction - requesting server render"),this.metrics.cacheMisses++,await this.requestServerRerender(e.componentId,e.code);const s=performance.now()-t;this.log("info",`‚úÖ Server render complete in ${s.toFixed(1)}ms`),this.showToast(`üîÑ ${s.toFixed(0)}ms`,"info",1e3),this.previousTsx.set(e.componentId,e.code)}catch(e){this.log("error","Hot reload failed:",e),this.metrics.errors++,this.showToast("‚ùå Hot reload failed","error")}}async requestServerRerender(e,t){return new Promise((n,o)=>{const s=setTimeout(()=>{o(new Error("Server rerender timeout"))},5e3);this.ws?.send(JSON.stringify({type:"request-rerender",componentId:e,code:t,timestamp:Date.now()}));const i=t=>{const o=JSON.parse(t.data);"rerender-complete"===o.type&&o.componentId===e&&(clearTimeout(s),this.ws?.removeEventListener("message",i),n())};this.ws?.addEventListener("message",i)})}async verifyWithServer(e,t){try{this.ws?.send(JSON.stringify({type:"verify-tsx",componentId:e,code:t,timestamp:Date.now()})),this.log("debug",`Verification requested for ${e}`)}catch(e){this.log("warn","Verification request failed:",e)}}handleTemplateMap(e){if(!e.templateMap||!e.componentId)return;const t=performance.now(),n=e.componentId,o=e.templateMap.templates;console.log(`[HotReload] üîç Processing template map for ${n}:`,{newTemplateCount:Object.keys(o).length,newTemplateKeys:Object.keys(o).slice(0,5)});const s=Object.keys(o)[0];s&&console.log("[HotReload] üîç First template structure:",s,o[s]);const i=new Map;console.log("[HotReload] üîç Checking for existing templates...");for(const[e,t]of Object.entries(o)){const o=y.getTemplate(n,e),s=t.templateString||t.template;if(o){const t=o.template!==s;console.log(`[HotReload] ${t?"üî•":"‚úÖ"} Template "${e}": old="${o.template}" new="${s}" changed=${t}`),i.set(e,o)}else console.log(`[HotReload] ‚ùå No existing template for ${e}, new="${s}"`)}console.log(`[HotReload] üìã Found ${i.size} existing templates out of ${Object.keys(o).length}`),y.loadTemplateMap(n,e.templateMap);const r=this.minimact.componentRegistry.getByType(n);if(console.log(`[HotReload] üîç Found ${r.length} instance(s) of type "${n}"`),0===r.length)return void console.warn(`[HotReload] ‚ö†Ô∏è No instances found for component type "${n}"`);for(const e of r){console.log(`[HotReload] üì¶ Processing instance ${e.instanceId.substring(0,8)}...`);const t=[];let n=0;for(const[s,r]of Object.entries(o)){const o=i.get(s);if(o&&o.template!==r.template){n++,console.log(`[HotReload] üî• Template changed #${n}: "${o.template}" ‚Üí "${r.template}"`);const s=r.bindings.map(t=>y.getStateValue(e.instanceId,t)),i=y.renderWithParams(r.template,s);"attribute"===r.type&&r.attribute?t.push({type:"UpdateProp",path:r.path,prop:r.attribute,value:i}):t.push({type:"UpdateText",path:r.path,text:i})}}console.log(`[HotReload] üìä Instance summary: ${n} changed, ${t.length} patches`),t.length>0&&(this.minimact.domPatcher.applyPatches(e.element,t),this.flashComponent(e.element),console.log(`[HotReload] ‚úÖ Applied ${t.length} patches to instance ${e.instanceId.substring(0,8)}`))}const a=performance.now()-t,c=Object.keys(o).length;this.log("info",`üì¶ Loaded ${c} templates for ${n} in ${a.toFixed(1)}ms`);const l=y.getStats();this.log("debug",`Template stats: ${l.templateCount} total, ~${l.memoryKB}KB`)}async handleTemplatePatch(e){if(!e.templatePatch||!e.componentId)return;const t=performance.now(),n=e.templatePatch,o=e.componentId;console.log(`[HotReload] üîß Applying template patch to ${o}:`,n);try{if("UpdateAttributeStatic"===n.type){const e=n.attrName,s=n.value;if(!e||void 0===s)return void console.warn("[HotReload] ‚ö†Ô∏è UpdateAttributeStatic missing attrName or value:",n);const i=this.minimact.componentRegistry.getByType(o);if(console.log(`[HotReload] üîç Found ${i.length} instance(s) to update`),0===i.length)return void console.warn(`[HotReload] ‚ö†Ô∏è No instances found for type "${o}"`);for(const r of i){const i=this.findElementByPath(r.element,n.path,o);if(i&&i.nodeType===Node.ELEMENT_NODE){i.setAttribute(e,s);const n=performance.now()-t;console.log(`[HotReload] üöÄ INSTANT! Updated static attribute ${e}="${s}" in ${n.toFixed(1)}ms`),this.log("info",`üöÄ INSTANT! Static attribute updated in ${n.toFixed(1)}ms`),this.metrics.cacheHits++,this.showToast(`‚ö° ${n.toFixed(0)}ms`,"success",800),this.flashComponent(r.element)}else console.warn("[HotReload] ‚ö†Ô∏è Element not found at path:",n.path)}return}const e=y.applyTemplatePatch(n);if(e){console.log("[HotReload] üìù Template patch result:",e);const s=this.minimact.componentRegistry.getByType(o);if(console.log(`[HotReload] üîç Found ${s.length} instance(s) to update`),0===s.length)return void console.warn(`[HotReload] ‚ö†Ô∏è No instances found for type "${o}"`);for(const i of s){const s=this.findElementByPath(i.element,e.path,o);if(s){"UpdateTextTemplate"===n.type?(s.nodeType,Node.TEXT_NODE,s.textContent=e.text):"UpdatePropTemplate"===n.type&&n.attribute&&s.setAttribute(n.attribute,e.text);const o=performance.now()-t;console.log(`[HotReload] üöÄ INSTANT! Updated instance ${i.instanceId.substring(0,8)} in ${o.toFixed(1)}ms: "${e.text}"`),this.log("info",`üöÄ INSTANT! Template updated in ${o.toFixed(1)}ms: "${e.text}"`),this.metrics.cacheHits++,this.showToast(`‚ö° ${o.toFixed(0)}ms`,"success",800),this.flashComponent(i.element)}else console.warn("[HotReload] ‚ö†Ô∏è Element not found at path:",e.path)}}else console.warn("[HotReload] ‚ö†Ô∏è Template patch returned no result")}catch(t){this.log("error","Template patch failed:",t),this.metrics.errors++,await this.requestServerRerender(e.componentId,"")}}isPathNull(e,t){return this.nullPaths.get(e)?.has(t)??!1}setPathNull(e,t){this.nullPaths.has(e)||this.nullPaths.set(e,new Set),this.nullPaths.get(e).add(t)}setPathNonNull(e,t){this.nullPaths.get(e)?.delete(t)}updateNullPaths(e,t){this.nullPaths.set(e,new Set(t))}findElementByPath(e,t,n){if(""===t||"."===t||Array.isArray(t)&&0===t.length)return e;let o;o="string"==typeof t?t.includes("@")?t.split(".").filter(e=>!e.startsWith("@")).map(e=>parseInt(e,10)):t.split(".").map(e=>parseInt(e,10)):t;let s=e;for(const e of o){if(!s.childNodes||e>=s.childNodes.length)return console.warn(`[HotReload] Index ${e} out of bounds (${s.childNodes?.length||0} children)`),null;s=s.childNodes[e]}return s}populateTsxCache(e){if(!e.tsxPattern||!e.patches)return;const t=this.detector.buildCacheKey(e.componentId,e.tsxPattern);this.tsxPredictionCache.set(t,e.patches),this.log("debug",`üì¶ Cached TSX pattern: ${t} (${e.patches.length} patches)`)}handleError(e){this.log("error",`Server error: ${e.error}`),this.metrics.errors++,this.showToast(`‚ùå ${e.error}`,"error")}computePatches(e,t){const n=[];if("string"==typeof e&&"string"==typeof t)e!==t&&n.push({type:"text",value:t});else if("object"==typeof e&&"object"==typeof t){if(e.tag!==t.tag)return n.push({type:"replace",vnode:t}),n;const o=e.attributes||{},s=t.attributes||{};for(const e in s)o[e]!==s[e]&&n.push({type:"setAttribute",name:e,value:s[e]});for(const e in o)e in s||n.push({type:"removeAttribute",name:e});const i=e.children||[],r=t.children||[];for(let e=0;e<Math.max(i.length,r.length);e++)if(e>=i.length)n.push({type:"appendChild",vnode:r[e]});else if(e>=r.length)n.push({type:"removeChild",index:e});else{const t=this.computePatches(i[e],r[e]);t.length>0&&n.push({type:"patchChild",index:e,patches:t})}}return n}vnodesMatch(e,t){return JSON.stringify(e)===JSON.stringify(t)}flashComponent(e){e.style.transition="box-shadow 0.3s ease",e.style.boxShadow="0 0 10px 2px rgba(255, 165, 0, 0.6)",setTimeout(()=>{e.style.boxShadow="",setTimeout(()=>{e.style.transition=""},300)},300)}updateMetrics(e){this.metrics.updateCount++,this.metrics.lastUpdateTime=Date.now(),this.metrics.averageLatency=(this.metrics.averageLatency*(this.metrics.updateCount-1)+e)/this.metrics.updateCount}showToast(e,t="info",n=2e3){if(!this.config.showNotifications)return;const o=document.createElement("div");o.textContent=e,o.style.cssText=`\n      position: fixed;\n      bottom: 20px;\n      right: 20px;\n      padding: 12px 20px;\n      background: ${"success"===t?"#10b981":"error"===t?"#ef4444":"#3b82f6"};\n      color: white;\n      border-radius: 6px;\n      font-family: system-ui, -apple-system, sans-serif;\n      font-size: 14px;\n      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n      z-index: 10000;\n      animation: slideIn 0.3s ease;\n    `,document.body.appendChild(o),setTimeout(()=>{o.style.animation="slideOut 0.3s ease",setTimeout(()=>o.remove(),300)},n)}log(e,...t){const n={debug:0,info:1,warn:2,error:3},o=n[this.config.logLevel];if(n[e]>=o){const n="[Minimact HMR]";console[e](n,...t)}}getMetrics(){return{...this.metrics}}enable(){this.config.enabled||(this.config.enabled=!0,this.connect())}disable(){this.config.enabled=!1,this.ws&&(this.ws.close(),this.ws=null)}dispose(){this.disable(),this.previousVNodes.clear(),this.pendingVerifications.clear()}}const v=document.createElement("style");v.textContent="\n  @keyframes slideIn {\n    from {\n      transform: translateX(400px);\n      opacity: 0;\n    }\n    to {\n      transform: translateX(0);\n      opacity: 1;\n    }\n  }\n\n  @keyframes slideOut {\n    from {\n      transform: translateX(0);\n      opacity: 1;\n    }\n    to {\n      transform: translateX(400px);\n      opacity: 0;\n    }\n  }\n",document.head.appendChild(v);class w{constructor(){this.typeToInstances=new Map,this.instanceToMeta=new Map}register(e){const{type:t,instanceId:n}=e;this.instanceToMeta.set(n,e),this.typeToInstances.has(t)||this.typeToInstances.set(t,new Set),this.typeToInstances.get(t).add(e),console.log(`[Registry] ‚úÖ Registered ${t} instance ${n.substring(0,8)}...`)}unregister(e){const t=this.instanceToMeta.get(e);if(!t)return;this.instanceToMeta.delete(e);const n=this.typeToInstances.get(t.type);n&&(n.delete(t),0===n.size&&this.typeToInstances.delete(t.type)),console.log(`[Registry] ‚ùå Unregistered ${t.type} instance ${e.substring(0,8)}...`)}getByType(e){const t=this.typeToInstances.get(e);return t?Array.from(t):[]}getByInstanceId(e){return this.instanceToMeta.get(e)}getTypes(){return Array.from(this.typeToInstances.keys())}getInstanceCount(){return this.instanceToMeta.size}getStats(){const e={};for(const[t,n]of this.typeToInstances.entries())e[t]=n.size;return{types:this.typeToInstances.size,instances:this.instanceToMeta.size,typeBreakdown:e}}clear(){this.typeToInstances.clear(),this.instanceToMeta.clear(),console.log("[Registry] üßπ Cleared all components")}}class C{constructor(){this.renderedElements=new Map}registerRenderedElement(e,t){this.renderedElements.set(e,t)}unregisterRenderedElement(e){this.renderedElements.delete(e)}getRenderedElement(e){return this.renderedElements.get(e)}evaluateCondition(e,t,n){try{const o={};if(t)for(const[e,s]of Object.entries(t))o[e]=this.resolveBinding(n,s);return this.evaluateSafeExpression(e,o)}catch(t){return console.error("[ConditionalElementRenderer] Failed to evaluate condition:",e,t),!1}}resolveBinding(e,t){const n=t.split(".");let o=e;for(const e of n){if(null==o)return;o=o[e]}return o}evaluateSafeExpression(e,t){const n=e.trim();if(n.startsWith("!")&&!n.includes(" ")){const e=n.slice(1);return!t[e]}if(n.includes("&&"))return n.split("&&").map(e=>e.trim()).every(e=>this.evaluateSafeExpression(e,t));if(n.includes("||"))return n.split("||").map(e=>e.trim()).some(e=>this.evaluateSafeExpression(e,t));const o=["===","!==","==","!=","<=",">=","<",">"];for(const e of o)if(n.includes(e)){const[o,s]=n.split(e).map(e=>e.trim()),i=this.resolveValue(o,t),r=this.resolveValue(s,t);switch(e){case"===":return i===r;case"!==":return i!==r;case"==":return i==r;case"!=":return i!=r;case"<":return i<r;case">":return i>r;case"<=":return i<=r;case">=":return i>=r}}return t.hasOwnProperty(n)?!!t[n]:(console.warn("[ConditionalElementRenderer] Could not evaluate expression:",n),!1)}resolveValue(e,t){return e.startsWith('"')||e.startsWith("'")?e.slice(1,-1):/^-?\d+(\.\d+)?$/.test(e)?parseFloat(e):"true"===e||"false"!==e&&("null"===e?null:"undefined"!==e&&t.hasOwnProperty(e)?t[e]:void 0)}buildElement(e,t){if("fragment"===e.type){const n=document.createDocumentFragment();for(const o of e.children||[])"tag"in o||"fragment"===o.type||"element"===o.type?n.appendChild(this.buildElement(o,t)):n.appendChild(this.buildTextNode(o,t));return n}const n=document.createElement(e.tag);if(e.attributes)for(const[o,s]of Object.entries(e.attributes))if("string"==typeof s)n.setAttribute(o,s);else if(s&&"object"==typeof s)if("binding"in s){const e=this.resolveBinding(t,s.binding);null!=e&&n.setAttribute(o,String(e))}else"expression"in s&&console.warn("[ConditionalElementRenderer] Complex attribute expression not supported:",s.expression);if(e.children)for(const o of e.children)"tag"in o||"fragment"===o.type||"element"===o.type?n.appendChild(this.buildElement(o,t)):n.appendChild(this.buildTextNode(o,t));return n}buildTextNode(e,t){if(void 0!==e.value)return document.createTextNode(e.value);if(e.binding){const n=this.resolveBinding(t,e.binding);return document.createTextNode(null!=n?String(n):"")}return e.expression?(console.warn("[ConditionalElementRenderer] Complex text expression not supported:",e.expression),document.createTextNode("")):document.createTextNode("")}render(e,t,n,o,s){const i=!!t.evaluable&&this.evaluateCondition(t.conditionExpression,t.conditionMapping,n);if(!t.evaluable)return console.log("[ConditionalElementRenderer] Condition not evaluable client-side, waiting for server:",t.conditionExpression),null;const r=i?t.branches.true:t.branches.false;if(!r){const t=o.childNodes[s];return t&&o.removeChild(t),this.unregisterRenderedElement(e),null}const a=this.buildElement(r,n),c=o.childNodes[s];return c?o.replaceChild(a,c):s<o.childNodes.length?o.insertBefore(a,o.childNodes[s]):o.appendChild(a),a instanceof HTMLElement?(this.registerRenderedElement(e,a),a):null}}const T={};let I=!1;function S(e,t){I&&console.log(`[ClientComputed] ${e}`,t||"")}function M(e){const t=T[e];if(!t)return S("No computed variables for component",{componentId:e}),{};const n={};for(const[e,o]of Object.entries(t))try{const t=o.computeFn();o.lastValue=t,n[e]=t}catch(t){console.error(`[ClientComputed] Error computing '${e}':`,t),n[e]=void 0}return S("Computed all variables",{componentId:e,result:n}),n}function $(e,t){const n=T[e];if(!n)return{};const o={};for(const[s,i]of Object.entries(n))if(!i.dependencies||i.dependencies.includes(t))try{const n=i.computeFn();i.lastValue=n,o[s]=n,S("Recomputed dependent variable",{componentId:e,varName:s,changedStateKey:t,value:n})}catch(e){console.error(`[ClientComputed] Error recomputing '${s}':`,e),o[s]=void 0}return o}function R(e){return!!T[e]&&Object.keys(T[e]).length>0}class E{constructor(e,t,n,o,s={}){this.taskId=e,this.componentId=t,this.signalR=n,this.context=o,this.status="idle",this.progress=0,this.chunks=[],this.chunkCount=0,this._options=s,this.streaming=s.stream||!1,this._createPromise()}_createPromise(){this._promise=new Promise((e,t)=>{this._resolve=e,this._reject=t})}get promise(){return this._promise}get idle(){return"idle"===this.status}get running(){return"running"===this.status}get complete(){return"complete"===this.status}get failed(){return"error"===this.status}get cancelled(){return"cancelled"===this.status}start(...e){this.status="running",this.startedAt=new Date,this.completedAt=void 0,this.progress=0,this.error=void 0,this.streaming?(this.chunks=[],this.chunkCount=0,this.partial=void 0):this.result=void 0,this._triggerRerender(),this.signalR.invoke("StartServerTask",this.componentId,this.taskId,e||[]).catch(e=>{console.error(`[Minimact] Failed to start task ${this.taskId}:`,e),this.status="error",this.error=e,this.completedAt=new Date,this.duration=this.completedAt.getTime()-(this.startedAt?.getTime()||0),this._reject?.(e),this._triggerRerender()})}retry(...e){"error"===this.status||"cancelled"===this.status?(this._createPromise(),this.status="running",this.startedAt=new Date,this.completedAt=void 0,this.progress=0,this.error=void 0,this.streaming?(this.chunks=[],this.chunkCount=0,this.partial=void 0):this.result=void 0,this._triggerRerender(),this.signalR.invoke("RetryServerTask",this.componentId,this.taskId,e||[]).catch(e=>{console.error(`[Minimact] Failed to retry task ${this.taskId}:`,e),this.status="error",this.error=e,this.completedAt=new Date,this.duration=this.completedAt.getTime()-(this.startedAt?.getTime()||0),this._reject?.(e),this._triggerRerender()})):console.warn("[Minimact] Can only retry failed or cancelled tasks")}cancel(){"running"===this.status?this.signalR.invoke("CancelServerTask",this.componentId,this.taskId).then(()=>{this.status="cancelled",this.completedAt=new Date,this.duration=this.completedAt.getTime()-(this.startedAt?.getTime()||0),this._reject?.(new Error("Task cancelled by user")),this._triggerRerender()}).catch(e=>{console.error(`[Minimact] Failed to cancel task ${this.taskId}:`,e)}):console.warn("[Minimact] Can only cancel running tasks")}_updateFromServer(e){const t=this.status;this.status=e.status,this.progress=e.progress||0,this.result=e.result,e.error&&(this.error=new Error(e.error)),e.startedAt&&(this.startedAt=new Date(e.startedAt)),e.completedAt&&(this.completedAt=new Date(e.completedAt)),e.duration&&(this.duration=e.duration),"complete"===this.status&&"complete"!==t?this._resolve&&this._resolve(this.result):"error"===this.status&&"error"!==t?this._reject&&this._reject(this.error):"cancelled"===this.status&&"cancelled"!==t&&this._reject&&this._reject(new Error("Task cancelled")),t===this.status&&this.progress===e.progress||this._triggerRerender()}_triggerRerender(){if(!this.context||!this.context.hintQueue)return;const e={[this.taskId]:{status:this.status,progress:this.progress,chunkCount:this.chunkCount}},t=this.context.hintQueue.matchHint(this.context.componentId,e);t?(console.log(`[Minimact] üü¢ Task state change predicted! Applying ${t.patches.length} patches`),this.context.domPatcher.applyPatches(this.context.element,t.patches)):console.log("[Minimact] üî¥ Task state change not predicted")}}class x{constructor(e,t,n,o,s){this.reducerId=e,this.componentId=t,this.signalR=n,this.context=o,this.dispatching=!1,this.state=s}dispatch(e){this.dispatching=!0,this.error=void 0,this.lastDispatchedAt=new Date,e&&"object"==typeof e&&"type"in e&&(this.lastActionType=String(e.type)),this._triggerRerender(),this.signalR.invoke("DispatchServerReducer",this.componentId,this.reducerId,e).catch(e=>{console.error(`[Minimact] Failed to dispatch action to reducer ${this.reducerId}:`,e),this.dispatching=!1,this.error=e,this._triggerRerender()})}dispatchAsync(e){return this.dispatching=!0,this.error=void 0,this.lastDispatchedAt=new Date,e&&"object"==typeof e&&"type"in e&&(this.lastActionType=String(e.type)),this._pendingPromise=new Promise((e,t)=>{this._pendingResolve=e,this._pendingReject=t}),this._triggerRerender(),this.signalR.invoke("DispatchServerReducer",this.componentId,this.reducerId,e).catch(e=>{console.error(`[Minimact] Failed to dispatch action to reducer ${this.reducerId}:`,e),this.dispatching=!1,this.error=e,this._pendingReject?.(e),this._triggerRerender()}),this._pendingPromise}_updateFromServer(e,t){const n=this.state;this.state=e,this.dispatching=!1,t?(this.error=new Error(t),this._pendingReject?.(this.error)):(this.error=void 0,this._pendingResolve?.(e)),this._pendingPromise=void 0,this._pendingResolve=void 0,this._pendingReject=void 0,n!==e&&this._triggerRerender()}_triggerRerender(){if(!this.context||!this.context.hintQueue)return;const e={[this.reducerId]:{state:this.state,dispatching:this.dispatching,error:this.error?.message}},t=this.context.hintQueue.matchHint(this.context.componentId,e);t?(console.log(`[Minimact] üü¢ Reducer state change predicted! Applying ${t.patches.length} patches`),this.context.domPatcher.applyPatches(this.context.element,t.patches)):console.log("[Minimact] üî¥ Reducer state change not predicted")}}let A=null,P=null,k=0,H=0,N=0,L=0,O=0;function D(e,t){if(""===t||"."===t)return e;let n=e;const o=t.split(".").map(e=>parseInt(e,16));for(const e of o){if(!n||!n.childNodes)return null;n=n.childNodes[e]||null}return n}function F(e,t){return e.map(e=>`${e}:${!!t[e]}`).sort().join(",")}function _(e){if(!P)throw new Error("useState must be called within a component render");const t=P,n="state_"+k++;t.state.has(n)||t.state.set(n,e);const o=t.state.get(n),s=e=>{const o=performance.now(),s="function"==typeof e?e(t.state.get(n)):e,i={[n]:s},r=t.hintQueue.matchHint(t.componentId,i);if(r){const e=performance.now()-o;console.log(`[Minimact] üü¢ CACHE HIT! Hint '${r.hintId}' matched - applying ${r.patches.length} patches in ${e.toFixed(2)}ms`),t.domPatcher.applyPatches(t.element,r.patches),t.playgroundBridge&&t.playgroundBridge.cacheHit({componentId:t.componentId,hintId:r.hintId,latency:e,confidence:r.confidence,patchCount:r.patches.length})}else{const e=performance.now()-o;console.log("[Minimact] üî¥ CACHE MISS - No prediction for state change:",i),t.playgroundBridge&&t.playgroundBridge.cacheMiss({componentId:t.componentId,methodName:`setState(${n})`,latency:e,patchCount:0})}t.state.set(n,s),y.updateState(t.componentId,n,s);const a=y.getTemplatesBoundTo(t.componentId,n);for(const e of a){const o=e.path.replace(/\./g,"_"),s=y.render(t.componentId,o);if(null!==s){const o=D(t.element,e.path);o&&(o.nodeType===Node.TEXT_NODE?o.textContent=s:o instanceof HTMLElement&&(e.attribute?o.setAttribute(e.attribute,s):o.textContent=s),console.log(`[Minimact] üìã Template updated: "${s}" (${n} changed)`))}}const c=y.getConditionalElementsBoundTo(t.componentId,n);if(c.length>0){const e=y.getAllComponentState(t.componentId);for(const{template:o}of c)if(o.evaluable)try{let s;if(o.pathVariants){const t=F(o.conditionBindings||[],e);if(s=o.pathVariants[t]??void 0,!s){console.log(`[Minimact] No path variant for state ${t}, skipping conditional`);continue}console.log(`[Minimact] üéØ Using simulated DOM indices [${s.join(", ")}] for state ${t}`)}else{if(!o.domPath){console.warn("[Minimact] No path information available for conditional template");continue}s=o.domPath,console.warn("[Minimact] Using deprecated domPath for conditional template (should use pathVariants)")}let i=t.element;for(let e=0;e<s.length-1;e++)i=i.childNodes[s[e]];const r=s[s.length-1];t.conditionalRenderer.render(o,e,i,r),console.log(`[Minimact] üîÄ Conditional element updated at DOM indices [${s.join(", ")}] (${n} changed)`)}catch(e){console.error("[Minimact] Failed to render conditional element:",e)}}t.signalR.updateComponentState(t.componentId,n,s).catch(e=>{console.error("[Minimact] Failed to sync state to server:",e)})};return Array.isArray(o)?[o,V(s,o,n,t)]:[o,s]}function U(e,t){if(!P)throw new Error("useEffect must be called within a component render");const n=P,o=H++;if(n.effects[o]){const s=n.effects[o];(!t||!s.deps||t.length!==s.deps.length||t.some((e,t)=>e!==s.deps[t]))&&(s.cleanup&&s.cleanup(),s.callback=e,s.deps=t,queueMicrotask(()=>{const t=e();"function"==typeof t&&(s.cleanup=t)}))}else n.effects[o]={callback:e,deps:t,cleanup:void 0},queueMicrotask(()=>{const t=e();"function"==typeof t&&(n.effects[o].cleanup=t)})}function j(e){if(!P)throw new Error("useRef must be called within a component render");const t=P,n="ref_"+N++;return t.refs.has(n)||t.refs.set(n,{current:e}),t.refs.get(n)}function V(e,t,n,o){const s=e;return s.append=e=>{const s=[...t,e];o.state.set(n,s),y.updateState(o.componentId,n,s),o.signalR.updateComponentStateWithOperation(o.componentId,n,s,{type:"Append",item:e}).catch(e=>{console.error("[Minimact] Failed to sync array append to server:",e)}),console.log(`[Minimact] üîµ Array append: ${n}`,e)},s.prepend=e=>{const s=[e,...t];o.state.set(n,s),y.updateState(o.componentId,n,s),o.signalR.updateComponentStateWithOperation(o.componentId,n,s,{type:"Prepend",item:e}).catch(e=>{console.error("[Minimact] Failed to sync array prepend to server:",e)}),console.log(`[Minimact] üîµ Array prepend: ${n}`,e)},s.insertAt=(e,s)=>{const i=[...t];i.splice(e,0,s),o.state.set(n,i),y.updateState(o.componentId,n,i),o.signalR.updateComponentStateWithOperation(o.componentId,n,i,{type:"InsertAt",index:e,item:s}).catch(e=>{console.error("[Minimact] Failed to sync array insert to server:",e)}),console.log(`[Minimact] üîµ Array insertAt(${e}): ${n}`,s)},s.removeAt=e=>{const s=t.filter((t,n)=>n!==e);o.state.set(n,s),y.updateState(o.componentId,n,s),o.signalR.updateComponentStateWithOperation(o.componentId,n,s,{type:"RemoveAt",index:e}).catch(e=>{console.error("[Minimact] Failed to sync array remove to server:",e)}),console.log(`[Minimact] üîµ Array removeAt(${e}): ${n}`)},s.updateAt=(e,s)=>{const i=[...t];i[e]="function"==typeof s?s(t[e]):{...t[e],...s},o.state.set(n,i),y.updateState(o.componentId,n,i),o.signalR.updateComponentStateWithOperation(o.componentId,n,i,{type:"UpdateAt",index:e,item:i[e]}).catch(e=>{console.error("[Minimact] Failed to sync array update to server:",e)}),console.log(`[Minimact] üîµ Array updateAt(${e}): ${n}`,i[e])},s.clear=()=>{e([])},s.removeWhere=n=>{const o=t.filter(e=>!n(e));e(o)},s.updateWhere=(n,o)=>{const s=t.map(e=>n(e)?{...e,...o}:e);e(s)},s.appendMany=n=>{const o=[...t,...n];e(o)},s.removeMany=n=>{const o=t.filter((e,t)=>!n.includes(t));e(o)},s}function B(e,t={}){if(!P)throw new Error("useServerTask must be called within a component render");const n=P,o="serverTask_"+L++;if(n.serverTasks||(n.serverTasks=new Map),!n.serverTasks.has(o)){const e=new E(o,n.componentId,n.signalR,n,t);n.serverTasks.set(o,e)}return n.serverTasks.get(o)}const W=new Proxy({},{get(e,t){throw new Error(`[Minimact] 'state' is a compile-time construct and should not execute at runtime.\nKey accessed: "${String(t)}"\n\nThis error means:\n1. The Babel plugin (babel-plugin-minimact) is not configured correctly\n2. You're trying to use 'state' in a non-component context\n3. The file was not transpiled through the Minimact build pipeline\n\nSolution: Ensure babel-plugin-minimact is properly configured in your build.`)},set(e,t,n){throw new Error(`[Minimact] Cannot set state directly using 'state.${String(t)} = value'.\nUse setState('${String(t)}', value) instead.`)},has(e,t){throw new Error(`[Minimact] 'state' proxy should not be used with 'in' operator at runtime.\nKey checked: "${String(t)}"\nUse hasState('${String(t)}') method instead.`)}});let K=null;class z{constructor(e={}){this.channels=new Map,this.debugLogging=!1,this.debugLogging=e.debugLogging||!1}subscribe(e,t){this.channels.has(e)||this.channels.set(e,{subscribers:new Set,lastMessage:null});const n=this.channels.get(e);t&&n.subscribers.add(t);const o=n.lastMessage||{value:void 0,timestamp:Date.now()};return this.log(`Subscribed to '${e}'`,{hasCallback:!!t}),o}unsubscribe(e,t){const n=this.channels.get(e);n&&(n.subscribers.delete(t),this.log(`Unsubscribed from '${e}'`))}publish(e,t,n={}){this.channels.has(e)||this.channels.set(e,{subscribers:new Set,lastMessage:null});const o=this.channels.get(e),s={value:t,error:n.error,waiting:n.waiting,source:n.source,timestamp:Date.now(),isStale:!1};o.lastMessage=s,o.subscribers.forEach(t=>{try{t(s)}catch(t){console.error(`[Minimact PubSub] Error in subscriber for '${e}':`,t)}}),this.log(`Published to '${e}'`,{subscribers:o.subscribers.size,value:t})}clear(e){this.channels.delete(e),this.log(`Cleared channel '${e}'`)}clearAll(){this.channels.clear(),this.log("Cleared all channels")}getStats(){return{totalChannels:this.channels.size,channels:Array.from(this.channels.entries()).map(([e,t])=>({name:e,subscribers:t.subscribers.size,hasLastMessage:!!t.lastMessage}))}}log(e,t){this.debugLogging&&console.log(`[Minimact PubSub] ${e}`,t||"")}}let q=null;function J(e){return q||(q=new z(e)),q}class Q{constructor(e=document.body,t={}){if(this.hotReload=null,this.eventDelegation=null,"string"==typeof e){const t=document.querySelector(e);if(!t)throw new Error(`[Minimact] Root element not found: ${e}`);this.rootElement=t}else this.rootElement=e;var n;this.options={hubUrl:t.hubUrl||"/minimact",enableDebugLogging:t.enableDebugLogging||!1,reconnectInterval:t.reconnectInterval||5e3,enableHotReload:!1!==t.enableHotReload,hotReloadWsUrl:t.hotReloadWsUrl},this.signalR=new a(this.options.hubUrl,{reconnectInterval:this.options.reconnectInterval,debugLogging:this.options.enableDebugLogging}),this.domPatcher=new c({debugLogging:this.options.enableDebugLogging}),this.clientState=new l({debugLogging:this.options.enableDebugLogging}),this.hydration=new h(this.clientState,{debugLogging:this.options.enableDebugLogging}),this.hintQueue=new m({debugLogging:this.options.enableDebugLogging}),this.playgroundBridge=new u({debugLogging:this.options.enableDebugLogging}),this.componentRegistry=new w,this.conditionalRenderer=new C,this.options.enableHotReload&&(this.hotReload=new b(this,{enabled:!0,wsUrl:this.options.hotReloadWsUrl,debounceMs:50,showNotifications:!0,logLevel:this.options.enableDebugLogging?"debug":"info"})),n=this.options.enableDebugLogging,I=n,this.log("Minimact initialized",{rootElement:this.rootElement,options:this.options})}async start(){this.setupSignalRHandlers(),await this.signalR.start(),this.hydration.hydrateAll(),console.log("[Minimact] üîç Registering hydrated components..."),this.registerHydratedComponents(),console.log("[Minimact] üìä Registry stats:",this.componentRegistry.getStats()),this.eventDelegation=new d(this.rootElement,(e,t,n)=>this.signalR.invokeComponentMethod(e,t,n),{debugLogging:this.options.enableDebugLogging}),await this.registerAllComponents(),this.log("Minimact started")}async stop(){this.eventDelegation&&(this.eventDelegation.destroy(),this.eventDelegation=null),await this.signalR.stop(),this.log("Minimact stopped")}setupSignalRHandlers(){this.signalR.on("updateComponent",({componentId:e,html:t})=>{const n=this.hydration.getComponent(e);n&&(this.domPatcher.replaceHTML(n.element,t),this.log("Component HTML updated",{componentId:e}))}),this.signalR.on("applyPatches",({componentId:e,patches:t})=>{const n=this.hydration.getComponent(e);n&&(this.domPatcher.applyPatches(n.element,t),this.log("Patches applied",{componentId:e,patchCount:t.length}))}),this.signalR.on("applyPrediction",({componentId:e,patches:t,confidence:n})=>{const o=this.hydration.getComponent(e);o&&(this.domPatcher.applyPatches(o.element,t),this.log(`Prediction applied (${(100*n).toFixed(0)}% confident)`,{componentId:e,patchCount:t.length}))}),this.signalR.on("applyCorrection",({componentId:e,patches:t})=>{const n=this.hydration.getComponent(e);n&&(this.domPatcher.applyPatches(n.element,t),this.log("Correction applied (prediction was incorrect)",{componentId:e,patchCount:t.length}))}),this.signalR.on("queueHint",e=>{this.hintQueue.queueHint(e),this.log(`Hint '${e.hintId}' queued for component ${e.componentId}`,{patchCount:e.patches.length,confidence:(100*e.confidence).toFixed(0)+"%"}),this.playgroundBridge.predictionReceived({componentId:e.componentId,hintId:e.hintId,patchCount:e.patches.length,confidence:e.confidence})}),this.signalR.on("reconnected",async()=>{this.log("Reconnected - re-registering components"),await this.registerAllComponents()}),this.signalR.on("UpdateServerReducerState",({componentId:e,reducerId:t,state:n,error:o})=>{const s=this.hydration.getComponent(e);if(s&&s.context.serverReducers){const i=s.context.serverReducers.get(t);i&&(i._updateFromServer(n,o),this.log("Server reducer state updated",{componentId:e,reducerId:t}))}}),this.signalR.on("HotReload:TemplateMap",e=>{console.log("[Minimact] üì® HotReload:TemplateMap received:",e),console.log("[Minimact] üîç HotReload manager exists?",!!this.hotReload),this.hotReload?(this.log("Received template map",{componentId:e.componentId}),this.hotReload.handleMessage({type:"template-map",...e})):console.warn("[Minimact] ‚ö†Ô∏è HotReload manager not initialized, cannot process template map")}),this.signalR.on("HotReload:TemplatePatch",e=>{this.hotReload&&(this.log("Received template patch",{componentId:e.componentId}),this.hotReload.handleMessage({type:"template-patch",...e}))}),this.signalR.on("HotReload:FileChange",e=>{this.hotReload&&(this.log("Received file change",{componentId:e.componentId}),this.hotReload.handleMessage({type:"file-change",...e}))}),this.signalR.on("HotReload:Error",e=>{this.hotReload&&console.error("[Minimact Hot Reload] Error:",e.error)}),this.signalR.on("error",({message:e})=>{console.error("[Minimact] Server error:",e)})}async registerAllComponents(){const e=document.querySelectorAll("[data-minimact-component]");for(const t of Array.from(e)){const e=t.getAttribute("data-minimact-component");if(e)try{await this.signalR.registerComponent(e),this.log("Registered component",{componentId:e})}catch(t){console.error("[Minimact] Failed to register component:",e,t)}}}hydrateComponent(e,t){this.hydration.hydrateComponent(e,t)}getComponent(e){return this.hydration.getComponent(e)}registerHydratedComponents(){const e=window.__MINIMACT_VIEWMODEL__;if(!e||!e._componentType||!e._componentId)return void console.warn("[Minimact] ViewModel metadata missing _componentType or _componentId");const t=e._componentType,n=e._componentId,o=document.querySelector(`[data-minimact-component-id="${n}"]`);if(!o)return void console.warn(`[Minimact] Component element not found for ${n}`);const s=this.hydration.getComponent(n);s?(s.type=t,this.componentRegistry.register({type:t,instanceId:n,element:o,context:s.context}),console.log(`[Minimact] Registered ${t} (${n.substring(0,8)}...) in registry`)):console.warn(`[Minimact] Component not hydrated for ${n}`)}getClientState(e,t){return this.clientState.getState(e,t)}setClientState(e,t,n){this.clientState.setState(e,t,n),this.recomputeAndSyncClientState(e,t)}subscribeToState(e,t,n){return this.clientState.subscribe(e,t,n)}async recomputeAndSyncClientState(e,t){if(!R(e))return;const n=t?$(e,t):M(e);if(Object.keys(n).length>0)try{await this.signalR.updateClientComputedState(e,n),this.log("Client-computed state synced",{componentId:e,computed:n})}catch(e){console.error("[Minimact] Failed to sync client-computed state:",e)}}get connectionState(){return this.signalR.state.toString()}get connectionId(){return this.signalR.connectionId}log(e,t){this.options.enableDebugLogging&&console.log(`[Minimact] ${e}`,t||"")}}if("undefined"!=typeof window)if("loading"===document.readyState)document.addEventListener("DOMContentLoaded",()=>{if(document.body.hasAttribute("data-minimact-auto-init")){const e=new Q(document.body,{enableDebugLogging:document.body.hasAttribute("data-minimact-debug")});e.start().catch(console.error),window.minimact=e}});else if(document.body.hasAttribute("data-minimact-auto-init")){const e=new Q(document.body,{enableDebugLogging:document.body.hasAttribute("data-minimact-debug")});e.start().catch(console.error),window.minimact=e}return"undefined"!=typeof window&&(window.Minimact=Q),e.ClientStateManager=l,e.ConditionalElementRenderer=C,e.DOMPatcher=c,e.EventDelegation=d,e.HintQueue=m,e.HotReloadManager=b,e.HydrationManager=h,e.Minimact=Q,e.MinimactComponentRegistry=w,e.SignalMManager=a,e.TemplateRenderer=p,e.TemplateStateManager=f,e.clearClientComputedComponent=function(e){delete T[e],S("Cleared component",{componentId:e})},e.clearComponentContext=function(){P=null},e.clearContextHookContext=function(){K=null},e.computeAllForComponent=M,e.computeDependentVariables=$,e.computeVariable=function(e,t){const n=T[e]?.[t];if(n)try{const o=n.computeFn();return n.lastValue=o,S("Computed variable",{componentId:e,varName:t,value:o}),o}catch(e){return void console.error(`[ClientComputed] Error computing '${t}':`,e)}else console.warn(`[ClientComputed] Variable '${t}' not registered for component '${e}'`)},e.createContext=function(e,t={}){if("url"===t.scope&&!t.urlPattern)throw new Error(`Context '${e}' with scope 'url' requires urlPattern`);return{key:e,options:{scope:t.scope||"request",urlPattern:t.urlPattern,expiry:t.expiry,defaultValue:t.defaultValue}}},e.default=Q,e.getAllLastValues=function(e){const t=T[e];if(!t)return{};const n={};for(const[e,o]of Object.entries(t))n[e]=o.lastValue;return n},e.getClientComputedDebugInfo=function(){const e={};for(const[t,n]of Object.entries(T)){const o=Object.keys(n);e[t]={variableCount:o.length,variables:o}}return{componentCount:Object.keys(T).length,components:e}},e.getComputedVariableNames=function(e){const t=T[e];return t?Object.keys(t):[]},e.getLastValue=function(e,t){return T[e]?.[t]?.lastValue},e.hasClientComputed=R,e.registerClientComputed=function(e,t,n,o){T[e]||(T[e]={}),T[e][t]={varName:t,computeFn:n,dependencies:o},S("Registered client-computed variable",{componentId:e,varName:t,dependencies:o})},e.setComponentContext=function(e){P=e,k=0,H=0,N=0,L=0,O=0,function(e){A=e}(e)},e.setContextHookContext=function(e){K=e},e.setState=function(e,t){throw new Error(`[Minimact] 'setState' is a compile-time construct and should not execute at runtime.\nKey: "${e}", Value: ${JSON.stringify(t)}\n\nThis error means:\n1. The Babel plugin (babel-plugin-minimact) is not configured correctly\n2. You're trying to use 'setState' in a non-component context\n3. The file was not transpiled through the Minimact build pipeline\n\nSolution: Ensure babel-plugin-minimact is properly configured in your build.`)},e.state=W,e.templateState=y,e.useAnimationFrame=function(e){return requestAnimationFrame(t=>{try{e(t)}catch(e){console.error("[Minimact useAnimationFrame] Error in animation frame:",e)}})},e.useComputed=function(e,t,n=[],o={}){if(!A)throw new Error("[Minimact] useComputed must be called within a component render");const{memoize:s=!0,expiry:i,debounce:r,throttle:a,initialValue:c}=o,l=A,[d,h]=_(void 0!==c?c:null),p=j(null),m=j(null);function u(t){const n=()=>{l.signalR?l.signalR.updateClientComputedState(l.componentId,{[e]:t}).catch(t=>{console.error(`[Minimact] Failed to sync computed state '${e}':`,t)}):console.warn(`[Minimact] SignalR not available, cannot sync useComputed('${e}')`)};if(r)return null!==m.current&&clearTimeout(m.current),void(m.current=window.setTimeout(()=>{n(),m.current=null},r));n()}return U(()=>{if(s&&p.current&&n.length===p.current.deps.length&&!n.some((e,t)=>!Object.is(e,p.current.deps[t]))){if(!i)return;if(Date.now()-p.current.timestamp<i)return}let o;try{o=t()}catch(t){throw console.error(`[Minimact] Error in useComputed('${e}'):`,t),t}o instanceof Promise?o.then(e=>{s&&(p.current={value:e,timestamp:Date.now(),deps:[...n]}),h(e),u(e)}).catch(t=>{console.error(`[Minimact] Async error in useComputed('${e}'):`,t)}):(s&&(p.current={value:o,timestamp:Date.now(),deps:[...n]}),h(o),u(o))},n),d},e.useContext=function(e){if(!K)throw new Error("[Minimact] useContext must be called within a component render");const t=K,n=`context_${e.key}`;let o=t.state.get(n);return void 0===o&&void 0!==e.options.defaultValue&&(o=e.options.defaultValue),[o,o=>{t.state.set(n,o);const s={[n]:o},i=t.hintQueue.matchHint(t.componentId,s);i&&t.domPatcher.applyPatches(t.element,i.patches),t.signalR.invoke("UpdateContext",{key:e.key,value:o,scope:e.options.scope,urlPattern:e.options.urlPattern,expiry:e.options.expiry}).catch(t=>{console.error(`[Minimact] Failed to update context '${e.key}':`,t)})},()=>{t.state.set(n,void 0);const o={[n]:void 0},s=t.hintQueue.matchHint(t.componentId,o);s&&t.domPatcher.applyPatches(t.element,s.patches),t.signalR.invoke("ClearContext",{key:e.key,scope:e.options.scope,urlPattern:e.options.urlPattern}).catch(t=>{console.error(`[Minimact] Failed to clear context '${e.key}':`,t)})}]},e.useEffect=U,e.useIdleCallback=function(e,t){return"requestIdleCallback"in window?requestIdleCallback(t=>{try{e(t)}catch(e){console.error("[Minimact useIdleCallback] Error in idle callback:",e)}},t):setTimeout(()=>{e({didTimeout:!1,timeRemaining:()=>50})},1)},e.useMacroTask=function(e,t=0){setTimeout(()=>{try{e()}catch(e){console.error("[Minimact useMacroTask] Error in macrotask:",e)}},t)},e.useMarkdown=function(e){return _(e)},e.useMicroTask=function(e){queueMicrotask(()=>{try{e()}catch(e){console.error("[Minimact useMicroTask] Error in microtask:",e)}})},e.usePaginatedServerTask=function(e,t){const n=t.pageSize||20,[o,s]=_(1),[i,r]=_([]),[a,c]=_(0),[l,d]=_(null),h=j(new Map),p=j([]),m=(b=t.dependencies)&&0!==b.length?1===b.length&&"object"==typeof b[0]?b[0]:b.reduce((e,t,n)=>(e[`dep${n}`]=t,e),{}):{},u=B(0,{runtime:t.runtime,parallel:t.parallel}),g=B(0,{runtime:t.runtime}),f=async(e,o=!0)=>{if(o&&h.current.has(e)){const n=h.current.get(e);return r(n),s(e),h.current.delete(e),console.log(`[usePaginatedServerTask] üü¢ Cache hit for page ${e}`),t.prefetchNext&&e<v&&y(e+1),void(t.prefetchPrev&&e>1&&y(e-1))}const i={page:e,pageSize:n,filters:m};p.current=[i],u.start(i);try{const n=await u.promise;r(n),s(e),d(null),console.log(`[usePaginatedServerTask] üî¥ Fetched page ${e} from server`),t.prefetchNext&&e<v&&y(e+1),t.prefetchPrev&&e>1&&y(e-1)}catch(t){d(t.message||"Failed to fetch page"),console.error(`[usePaginatedServerTask] Error fetching page ${e}:`,t)}},y=async e=>{if(h.current.has(e))return;const t={page:e,pageSize:n,filters:m};u.start(t);try{const t=await u.promise;h.current.set(e,t),console.log(`[usePaginatedServerTask] ‚ö° Prefetched page ${e}`)}catch(t){console.error(`[usePaginatedServerTask] Prefetch failed for page ${e}:`,t)}};var b;U(()=>{g.start(m),g.promise.then(e=>{c(e)}).catch(e=>{console.error("[usePaginatedServerTask] Failed to get total count:",e)})},[JSON.stringify(m)]),U(()=>{f(1,!1)},[]),U(()=>{t.dependencies&&t.dependencies.length>0&&(h.current.clear(),f(1,!1))},[JSON.stringify(m)]);const v=Math.ceil(a/n),w=o<v,C=o>1;return{items:i,total:a,totalPages:v,page:o,pageSize:n,pending:"running"===u.status,error:l||u.error?.message,hasNext:w,hasPrev:C,next:()=>{w&&f(o+1)},prev:()=>{C&&f(o-1)},goto:e=>{e>=1&&e<=v&&f(e)},refresh:()=>{h.current.clear(),f(o,!1)},_fetchTask:u,_countTask:g}},e.useProtectedState=function(e){return _(e)},e.usePub=function(e){const t=J();return(n,o={})=>{t.publish(e,n,o)}},e.useRef=j,e.useServerReducer=function(e){if(!P)throw new Error("useServerReducer must be called within a component render");const t=P,n="serverReducer_"+O++;if(t.serverReducers||(t.serverReducers=new Map),!t.serverReducers.has(n)){const o=new x(n,t.componentId,t.signalR,t,e);t.serverReducers.set(n,o)}return t.serverReducers.get(n)},e.useServerTask=B,e.useSignalR=function(e,t,n={}){const o=new a(e,{reconnectInterval:n.reconnectInterval,debugLogging:n.debugLogging}),s={data:null,error:null,connected:!1,connectionId:null};return o.on("connected",({connectionId:e})=>{s.connected=!0,s.connectionId=e||null,s.error=null}),o.on("reconnected",({connectionId:e})=>{s.connected=!0,s.connectionId=e||null,s.error=null}),o.on("closed",({error:e})=>{s.connected=!1,s.connectionId=null,e&&(s.error=e.toString())}),o.on("error",({message:e})=>{s.error=e}),t&&o.on("message",e=>{s.data=e,t(e)}),!1!==n.autoConnect&&o.start().catch(e=>{s.error=e.message,console.error("[Minimact useSignalR] Auto-connect failed:",e)}),{state:s,send:async(e,...t)=>{try{await o.invoke(e,...t)}catch(e){throw s.error=e.message,e}},on:(e,t)=>{o.on(e,t)},off:(e,t)=>{o.off(e,t)},connect:async()=>{await o.start()},disconnect:async()=>{await o.stop()}}},e.useState=_,e.useSub=function(e,t){return J().subscribe(e,t)},Object.defineProperty(e,"__esModule",{value:!0}),e}({});
//# sourceMappingURL=core.min.js.map
