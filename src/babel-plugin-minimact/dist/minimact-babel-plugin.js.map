{"version":3,"file":"minimact-babel-plugin.js","sources":["../src/utils/helpers.cjs","../src/types/typeConversion.cjs","../src/analyzers/dependencies.cjs","../src/analyzers/classification.cjs","../src/analyzers/detection.cjs","../src/extractors/eventHandlers.cjs","../src/generators/jsx.cjs","../src/generators/runtimeHelpers.cjs","../src/generators/expressions.cjs","../src/extractors/hooks.cjs","../src/extractors/localVariables.cjs","../src/analyzers/propTypeInference.cjs","../src/extractors/templates.cjs","../src/extractors/loopTemplates.cjs","../src/extractors/structuralTemplates.cjs","../src/extractors/expressionTemplates.cjs","../src/processComponent.cjs","../src/generators/renderBody.cjs","../src/transpilers/typescriptToCSharp.cjs","../src/generators/serverTask.cjs","../src/generators/component.cjs","../src/generators/csharpFile.cjs","../index-full.cjs"],"sourcesContent":["/**\r\n * Utility Helpers\r\n *\r\n * General utility functions used throughout the plugin.\r\n *\r\n * Functions to move:\r\n * - escapeCSharpString(str) - Escapes special characters for C# strings\r\n * - getComponentName(path) - Extracts component name from function/class declaration\r\n *\r\n * Utilities:\r\n * - escapeCSharpString: Handles \\, \", \\n, \\r, \\t escaping\r\n * - getComponentName: Supports FunctionDeclaration, ArrowFunctionExpression, etc.\r\n *\r\n * Returns processed string or component name\r\n */\r\n\r\n// TODO: Move the following functions here:\r\n// - escapeCSharpString\r\n// - getComponentName\r\n\r\n/**\r\n * Escape C# string\r\n */\r\nfunction escapeCSharpString(str) {\r\n  return str\r\n    .replace(/\\\\/g, '\\\\\\\\')\r\n    .replace(/\"/g, '\\\\\"')\r\n    .replace(/\\n/g, '\\\\n')\r\n    .replace(/\\r/g, '\\\\r')\r\n    .replace(/\\t/g, '\\\\t');\r\n}\r\n\r\n/**\r\n * Get component name from path\r\n */\r\nfunction getComponentName(path) {\r\n  if (path.node.id) {\r\n    return path.node.id.name;\r\n  }\r\n\r\n  if (path.parent.type === 'VariableDeclarator') {\r\n    return path.parent.id.name;\r\n  }\r\n\r\n  if (path.parent.type === 'ExportNamedDeclaration') {\r\n    return path.node.id ? path.node.id.name : null;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  escapeCSharpString,\r\n  getComponentName,\r\n};\r\n","/**\r\n * Type Conversion\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Convert TypeScript type annotation to C# type\r\n */\r\nfunction tsTypeToCSharpType(tsType) {\r\n  if (!tsType) return 'dynamic';\r\n\r\n  // TSStringKeyword -> string\r\n  if (t.isTSStringKeyword(tsType)) return 'string';\r\n\r\n  // TSNumberKeyword -> double\r\n  if (t.isTSNumberKeyword(tsType)) return 'double';\r\n\r\n  // TSBooleanKeyword -> bool\r\n  if (t.isTSBooleanKeyword(tsType)) return 'bool';\r\n\r\n  // TSAnyKeyword -> dynamic\r\n  if (t.isTSAnyKeyword(tsType)) return 'dynamic';\r\n\r\n  // TSArrayType -> List<T>\r\n  if (t.isTSArrayType(tsType)) {\r\n    const elementType = tsTypeToCSharpType(tsType.elementType);\r\n    return `List<${elementType}>`;\r\n  }\r\n\r\n  // TSTypeLiteral (object type) -> dynamic\r\n  if (t.isTSTypeLiteral(tsType)) return 'dynamic';\r\n\r\n  // TSTypeReference (custom types, interfaces) -> dynamic\r\n  if (t.isTSTypeReference(tsType)) return 'dynamic';\r\n\r\n  // Default to dynamic for full JSX semantics\r\n  return 'dynamic';\r\n}\r\n\r\n/**\r\n * Infer C# type from initial value\r\n */\r\nfunction inferType(node) {\r\n  if (!node) return 'dynamic';\r\n\r\n  if (t.isStringLiteral(node)) return 'string';\r\n  if (t.isNumericLiteral(node)) return 'int';\r\n  if (t.isBooleanLiteral(node)) return 'bool';\r\n  if (t.isNullLiteral(node)) return 'dynamic';\r\n  if (t.isArrayExpression(node)) return 'List<dynamic>';\r\n  if (t.isObjectExpression(node)) return 'dynamic';\r\n\r\n  return 'dynamic';\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  inferType,\r\n  tsTypeToCSharpType\r\n};\r\n","/**\r\n * Dependency Analyzer\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Analyze dependencies in JSX expressions\r\n * Walk the AST manually to find identifier dependencies\r\n */\r\nfunction analyzeDependencies(jsxExpr, component) {\r\n  const deps = new Set();\r\n\r\n  function walk(node) {\r\n    if (!node) return;\r\n\r\n    // Check if this is an identifier that's a state variable\r\n    if (t.isIdentifier(node)) {\r\n      const name = node.name;\r\n      if (component.stateTypes.has(name)) {\r\n        deps.add({\r\n          name: name,\r\n          type: component.stateTypes.get(name) // 'client' or 'server'\r\n        });\r\n      }\r\n    }\r\n\r\n    // Recursively walk the tree\r\n    if (t.isConditionalExpression(node)) {\r\n      walk(node.test);\r\n      walk(node.consequent);\r\n      walk(node.alternate);\r\n    } else if (t.isLogicalExpression(node)) {\r\n      walk(node.left);\r\n      walk(node.right);\r\n    } else if (t.isMemberExpression(node)) {\r\n      walk(node.object);\r\n      walk(node.property);\r\n    } else if (t.isCallExpression(node)) {\r\n      walk(node.callee);\r\n      node.arguments.forEach(walk);\r\n    } else if (t.isBinaryExpression(node)) {\r\n      walk(node.left);\r\n      walk(node.right);\r\n    } else if (t.isUnaryExpression(node)) {\r\n      walk(node.argument);\r\n    } else if (t.isArrowFunctionExpression(node) || t.isFunctionExpression(node)) {\r\n      walk(node.body);\r\n    }\r\n  }\r\n\r\n  walk(jsxExpr);\r\n  return deps;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  analyzeDependencies\r\n};\r\n","/**\r\n * Node Classification\r\n *\r\n * Classifies JSX nodes as static, dynamic, or hybrid based on dependencies.\r\n *\r\n * Function to move:\r\n * - classifyNode(deps) - Classifies based on dependency set\r\n *\r\n * Classifications:\r\n * - 'static': No dependencies (can be compile-time VNode)\r\n * - 'dynamic': All dependencies are from same zone (state or props)\r\n * - 'hybrid': Mixed dependencies (needs runtime helpers)\r\n *\r\n * Currently returns 'hybrid' for any dependencies as a conservative approach.\r\n *\r\n * Returns classification string\r\n */\r\n\r\n// TODO: Move classifyNode function here\r\n\r\n/**\r\n * Classify a JSX node based on dependencies\r\n */\r\nfunction classifyNode(deps) {\r\n  if (deps.size === 0) {\r\n    return 'static';\r\n  }\r\n\r\n  const types = new Set([...deps].map(d => d.type));\r\n\r\n  if (types.size === 1) {\r\n    return types.has('client') ? 'client' : 'server';\r\n  }\r\n\r\n  return 'hybrid'; // Mixed dependencies\r\n}\r\n\r\nmodule.exports = {\r\n  classifyNode\r\n};\r\n","/**\r\n * Pattern Detection\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n\r\n/**\r\n * Detect if attributes contain spread operators\r\n */\r\nfunction hasSpreadProps(attributes) {\r\n  return attributes.some(attr => t.isJSXSpreadAttribute(attr));\r\n}\r\n\r\n/**\r\n * Detect if children contain dynamic patterns (like .map())\r\n */\r\nfunction hasDynamicChildren(children) {\r\n  return children.some(child => {\r\n    if (!t.isJSXExpressionContainer(child)) return false;\r\n    const expr = child.expression;\r\n\r\n    // Check for .map() calls\r\n    if (t.isCallExpression(expr) &&\r\n        t.isMemberExpression(expr.callee) &&\r\n        t.isIdentifier(expr.callee.property, { name: 'map' })) {\r\n      return true;\r\n    }\r\n\r\n    // Check for array expressions from LINQ/Select\r\n    if (t.isCallExpression(expr) &&\r\n        t.isMemberExpression(expr.callee) &&\r\n        (t.isIdentifier(expr.callee.property, { name: 'Select' }) ||\r\n         t.isIdentifier(expr.callee.property, { name: 'ToArray' }))) {\r\n      return true;\r\n    }\r\n\r\n    // Check for conditionals with JSX: {condition ? <A/> : <B/>}\r\n    if (t.isConditionalExpression(expr)) {\r\n      if (t.isJSXElement(expr.consequent) || t.isJSXFragment(expr.consequent) ||\r\n          t.isJSXElement(expr.alternate) || t.isJSXFragment(expr.alternate)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Check for logical expressions with JSX: {condition && <Element/>}\r\n    if (t.isLogicalExpression(expr)) {\r\n      if (t.isJSXElement(expr.right) || t.isJSXFragment(expr.right)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  });\r\n}\r\n\r\n/**\r\n * Detect if props contain complex expressions\r\n */\r\nfunction hasComplexProps(attributes) {\r\n  return attributes.some(attr => {\r\n    if (!t.isJSXAttribute(attr)) return false;\r\n    const value = attr.value;\r\n\r\n    if (!t.isJSXExpressionContainer(value)) return false;\r\n    const expr = value.expression;\r\n\r\n    // Check for conditional spread: {...(condition && { prop: value })}\r\n    if (t.isConditionalExpression(expr) || t.isLogicalExpression(expr)) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  hasSpreadProps,\r\n  hasDynamicChildren,\r\n  hasComplexProps\r\n};\r\n","/**\r\n * Event Handlers Extractor\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Extract event handler name\r\n */\r\nfunction extractEventHandler(value, component) {\r\n  if (t.isStringLiteral(value)) {\r\n    return value.value;\r\n  }\r\n\r\n  if (t.isJSXExpressionContainer(value)) {\r\n    const expr = value.expression;\r\n\r\n    if (t.isArrowFunctionExpression(expr) || t.isFunctionExpression(expr)) {\r\n      // Inline arrow function - extract to named method\r\n      const handlerName = `Handle${component.eventHandlers.length}`;\r\n      component.eventHandlers.push({ name: handlerName, body: expr.body });\r\n      return handlerName;\r\n    }\r\n\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    }\r\n\r\n    if (t.isCallExpression(expr)) {\r\n      // () => someMethod() - extract\r\n      const handlerName = `Handle${component.eventHandlers.length}`;\r\n      component.eventHandlers.push({ name: handlerName, body: expr });\r\n      return handlerName;\r\n    }\r\n  }\r\n\r\n  return 'UnknownHandler';\r\n}\r\n\r\n\r\n\r\nmodule.exports = {\r\n  extractEventHandler\r\n};\r\n","/**\r\n * JSX Generators\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { escapeCSharpString } = require('../utils/helpers.cjs');\r\nconst { hasSpreadProps, hasDynamicChildren, hasComplexProps } = require('../analyzers/detection.cjs');\r\nconst { extractEventHandler } = require('../extractors/eventHandlers.cjs');\r\n// Note: generateCSharpExpression, generateRuntimeHelperCall and generateJSXExpression will be lazy-loaded to avoid circular dependencies\r\n\r\n/**\r\n * Generate Fragment\r\n */\r\nfunction generateFragment(node, component, indent) {\r\n  const children = generateChildren(node.children, component, indent);\r\n  const childrenArray = children.map(c => c.code).join(', ');\r\n  return `new Fragment(${childrenArray})`;\r\n}\r\n\r\n/**\r\n * Generate C# for JSX element\r\n */\r\nfunction generateJSXElement(node, component, indent) {\r\n  // Lazy load to avoid circular dependencies\r\n  const { generateCSharpExpression: _generateCSharpExpression } = require('./expressions.cjs');\r\n\r\n  const indentStr = '    '.repeat(indent);\r\n\r\n  if (t.isJSXFragment(node)) {\r\n    return generateFragment(node, component, indent);\r\n  }\r\n\r\n  const tagName = node.openingElement.name.name;\r\n  const attributes = node.openingElement.attributes;\r\n  const children = node.children;\r\n\r\n  // Check if this element has markdown attribute and markdown content\r\n  const hasMarkdownAttr = attributes.some(attr =>\r\n    t.isJSXAttribute(attr) && attr.name.name === 'markdown'\r\n  );\r\n\r\n  if (hasMarkdownAttr) {\r\n    // Check if child is a markdown state variable\r\n    if (children.length === 1 && t.isJSXExpressionContainer(children[0])) {\r\n      const expr = children[0].expression;\r\n      if (t.isIdentifier(expr)) {\r\n        const varName = expr.name;\r\n        // Check if this is a markdown state variable\r\n        if (component.stateTypes.get(varName) === 'markdown') {\r\n          // Return DivRawHtml with MarkdownHelper.ToHtml()\r\n          return `new DivRawHtml(MarkdownHelper.ToHtml(${varName}))`;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Detect if this needs runtime helpers (hybrid approach)\r\n  const needsRuntimeHelper = hasSpreadProps(attributes) ||\r\n                              hasDynamicChildren(children) ||\r\n                              hasComplexProps(attributes);\r\n\r\n  if (needsRuntimeHelper) {\r\n    // Lazy load to avoid circular dependency\r\n    const { generateRuntimeHelperCall } = require('./runtimeHelpers.cjs');\r\n    return generateRuntimeHelperCall(tagName, attributes, children, component, indent);\r\n  }\r\n\r\n  // Direct VNode construction (compile-time approach)\r\n  // Extract props and event handlers\r\n  const props = [];\r\n  const eventHandlers = [];\r\n  let dataMinimactAttrs = [];\r\n\r\n  for (const attr of attributes) {\r\n    if (t.isJSXAttribute(attr)) {\r\n      const name = attr.name.name;\r\n      const value = attr.value;\r\n\r\n      if (name.startsWith('on')) {\r\n        // Event handler\r\n        const handlerName = extractEventHandler(value, component);\r\n        eventHandlers.push(`[\"${name.toLowerCase()}\"] = \"${handlerName}\"`);\r\n      } else if (name.startsWith('data-minimact-')) {\r\n        // Keep minimact attributes as-is\r\n        const val = t.isStringLiteral(value) ? value.value : _generateCSharpExpression(value.expression);\r\n        dataMinimactAttrs.push(`[\"${name}\"] = \"${val}\"`);\r\n      } else {\r\n        // Regular prop\r\n        if (t.isStringLiteral(value)) {\r\n          // String literal - use as-is with quotes\r\n          props.push(`[\"${name}\"] = \"${escapeCSharpString(value.value)}\"`);\r\n        } else if (t.isJSXExpressionContainer(value)) {\r\n          // Expression - wrap in string interpolation\r\n          const expr = _generateCSharpExpression(value.expression);\r\n          props.push(`[\"${name}\"] = $\"{${expr}}\"`);\r\n        } else {\r\n          // Fallback\r\n          props.push(`[\"${name}\"] = \"\"`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Build props dictionary\r\n  const allProps = [...props, ...eventHandlers, ...dataMinimactAttrs];\r\n  const propsStr = allProps.length > 0\r\n    ? `new Dictionary<string, string> { ${allProps.join(', ')} }`\r\n    : 'new Dictionary<string, string>()';\r\n\r\n  // Generate children\r\n  const childrenCode = generateChildren(children, component, indent);\r\n\r\n  // Build VElement construction\r\n  if (childrenCode.length === 0) {\r\n    return `new VElement(\"${tagName}\", ${propsStr})`;\r\n  } else if (childrenCode.length === 1 && childrenCode[0].type === 'text') {\r\n    return `new VElement(\"${tagName}\", ${propsStr}, ${childrenCode[0].code})`;\r\n  } else {\r\n    // Wrap children appropriately for VNode array\r\n    const childrenArray = childrenCode.map(c => {\r\n      if (c.type === 'text') {\r\n        // Text already has quotes, wrap in VText\r\n        return `new VText(${c.code})`;\r\n      } else if (c.type === 'expression') {\r\n        // Expression needs string interpolation wrapper\r\n        return `new VText($\"{${c.code}}\")`;\r\n      } else {\r\n        // Element is already a VNode\r\n        return c.code;\r\n      }\r\n    }).join(',\\n' + indentStr + '    ');\r\n    return `new VElement(\"${tagName}\", ${propsStr}, new VNode[]\\n${indentStr}{\\n${indentStr}    ${childrenArray}\\n${indentStr}})`;\r\n  }\r\n}\r\n\r\n/**\r\n * Generate children\r\n */\r\nfunction generateChildren(children, component, indent) {\r\n  const result = [];\r\n\r\n  // Lazy load to avoid circular dependency\r\n  const { generateJSXExpression } = require('./expressions.cjs');\r\n\r\n  for (const child of children) {\r\n    if (t.isJSXText(child)) {\r\n      const text = child.value.trim();\r\n      if (text) {\r\n        result.push({ type: 'text', code: `\"${escapeCSharpString(text)}\"` });\r\n      }\r\n    } else if (t.isJSXElement(child)) {\r\n      result.push({ type: 'element', code: generateJSXElement(child, component, indent + 1) });\r\n    } else if (t.isJSXExpressionContainer(child)) {\r\n      result.push({ type: 'expression', code: generateJSXExpression(child.expression, component, indent) });\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = {\r\n  generateFragment,\r\n  generateJSXElement,\r\n  generateChildren\r\n};\r\n","/**\r\n * Runtime Helper Generators\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { escapeCSharpString } = require('../utils/helpers.cjs');\r\n// Lazy load to avoid circular dependencies with jsx.cjs and expressions.cjs\r\n\r\n/**\r\n * Generate runtime helper call for complex JSX patterns\r\n * Uses MinimactHelpers.createElement() for dynamic scenarios\r\n */\r\nfunction generateRuntimeHelperCall(tagName, attributes, children, component, indent) {\r\n  // Lazy load to avoid circular dependency\r\n  const { generateCSharpExpression } = require('./expressions.cjs');\r\n  const { generateJSXElement } = require('./jsx.cjs');\r\n\r\n  const indentStr = '    '.repeat(indent);\r\n\r\n  // Build props object\r\n  let propsCode = 'null';\r\n  const regularProps = [];\r\n  const spreadProps = [];\r\n\r\n  for (const attr of attributes) {\r\n    if (t.isJSXSpreadAttribute(attr)) {\r\n      // Spread operator: {...props}\r\n      spreadProps.push(generateCSharpExpression(attr.argument));\r\n    } else if (t.isJSXAttribute(attr)) {\r\n      const name = attr.name.name;\r\n      const value = attr.value;\r\n\r\n      // Convert attribute value to C# expression\r\n      let propValue;\r\n      if (t.isStringLiteral(value)) {\r\n        propValue = `\"${escapeCSharpString(value.value)}\"`;\r\n      } else if (t.isJSXExpressionContainer(value)) {\r\n        propValue = generateCSharpExpression(value.expression);\r\n      } else if (value === null) {\r\n        propValue = '\"true\"'; // Boolean attribute like <input disabled />\r\n      } else {\r\n        propValue = `\"${value}\"`;\r\n      }\r\n\r\n      regularProps.push(`${name} = ${propValue}`);\r\n    }\r\n  }\r\n\r\n  // Build props with potential spread merging\r\n  if (regularProps.length > 0 && spreadProps.length > 0) {\r\n    // Need to merge: ((object)new { prop1 = val1 }).MergeWith((object)spreadObj)\r\n    // Cast both to object to avoid dynamic dispatch issues\r\n    const regularPropsObj = `new { ${regularProps.join(', ')} }`;\r\n    propsCode = `((object)${regularPropsObj})`;\r\n    for (const spreadProp of spreadProps) {\r\n      propsCode = `${propsCode}.MergeWith((object)${spreadProp})`;\r\n    }\r\n  } else if (regularProps.length > 0) {\r\n    // Just regular props\r\n    propsCode = `new { ${regularProps.join(', ')} }`;\r\n  } else if (spreadProps.length > 0) {\r\n    // Just spread props\r\n    propsCode = spreadProps[0];\r\n    for (let i = 1; i < spreadProps.length; i++) {\r\n      propsCode = `((object)${propsCode}).MergeWith((object)${spreadProps[i]})`;\r\n    }\r\n  }\r\n\r\n  // Build children\r\n  const childrenArgs = [];\r\n  for (const child of children) {\r\n    if (t.isJSXText(child)) {\r\n      const text = child.value.trim();\r\n      if (text) {\r\n        childrenArgs.push(`\"${escapeCSharpString(text)}\"`);\r\n      }\r\n    } else if (t.isJSXElement(child)) {\r\n      childrenArgs.push(generateJSXElement(child, component, indent + 1));\r\n    } else if (t.isJSXExpressionContainer(child)) {\r\n      const expr = child.expression;\r\n\r\n      // Handle conditionals with JSX: {condition ? <A/> : <B/>}\r\n      if (t.isConditionalExpression(expr)) {\r\n        const { generateBooleanExpression } = require('./expressions.cjs');\r\n        const condition = generateBooleanExpression(expr.test);\r\n        const consequent = t.isJSXElement(expr.consequent) || t.isJSXFragment(expr.consequent)\r\n          ? generateJSXElement(expr.consequent, component, indent + 1)\r\n          : generateCSharpExpression(expr.consequent);\r\n        const alternate = t.isJSXElement(expr.alternate) || t.isJSXFragment(expr.alternate)\r\n          ? generateJSXElement(expr.alternate, component, indent + 1)\r\n          : generateCSharpExpression(expr.alternate);\r\n        childrenArgs.push(`(${condition}) ? ${consequent} : ${alternate}`);\r\n      }\r\n      // Handle logical expressions with JSX: {condition && <Element/>}\r\n      else if (t.isLogicalExpression(expr) && expr.operator === '&&') {\r\n        const { generateBooleanExpression } = require('./expressions.cjs');\r\n        const left = generateBooleanExpression(expr.left);\r\n        const right = t.isJSXElement(expr.right) || t.isJSXFragment(expr.right)\r\n          ? generateJSXElement(expr.right, component, indent + 1)\r\n          : generateCSharpExpression(expr.right);\r\n        childrenArgs.push(`(${left}) ? ${right} : null`);\r\n      }\r\n      // Handle .map() with JSX callback\r\n      else if (t.isCallExpression(expr) &&\r\n               t.isMemberExpression(expr.callee) &&\r\n               t.isIdentifier(expr.callee.property, { name: 'map' })) {\r\n        // Lazy load generateMapExpression\r\n        const { generateMapExpression } = require('./expressions.cjs');\r\n        childrenArgs.push(generateMapExpression(expr, component, indent));\r\n      }\r\n      // Dynamic children (e.g., items.Select(...))\r\n      else {\r\n        childrenArgs.push(generateCSharpExpression(child.expression));\r\n      }\r\n    }\r\n  }\r\n\r\n  // Generate the createElement call\r\n  if (childrenArgs.length === 0) {\r\n    return `MinimactHelpers.createElement(\"${tagName}\", ${propsCode})`;\r\n  } else if (childrenArgs.length === 1) {\r\n    return `MinimactHelpers.createElement(\"${tagName}\", ${propsCode}, ${childrenArgs[0]})`;\r\n  } else {\r\n    const childrenStr = childrenArgs.join(', ');\r\n    return `MinimactHelpers.createElement(\"${tagName}\", ${propsCode}, ${childrenStr})`;\r\n  }\r\n}\r\n\r\n/**\r\n * Force runtime helper generation for a JSX node (used in conditionals/logical expressions)\r\n */\r\nfunction generateRuntimeHelperForJSXNode(node, component, indent) {\r\n  // Lazy load to avoid circular dependency\r\n  const { generateCSharpExpression } = require('./expressions.cjs');\r\n\r\n  if (t.isJSXFragment(node)) {\r\n    // Handle fragments\r\n    const children = node.children;\r\n    const childrenArgs = [];\r\n    for (const child of children) {\r\n      if (t.isJSXText(child)) {\r\n        const text = child.value.trim();\r\n        if (text) {\r\n          childrenArgs.push(`\"${escapeCSharpString(text)}\"`);\r\n        }\r\n      } else if (t.isJSXElement(child)) {\r\n        childrenArgs.push(generateRuntimeHelperForJSXNode(child, component, indent + 1));\r\n      } else if (t.isJSXExpressionContainer(child)) {\r\n        childrenArgs.push(generateCSharpExpression(child.expression));\r\n      }\r\n    }\r\n    if (childrenArgs.length === 0) {\r\n      return 'MinimactHelpers.Fragment()';\r\n    }\r\n    return `MinimactHelpers.Fragment(${childrenArgs.join(', ')})`;\r\n  }\r\n\r\n  if (t.isJSXElement(node)) {\r\n    const tagName = node.openingElement.name.name;\r\n    const attributes = node.openingElement.attributes;\r\n    const children = node.children;\r\n    return generateRuntimeHelperCall(tagName, attributes, children, component, indent);\r\n  }\r\n\r\n  return 'null';\r\n}\r\n\r\n\r\n\r\n\r\nmodule.exports = {\r\n  generateRuntimeHelperCall,\r\n  generateRuntimeHelperForJSXNode\r\n};\r\n","/**\r\n * Expression Generators\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { escapeCSharpString } = require('../utils/helpers.cjs');\r\nconst { analyzeDependencies } = require('../analyzers/dependencies.cjs');\r\nconst { classifyNode } = require('../analyzers/classification.cjs');\r\nconst { generateRuntimeHelperForJSXNode } = require('./runtimeHelpers.cjs');\r\nconst { generateJSXElement } = require('./jsx.cjs');\r\n\r\n// Module-level variable to store current component context\r\n// This allows useState setter detection without threading component through all calls\r\nlet currentComponent = null;\r\n\r\n/**\r\n * Generate expression for use in boolean context (conditionals, logical operators)\r\n * Wraps expressions in MObject for JavaScript truthiness semantics\r\n */\r\nfunction generateBooleanExpression(expr) {\r\n  const generated = generateCSharpExpression(expr);\r\n\r\n  // Check if this is a member expression on dynamic object (like user.isAdmin)\r\n  if (t.isMemberExpression(expr) && !expr.computed && t.isIdentifier(expr.object)) {\r\n    // Wrap dynamic member access in MObject for proper truthiness\r\n    return `new MObject(${generated})`;\r\n  }\r\n\r\n  // Check if this is a simple identifier that might be dynamic\r\n  if (t.isIdentifier(expr)) {\r\n    // Wrap in MObject for null/truthiness handling\r\n    return `new MObject(${generated})`;\r\n  }\r\n\r\n  // For other expressions (literals, etc.), use as-is\r\n  return generated;\r\n}\r\n\r\n/**\r\n * Generate JSX expression (e.g., {count}, {user.name})\r\n */\r\nfunction generateJSXExpression(expr, component, indent) {\r\n  // Analyze dependencies\r\n  const deps = analyzeDependencies(expr, component);\r\n  const zone = classifyNode(deps);\r\n\r\n  // For hybrid zones, we need to split\r\n  if (zone === 'hybrid') {\r\n    return generateHybridExpression(expr, component, deps, indent);\r\n  }\r\n\r\n  // Add zone attribute if needed\r\n  const zoneAttr = zone === 'client'\r\n    ? 'data-minimact-client-scope'\r\n    : zone === 'server'\r\n      ? 'data-minimact-server-scope'\r\n      : '';\r\n\r\n  // Handle special JSX expression types\r\n  if (t.isConditionalExpression(expr)) {\r\n    // Ternary with JSX: condition ? <A/> : <B/>\r\n    // Force runtime helpers for JSX in conditionals\r\n    const condition = generateBooleanExpression(expr.test);\r\n    const consequent = t.isJSXElement(expr.consequent) || t.isJSXFragment(expr.consequent)\r\n      ? generateRuntimeHelperForJSXNode(expr.consequent, component, indent)\r\n      : generateCSharpExpression(expr.consequent);\r\n    const alternate = t.isJSXElement(expr.alternate) || t.isJSXFragment(expr.alternate)\r\n      ? generateRuntimeHelperForJSXNode(expr.alternate, component, indent)\r\n      : generateCSharpExpression(expr.alternate);\r\n    return `(${condition}) ? ${consequent} : ${alternate}`;\r\n  }\r\n\r\n  if (t.isLogicalExpression(expr) && expr.operator === '&&') {\r\n    // Short-circuit with JSX: condition && <Element/>\r\n    // Force runtime helpers for JSX in logical expressions\r\n    const left = generateBooleanExpression(expr.left);\r\n    const right = t.isJSXElement(expr.right) || t.isJSXFragment(expr.right)\r\n      ? generateRuntimeHelperForJSXNode(expr.right, component, indent)\r\n      : generateCSharpExpression(expr.right);\r\n    // Use != null for truthy check (works for bool, object, int, etc.)\r\n    return `(${left}) ? ${right} : null`;\r\n  }\r\n\r\n  if (t.isCallExpression(expr) &&\r\n      t.isMemberExpression(expr.callee) &&\r\n      t.isIdentifier(expr.callee.property, { name: 'map' })) {\r\n    // Array.map() with JSX callback\r\n    return generateMapExpression(expr, component, indent);\r\n  }\r\n\r\n  // Generate C# expression\r\n  return generateCSharpExpression(expr);\r\n}\r\n\r\n/**\r\n * Generate conditional (ternary)\r\n */\r\nfunction generateConditional(node, component, indent) {\r\n  const indentStr = '    '.repeat(indent);\r\n  const condition = generateCSharpExpression(node.test);\r\n  const consequent = generateJSXElement(node.consequent, component, indent);\r\n  const alternate = generateJSXElement(node.alternate, component, indent);\r\n\r\n  return `${indentStr}return ${condition}\\n${indentStr}    ? ${consequent}\\n${indentStr}    : ${alternate};`;\r\n}\r\n\r\n/**\r\n * Generate short-circuit (&&)\r\n */\r\nfunction generateShortCircuit(node, component, indent) {\r\n  const indentStr = '    '.repeat(indent);\r\n  const condition = generateCSharpExpression(node.left);\r\n  const element = generateJSXElement(node.right, component, indent);\r\n\r\n  return `${indentStr}if (${condition})\\n${indentStr}{\\n${indentStr}    return ${element};\\n${indentStr}}\\n${indentStr}return new VText(\"\");`;\r\n}\r\n\r\n/**\r\n * Generate .map() expression\r\n */\r\nfunction generateMapExpression(node, component, indent) {\r\n  const indentStr = '    '.repeat(indent);\r\n  const array = node.callee.object;\r\n  const callback = node.arguments[0];\r\n\r\n  const arrayName = array.name || generateCSharpExpression(array);\r\n  const itemParam = callback.params[0].name;\r\n  const indexParam = callback.params[1] ? callback.params[1].name : null;\r\n  const body = callback.body;\r\n\r\n  const itemCode = t.isJSXElement(body)\r\n    ? generateJSXElement(body, component, indent + 1)\r\n    : generateJSXElement(body.body, component, indent + 1);\r\n\r\n  // C# Select supports (item, index) => ...\r\n  if (indexParam) {\r\n    return `${arrayName}.Select((${itemParam}, ${indexParam}) => ${itemCode}).ToArray()`;\r\n  } else {\r\n    return `${arrayName}.Select(${itemParam} => ${itemCode}).ToArray()`;\r\n  }\r\n}\r\n\r\n/**\r\n * Generate C# statement from JavaScript AST node\r\n */\r\nfunction generateCSharpStatement(node) {\r\n  if (!node) return '';\r\n\r\n  if (t.isExpressionStatement(node)) {\r\n    return generateCSharpExpression(node.expression) + ';';\r\n  }\r\n\r\n  if (t.isReturnStatement(node)) {\r\n    return `return ${generateCSharpExpression(node.argument)};`;\r\n  }\r\n\r\n  if (t.isVariableDeclaration(node)) {\r\n    const declarations = node.declarations.map(d => {\r\n      const name = d.id.name;\r\n      const value = generateCSharpExpression(d.init);\r\n      return `var ${name} = ${value};`;\r\n    }).join(' ');\r\n    return declarations;\r\n  }\r\n\r\n  // Fallback: try to convert as expression\r\n  return generateCSharpExpression(node) + ';';\r\n}\r\n\r\n/**\r\n * Generate C# expression from JS expression\r\n */\r\nfunction generateCSharpExpression(node) {\r\n  if (!node) return 'null';\r\n\r\n  if (t.isStringLiteral(node)) {\r\n    return `\"${escapeCSharpString(node.value)}\"`;\r\n  }\r\n\r\n  if (t.isNumericLiteral(node)) {\r\n    return String(node.value);\r\n  }\r\n\r\n  if (t.isBooleanLiteral(node)) {\r\n    return node.value ? 'true' : 'false';\r\n  }\r\n\r\n  if (t.isNullLiteral(node)) {\r\n    return 'null';\r\n  }\r\n\r\n  if (t.isIdentifier(node)) {\r\n    return node.name;\r\n  }\r\n\r\n  if (t.isMemberExpression(node)) {\r\n    const object = generateCSharpExpression(node.object);\r\n    const propertyName = t.isIdentifier(node.property) ? node.property.name : null;\r\n\r\n    // Handle JavaScript to C# API conversions\r\n    if (propertyName === 'length' && !node.computed) {\r\n      // array.length → array.Count\r\n      return `${object}.Count`;\r\n    }\r\n\r\n    const property = node.computed\r\n      ? `[${generateCSharpExpression(node.property)}]`\r\n      : `.${propertyName}`;\r\n    return `${object}${property}`;\r\n  }\r\n\r\n  if (t.isArrayExpression(node)) {\r\n    const elements = node.elements.map(e => generateCSharpExpression(e)).join(', ');\r\n    return `new List<object> { ${elements} }`;\r\n  }\r\n\r\n  if (t.isBinaryExpression(node)) {\r\n    const left = generateCSharpExpression(node.left);\r\n    const right = generateCSharpExpression(node.right);\r\n    // Convert JavaScript operators to C# operators\r\n    let operator = node.operator;\r\n    if (operator === '===') operator = '==';\r\n    if (operator === '!==') operator = '!=';\r\n    return `${left} ${operator} ${right}`;\r\n  }\r\n\r\n  if (t.isConditionalExpression(node)) {\r\n    // Handle ternary operator: test ? consequent : alternate\r\n    const test = generateCSharpExpression(node.test);\r\n    const consequent = generateCSharpExpression(node.consequent);\r\n    const alternate = generateCSharpExpression(node.alternate);\r\n    return `(${test}) ? ${consequent} : ${alternate}`;\r\n  }\r\n\r\n  if (t.isCallExpression(node)) {\r\n    // Handle console.log → Console.WriteLine\r\n    if (t.isMemberExpression(node.callee) &&\r\n        t.isIdentifier(node.callee.object, { name: 'console' }) &&\r\n        t.isIdentifier(node.callee.property, { name: 'log' })) {\r\n      const args = node.arguments.map(arg => generateCSharpExpression(arg)).join(' + ');\r\n      return `Console.WriteLine(${args})`;\r\n    }\r\n\r\n    // Handle .toFixed(n) → .ToString(\"Fn\")\r\n    if (t.isMemberExpression(node.callee) && t.isIdentifier(node.callee.property, { name: 'toFixed' })) {\r\n      const object = generateCSharpExpression(node.callee.object);\r\n      const decimals = node.arguments.length > 0 && t.isNumericLiteral(node.arguments[0])\r\n        ? node.arguments[0].value\r\n        : 2;\r\n      return `${object}.ToString(\"F${decimals}\")`;\r\n    }\r\n\r\n    // Handle useState/useClientState setters → SetState calls\r\n    if (t.isIdentifier(node.callee) && currentComponent) {\r\n      const setterName = node.callee.name;\r\n\r\n      // Check if this is a useState setter\r\n      const useState = [...(currentComponent.useState || []), ...(currentComponent.useClientState || [])]\r\n        .find(state => state.setter === setterName);\r\n\r\n      if (useState && node.arguments.length > 0) {\r\n        const newValue = generateCSharpExpression(node.arguments[0]);\r\n        return `SetState(nameof(${useState.name}), ${newValue})`;\r\n      }\r\n    }\r\n\r\n    // Generic function call\r\n    const callee = generateCSharpExpression(node.callee);\r\n    const args = node.arguments.map(arg => generateCSharpExpression(arg)).join(', ');\r\n    return `${callee}(${args})`;\r\n  }\r\n\r\n  if (t.isTemplateLiteral(node)) {\r\n    // Convert template literal to C# string interpolation\r\n    let result = '$\"';\r\n    for (let i = 0; i < node.quasis.length; i++) {\r\n      result += node.quasis[i].value.raw;\r\n      if (i < node.expressions.length) {\r\n        result += '{' + generateCSharpExpression(node.expressions[i]) + '}';\r\n      }\r\n    }\r\n    result += '\"';\r\n    return result;\r\n  }\r\n\r\n  if (t.isObjectExpression(node)) {\r\n    // Convert JS object literal to C# anonymous object or Dictionary\r\n    // Check if any key has hyphens (invalid for C# anonymous types)\r\n    const hasHyphenatedKeys = node.properties.some(prop => {\r\n      if (t.isObjectProperty(prop)) {\r\n        const key = t.isIdentifier(prop.key) ? prop.key.name : prop.key.value;\r\n        return typeof key === 'string' && key.includes('-');\r\n      }\r\n      return false;\r\n    });\r\n\r\n    const properties = node.properties.map(prop => {\r\n      if (t.isObjectProperty(prop)) {\r\n        const key = t.isIdentifier(prop.key) ? prop.key.name : prop.key.value;\r\n        const value = generateCSharpExpression(prop.value);\r\n\r\n        if (hasHyphenatedKeys) {\r\n          // Use Dictionary syntax with quoted keys\r\n          return `[\"${key}\"] = ${value}`;\r\n        } else {\r\n          // Use anonymous object syntax\r\n          return `${key} = ${value}`;\r\n        }\r\n      }\r\n      return '';\r\n    }).filter(p => p !== '');\r\n\r\n    if (properties.length === 0) return 'null';\r\n\r\n    if (hasHyphenatedKeys) {\r\n      return `new Dictionary<string, object> { ${properties.join(', ')} }`;\r\n    } else {\r\n      return `new { ${properties.join(', ')} }`;\r\n    }\r\n  }\r\n\r\n  return 'null';\r\n}\r\n\r\n/**\r\n * Generate attribute value\r\n */\r\nfunction generateAttributeValue(value) {\r\n  if (!value) return '\"\"';\r\n\r\n  if (t.isStringLiteral(value)) {\r\n    return `\"${escapeCSharpString(value.value)}\"`;\r\n  }\r\n\r\n  if (t.isJSXExpressionContainer(value)) {\r\n    return generateCSharpExpression(value.expression);\r\n  }\r\n\r\n  return '\"\"';\r\n}\r\n\r\n/**\r\n * Generate hybrid expression with smart span splitting\r\n */\r\nfunction generateHybridExpression(expr, component, deps, indent) {\r\n  // For now, return a simplified version\r\n  // TODO: Implement full AST splitting logic\r\n  return `new VText(${generateCSharpExpression(expr)})`;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * Set the current component context for useState setter detection\r\n */\r\nfunction setCurrentComponent(component) {\r\n  currentComponent = component;\r\n}\r\n\r\nmodule.exports = {\r\n  generateAttributeValue,\r\n  generateCSharpExpression,\r\n  generateCSharpStatement,\r\n  generateMapExpression,\r\n  generateConditional,\r\n  generateShortCircuit,\r\n  generateHybridExpression,\r\n  generateJSXExpression,\r\n  generateBooleanExpression,\r\n  setCurrentComponent\r\n};\r\n","/**\r\n * Hook Extractors\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { generateCSharpExpression } = require('../generators/expressions.cjs');\r\nconst { inferType } = require('../types/typeConversion.cjs');\r\n\r\n/**\r\n * Extract hook calls (useState, useClientState, etc.)\r\n */\r\nfunction extractHook(path, component) {\r\n  const node = path.node;\r\n\r\n  if (!t.isIdentifier(node.callee)) return;\r\n\r\n  const hookName = node.callee.name;\r\n\r\n  switch (hookName) {\r\n    case 'useState':\r\n      extractUseState(path, component, 'useState');\r\n      break;\r\n    case 'useClientState':\r\n      extractUseState(path, component, 'useClientState');\r\n      break;\r\n    case 'useEffect':\r\n      extractUseEffect(path, component);\r\n      break;\r\n    case 'useRef':\r\n      extractUseRef(path, component);\r\n      break;\r\n    case 'useMarkdown':\r\n      extractUseMarkdown(path, component);\r\n      break;\r\n    case 'useTemplate':\r\n      extractUseTemplate(path, component);\r\n      break;\r\n    case 'useValidation':\r\n      extractUseValidation(path, component);\r\n      break;\r\n    case 'useModal':\r\n      extractUseModal(path, component);\r\n      break;\r\n    case 'useToggle':\r\n      extractUseToggle(path, component);\r\n      break;\r\n    case 'useDropdown':\r\n      extractUseDropdown(path, component);\r\n      break;\r\n    case 'usePub':\r\n      extractUsePub(path, component);\r\n      break;\r\n    case 'useSub':\r\n      extractUseSub(path, component);\r\n      break;\r\n    case 'useMicroTask':\r\n      extractUseMicroTask(path, component);\r\n      break;\r\n    case 'useMacroTask':\r\n      extractUseMacroTask(path, component);\r\n      break;\r\n    case 'useSignalR':\r\n      extractUseSignalR(path, component);\r\n      break;\r\n    case 'usePredictHint':\r\n      extractUsePredictHint(path, component);\r\n      break;\r\n    case 'useServerTask':\r\n      extractUseServerTask(path, component);\r\n      break;\r\n  }\r\n}\r\n\r\n/**\r\n * Extract useState or useClientState\r\n */\r\nfunction extractUseState(path, component, hookType) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n  if (!t.isArrayPattern(parent.id)) return;\r\n\r\n  const [stateVar, setterVar] = parent.id.elements;\r\n  const initialValue = path.node.arguments[0];\r\n\r\n  const stateInfo = {\r\n    name: stateVar.name,\r\n    setter: setterVar.name,\r\n    initialValue: generateCSharpExpression(initialValue),\r\n    type: inferType(initialValue)\r\n  };\r\n\r\n  if (hookType === 'useState') {\r\n    component.useState.push(stateInfo);\r\n    component.stateTypes.set(stateVar.name, 'server');\r\n  } else {\r\n    component.useClientState.push(stateInfo);\r\n    component.stateTypes.set(stateVar.name, 'client');\r\n  }\r\n}\r\n\r\n/**\r\n * Extract useEffect\r\n */\r\nfunction extractUseEffect(path, component) {\r\n  const callback = path.node.arguments[0];\r\n  const dependencies = path.node.arguments[1];\r\n\r\n  component.useEffect.push({\r\n    body: callback,\r\n    dependencies: dependencies\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useRef\r\n */\r\nfunction extractUseRef(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const refName = parent.id.name;\r\n  const initialValue = path.node.arguments[0];\r\n\r\n  component.useRef.push({\r\n    name: refName,\r\n    initialValue: generateCSharpExpression(initialValue)\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useMarkdown\r\n */\r\nfunction extractUseMarkdown(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n  if (!t.isArrayPattern(parent.id)) return;\r\n\r\n  const [contentVar, setterVar] = parent.id.elements;\r\n  const initialValue = path.node.arguments[0];\r\n\r\n  component.useMarkdown.push({\r\n    name: contentVar.name,\r\n    setter: setterVar.name,\r\n    initialValue: generateCSharpExpression(initialValue)\r\n  });\r\n\r\n  // Track as markdown state type\r\n  component.stateTypes.set(contentVar.name, 'markdown');\r\n}\r\n\r\n/**\r\n * Extract useTemplate\r\n */\r\nfunction extractUseTemplate(path, component) {\r\n  const templateName = path.node.arguments[0];\r\n  const templateProps = path.node.arguments[1];\r\n\r\n  if (t.isStringLiteral(templateName)) {\r\n    component.useTemplate = {\r\n      name: templateName.value,\r\n      props: {}\r\n    };\r\n\r\n    // Extract template props if provided\r\n    if (templateProps && t.isObjectExpression(templateProps)) {\r\n      for (const prop of templateProps.properties) {\r\n        if (t.isObjectProperty(prop) && t.isIdentifier(prop.key)) {\r\n          const propName = prop.key.name;\r\n          let propValue = '';\r\n\r\n          if (t.isStringLiteral(prop.value)) {\r\n            propValue = prop.value.value;\r\n          } else if (t.isNumericLiteral(prop.value)) {\r\n            propValue = prop.value.value.toString();\r\n          } else if (t.isBooleanLiteral(prop.value)) {\r\n            propValue = prop.value.value.toString();\r\n          }\r\n\r\n          component.useTemplate.props[propName] = propValue;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Extract useValidation\r\n */\r\nfunction extractUseValidation(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const fieldName = parent.id.name;\r\n  const fieldKey = path.node.arguments[0];\r\n  const validationRules = path.node.arguments[1];\r\n\r\n  const validationInfo = {\r\n    name: fieldName,\r\n    fieldKey: t.isStringLiteral(fieldKey) ? fieldKey.value : fieldName,\r\n    rules: {}\r\n  };\r\n\r\n  // Extract validation rules from the object\r\n  if (validationRules && t.isObjectExpression(validationRules)) {\r\n    for (const prop of validationRules.properties) {\r\n      if (t.isObjectProperty(prop) && t.isIdentifier(prop.key)) {\r\n        const ruleName = prop.key.name;\r\n        let ruleValue = null;\r\n\r\n        if (t.isStringLiteral(prop.value)) {\r\n          ruleValue = prop.value.value;\r\n        } else if (t.isNumericLiteral(prop.value)) {\r\n          ruleValue = prop.value.value;\r\n        } else if (t.isBooleanLiteral(prop.value)) {\r\n          ruleValue = prop.value.value;\r\n        } else if (t.isRegExpLiteral(prop.value)) {\r\n          ruleValue = `/${prop.value.pattern}/${prop.value.flags || ''}`;\r\n        }\r\n\r\n        validationInfo.rules[ruleName] = ruleValue;\r\n      }\r\n    }\r\n  }\r\n\r\n  component.useValidation.push(validationInfo);\r\n}\r\n\r\n/**\r\n * Extract useModal\r\n */\r\nfunction extractUseModal(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const modalName = parent.id.name;\r\n\r\n  component.useModal.push({\r\n    name: modalName\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useToggle\r\n */\r\nfunction extractUseToggle(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n  if (!t.isArrayPattern(parent.id)) return;\r\n\r\n  const [stateVar, toggleFunc] = parent.id.elements;\r\n  const initialValue = path.node.arguments[0];\r\n\r\n  const toggleInfo = {\r\n    name: stateVar.name,\r\n    toggleFunc: toggleFunc.name,\r\n    initialValue: generateCSharpExpression(initialValue)\r\n  };\r\n\r\n  component.useToggle.push(toggleInfo);\r\n}\r\n\r\n/**\r\n * Extract useDropdown\r\n */\r\nfunction extractUseDropdown(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const dropdownName = parent.id.name;\r\n  const routeArg = path.node.arguments[0];\r\n\r\n  let routeReference = null;\r\n\r\n  // Try to extract route reference (e.g., Routes.Api.Units.GetAll)\r\n  if (routeArg && t.isMemberExpression(routeArg)) {\r\n    routeReference = generateCSharpExpression(routeArg);\r\n  }\r\n\r\n  component.useDropdown.push({\r\n    name: dropdownName,\r\n    route: routeReference\r\n  });\r\n}\r\n\r\n/**\r\n * Extract usePub\r\n */\r\nfunction extractUsePub(path, component) {\r\n  const parent = path.parent;\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const pubName = parent.id.name;\r\n  const channel = path.node.arguments[0];\r\n\r\n  component.usePub = component.usePub || [];\r\n  component.usePub.push({\r\n    name: pubName,\r\n    channel: t.isStringLiteral(channel) ? channel.value : null\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useSub\r\n */\r\nfunction extractUseSub(path, component) {\r\n  const parent = path.parent;\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const subName = parent.id.name;\r\n  const channel = path.node.arguments[0];\r\n  const callback = path.node.arguments[1];\r\n\r\n  component.useSub = component.useSub || [];\r\n  component.useSub.push({\r\n    name: subName,\r\n    channel: t.isStringLiteral(channel) ? channel.value : null,\r\n    hasCallback: !!callback\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useMicroTask\r\n */\r\nfunction extractUseMicroTask(path, component) {\r\n  const callback = path.node.arguments[0];\r\n\r\n  component.useMicroTask = component.useMicroTask || [];\r\n  component.useMicroTask.push({\r\n    body: callback\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useMacroTask\r\n */\r\nfunction extractUseMacroTask(path, component) {\r\n  const callback = path.node.arguments[0];\r\n  const delay = path.node.arguments[1];\r\n\r\n  component.useMacroTask = component.useMacroTask || [];\r\n  component.useMacroTask.push({\r\n    body: callback,\r\n    delay: t.isNumericLiteral(delay) ? delay.value : 0\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useSignalR\r\n */\r\nfunction extractUseSignalR(path, component) {\r\n  const parent = path.parent;\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const signalRName = parent.id.name;\r\n  const hubUrl = path.node.arguments[0];\r\n  const onMessage = path.node.arguments[1];\r\n\r\n  component.useSignalR = component.useSignalR || [];\r\n  component.useSignalR.push({\r\n    name: signalRName,\r\n    hubUrl: t.isStringLiteral(hubUrl) ? hubUrl.value : null,\r\n    hasOnMessage: !!onMessage\r\n  });\r\n}\r\n\r\n/**\r\n * Extract usePredictHint\r\n */\r\nfunction extractUsePredictHint(path, component) {\r\n  const hintId = path.node.arguments[0];\r\n  const predictedState = path.node.arguments[1];\r\n\r\n  component.usePredictHint = component.usePredictHint || [];\r\n  component.usePredictHint.push({\r\n    hintId: t.isStringLiteral(hintId) ? hintId.value : null,\r\n    predictedState: predictedState\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useServerTask\r\n *\r\n * Detects: const task = useServerTask(async () => { ... }, options)\r\n * Transpiles async function → C# async Task<T>\r\n * Generates [ServerTask] attribute\r\n */\r\nfunction extractUseServerTask(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const taskName = parent.id.name;\r\n  const asyncFunction = path.node.arguments[0];\r\n  const options = path.node.arguments[1];\r\n\r\n  // Validate async function\r\n  if (!asyncFunction || (!t.isArrowFunctionExpression(asyncFunction) && !t.isFunctionExpression(asyncFunction))) {\r\n    console.warn('[useServerTask] First argument must be an async function');\r\n    return;\r\n  }\r\n\r\n  if (!asyncFunction.async) {\r\n    console.warn('[useServerTask] Function must be async');\r\n    return;\r\n  }\r\n\r\n  // Check if streaming (async function*)\r\n  const isStreaming = asyncFunction.generator === true;\r\n\r\n  // Extract parameters\r\n  const parameters = asyncFunction.params.map(param => {\r\n    if (t.isIdentifier(param)) {\r\n      return {\r\n        name: param.name,\r\n        type: param.typeAnnotation ? extractTypeAnnotation(param.typeAnnotation) : 'object'\r\n      };\r\n    }\r\n    return null;\r\n  }).filter(Boolean);\r\n\r\n  // Extract options\r\n  let streamingEnabled = isStreaming;\r\n  let estimatedChunks = null;\r\n\r\n  if (options && t.isObjectExpression(options)) {\r\n    for (const prop of options.properties) {\r\n      if (t.isObjectProperty(prop) && t.isIdentifier(prop.key)) {\r\n        if (prop.key.name === 'stream' && t.isBooleanLiteral(prop.value)) {\r\n          streamingEnabled = prop.value.value;\r\n        }\r\n        if (prop.key.name === 'estimatedChunks' && t.isNumericLiteral(prop.value)) {\r\n          estimatedChunks = prop.value.value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Initialize component.useServerTask if needed\r\n  component.useServerTask = component.useServerTask || [];\r\n\r\n  // Store server task info\r\n  component.useServerTask.push({\r\n    name: taskName,\r\n    asyncFunction: asyncFunction,\r\n    parameters: parameters,\r\n    isStreaming: streamingEnabled,\r\n    estimatedChunks: estimatedChunks,\r\n    returnType: extractReturnType(asyncFunction)\r\n  });\r\n}\r\n\r\n/**\r\n * Extract TypeScript type annotation\r\n */\r\nfunction extractTypeAnnotation(typeAnnotation) {\r\n  // Strip TSTypeAnnotation wrapper\r\n  const actualType = typeAnnotation.typeAnnotation || typeAnnotation;\r\n\r\n  if (t.isTSStringKeyword(actualType)) {\r\n    return 'string';\r\n  }\r\n  if (t.isTSNumberKeyword(actualType)) {\r\n    return 'double';\r\n  }\r\n  if (t.isTSBooleanKeyword(actualType)) {\r\n    return 'bool';\r\n  }\r\n  if (t.isTSArrayType(actualType)) {\r\n    const elementType = extractTypeAnnotation(actualType.elementType);\r\n    return `List<${elementType}>`;\r\n  }\r\n  if (t.isTSTypeReference(actualType) && t.isIdentifier(actualType.typeName)) {\r\n    return actualType.typeName.name; // Use custom type as-is\r\n  }\r\n\r\n  return 'object';\r\n}\r\n\r\n/**\r\n * Extract return type from async function\r\n */\r\nfunction extractReturnType(asyncFunction) {\r\n  // Check for explicit return type annotation\r\n  if (asyncFunction.returnType) {\r\n    const returnType = asyncFunction.returnType.typeAnnotation;\r\n\r\n    // Promise<T> → T\r\n    if (t.isTSTypeReference(returnType) &&\r\n        t.isIdentifier(returnType.typeName) &&\r\n        returnType.typeName.name === 'Promise') {\r\n      if (returnType.typeParameters && returnType.typeParameters.params.length > 0) {\r\n        return extractTypeAnnotation(returnType.typeParameters.params[0]);\r\n      }\r\n    }\r\n\r\n    return extractTypeAnnotation(returnType);\r\n  }\r\n\r\n  // Try to infer from return statements\r\n  // For now, default to object\r\n  return 'object';\r\n}\r\n\r\nmodule.exports = {\r\n  extractHook,\r\n  extractUseState,\r\n  extractUseEffect,\r\n  extractUseRef,\r\n  extractUseMarkdown,\r\n  extractUseTemplate,\r\n  extractUseValidation,\r\n  extractUseModal,\r\n  extractUseToggle,\r\n  extractUseDropdown,\r\n  extractUsePub,\r\n  extractUseSub,\r\n  extractUseMicroTask,\r\n  extractUseMacroTask,\r\n  extractUseSignalR,\r\n  extractUsePredictHint,\r\n  extractUseServerTask\r\n};","/**\r\n * Local Variables Extractor\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { generateCSharpExpression } = require('../generators/expressions.cjs');\r\nconst { tsTypeToCSharpType } = require('../types/typeConversion.cjs');\r\n\r\n/**\r\n * Check if an expression uses external libraries\r\n */\r\nfunction usesExternalLibrary(node, externalImports, visited = new WeakSet()) {\r\n  if (!node || visited.has(node)) return false;\r\n  visited.add(node);\r\n\r\n  // Direct identifier match\r\n  if (t.isIdentifier(node) && externalImports.has(node.name)) {\r\n    return true;\r\n  }\r\n\r\n  // Member expression (_.sortBy, moment().format)\r\n  if (t.isMemberExpression(node)) {\r\n    return usesExternalLibrary(node.object, externalImports, visited);\r\n  }\r\n\r\n  // Call expression (_.sortBy(...), moment(...))\r\n  if (t.isCallExpression(node)) {\r\n    return usesExternalLibrary(node.callee, externalImports, visited) ||\r\n           node.arguments.some(arg => usesExternalLibrary(arg, externalImports, visited));\r\n  }\r\n\r\n  // Binary/Logical expressions\r\n  if (t.isBinaryExpression(node) || t.isLogicalExpression(node)) {\r\n    return usesExternalLibrary(node.left, externalImports, visited) ||\r\n           usesExternalLibrary(node.right, externalImports, visited);\r\n  }\r\n\r\n  // Conditional expression\r\n  if (t.isConditionalExpression(node)) {\r\n    return usesExternalLibrary(node.test, externalImports, visited) ||\r\n           usesExternalLibrary(node.consequent, externalImports, visited) ||\r\n           usesExternalLibrary(node.alternate, externalImports, visited);\r\n  }\r\n\r\n  // Array expressions\r\n  if (t.isArrayExpression(node)) {\r\n    return node.elements.some(el => el && usesExternalLibrary(el, externalImports, visited));\r\n  }\r\n\r\n  // Object expressions\r\n  if (t.isObjectExpression(node)) {\r\n    return node.properties.some(prop =>\r\n      t.isObjectProperty(prop) && usesExternalLibrary(prop.value, externalImports, visited)\r\n    );\r\n  }\r\n\r\n  // Arrow functions and function expressions\r\n  if (t.isArrowFunctionExpression(node) || t.isFunctionExpression(node)) {\r\n    return usesExternalLibrary(node.body, externalImports, visited);\r\n  }\r\n\r\n  // Block statement\r\n  if (t.isBlockStatement(node)) {\r\n    return node.body.some(stmt => usesExternalLibrary(stmt, externalImports, visited));\r\n  }\r\n\r\n  // Return statement\r\n  if (t.isReturnStatement(node)) {\r\n    return usesExternalLibrary(node.argument, externalImports, visited);\r\n  }\r\n\r\n  // Expression statement\r\n  if (t.isExpressionStatement(node)) {\r\n    return usesExternalLibrary(node.expression, externalImports, visited);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Extract local variables (const/let/var) from function body\r\n */\r\nfunction extractLocalVariables(path, component, types) {\r\n  const declarations = path.node.declarations;\r\n\r\n  for (const declarator of declarations) {\r\n    // Skip if it's a hook call (already handled)\r\n    if (t.isCallExpression(declarator.init)) {\r\n      const callee = declarator.init.callee;\r\n      if (t.isIdentifier(callee) && callee.name.startsWith('use')) {\r\n        continue; // Skip hook calls\r\n      }\r\n    }\r\n\r\n    // Check if this is an event handler (arrow function or function expression)\r\n    if (t.isIdentifier(declarator.id) && declarator.init) {\r\n      const varName = declarator.id.name;\r\n\r\n      // If it's an arrow function or function expression\r\n      if (t.isArrowFunctionExpression(declarator.init) || t.isFunctionExpression(declarator.init)) {\r\n        // Check if the function body uses external libraries\r\n        const usesExternal = usesExternalLibrary(declarator.init.body, component.externalImports);\r\n\r\n        if (usesExternal) {\r\n          // Mark as client-computed function\r\n          component.clientComputedVars.add(varName);\r\n\r\n          component.localVariables.push({\r\n            name: varName,\r\n            type: 'dynamic', // Will be refined to Func<> in generator\r\n            initialValue: 'null',\r\n            isClientComputed: true,\r\n            isFunction: true,\r\n            init: declarator.init\r\n          });\r\n        } else {\r\n          // Regular event handler\r\n          component.eventHandlers.push({\r\n            name: varName,\r\n            body: declarator.init.body,\r\n            params: declarator.init.params\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Check if this variable uses external libraries\r\n      const isClientComputed = usesExternalLibrary(declarator.init, component.externalImports);\r\n\r\n      if (isClientComputed) {\r\n        // Mark as client-computed\r\n        component.clientComputedVars.add(varName);\r\n      }\r\n\r\n      // Otherwise, treat as a regular local variable\r\n      const initValue = generateCSharpExpression(declarator.init);\r\n\r\n      // Try to infer type from TypeScript annotation or initial value\r\n      let varType = 'var'; // C# var for type inference\r\n      if (declarator.id.typeAnnotation?.typeAnnotation) {\r\n        varType = tsTypeToCSharpType(declarator.id.typeAnnotation.typeAnnotation);\r\n      }\r\n\r\n      component.localVariables.push({\r\n        name: varName,\r\n        type: varType,\r\n        initialValue: initValue,\r\n        isClientComputed: isClientComputed,  // NEW: Flag for client-computed\r\n        init: declarator.init  // NEW: Store AST node for type inference\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  extractLocalVariables,\r\n  usesExternalLibrary\r\n};\r\n","/**\r\n * Prop Type Inference\r\n * Infers C# types for props based on how they're used in the component\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Infer prop types from usage in the component body\r\n */\r\nfunction inferPropTypes(component, body) {\r\n  const propUsage = {};\r\n\r\n  // Initialize tracking for each prop\r\n  for (const prop of component.props) {\r\n    propUsage[prop.name] = {\r\n      usedAsBoolean: false,\r\n      usedAsNumber: false,\r\n      usedAsString: false,\r\n      usedAsArray: false,\r\n      usedAsObject: false,\r\n      hasArrayMethods: false,\r\n      hasNumberOperations: false\r\n    };\r\n  }\r\n\r\n  // Traverse the body to analyze prop usage\r\n  function analyzePropUsage(node) {\r\n    if (!node) return;\r\n\r\n    // Handle BlockStatement (function body)\r\n    if (t.isBlockStatement(node)) {\r\n      for (const statement of node.body) {\r\n        analyzePropUsage(statement);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle VariableDeclaration\r\n    if (t.isVariableDeclaration(node)) {\r\n      for (const declarator of node.declarations) {\r\n        if (declarator.init) {\r\n          analyzePropUsage(declarator.init);\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle ReturnStatement\r\n    if (t.isReturnStatement(node)) {\r\n      analyzePropUsage(node.argument);\r\n      return;\r\n    }\r\n\r\n    // Handle ExpressionStatement\r\n    if (t.isExpressionStatement(node)) {\r\n      analyzePropUsage(node.expression);\r\n      return;\r\n    }\r\n\r\n    // Check if prop is used in conditional context (implies boolean)\r\n    if (t.isConditionalExpression(node)) {\r\n      const testName = extractPropName(node.test);\r\n      if (testName && propUsage[testName]) {\r\n        propUsage[testName].usedAsBoolean = true;\r\n      }\r\n      analyzePropUsage(node.consequent);\r\n      analyzePropUsage(node.alternate);\r\n    }\r\n\r\n    // Check if prop is used in logical expression (implies boolean)\r\n    if (t.isLogicalExpression(node)) {\r\n      const leftName = extractPropName(node.left);\r\n      if (leftName && propUsage[leftName]) {\r\n        propUsage[leftName].usedAsBoolean = true;\r\n      }\r\n      analyzePropUsage(node.right);\r\n    }\r\n\r\n    // Check if prop is used with .map(), .filter(), etc (implies array)\r\n    if (t.isCallExpression(node) && t.isMemberExpression(node.callee)) {\r\n      const objectName = extractPropName(node.callee.object);\r\n      const methodName = t.isIdentifier(node.callee.property) ? node.callee.property.name : null;\r\n\r\n      if (objectName && propUsage[objectName]) {\r\n        if (methodName === 'map' || methodName === 'filter' || methodName === 'forEach' ||\r\n            methodName === 'find' || methodName === 'some' || methodName === 'every' ||\r\n            methodName === 'reduce' || methodName === 'sort' || methodName === 'slice') {\r\n          propUsage[objectName].usedAsArray = true;\r\n          propUsage[objectName].hasArrayMethods = true;\r\n        }\r\n      }\r\n\r\n      // Recurse into arguments\r\n      for (const arg of node.arguments) {\r\n        analyzePropUsage(arg);\r\n      }\r\n    }\r\n\r\n    // Check if prop is used in arithmetic operations (implies number)\r\n    if (t.isBinaryExpression(node)) {\r\n      if (['+', '-', '*', '/', '%', '>', '<', '>=', '<='].includes(node.operator)) {\r\n        const leftName = extractPropName(node.left);\r\n        const rightName = extractPropName(node.right);\r\n\r\n        if (leftName && propUsage[leftName]) {\r\n          propUsage[leftName].usedAsNumber = true;\r\n          propUsage[leftName].hasNumberOperations = true;\r\n        }\r\n        if (rightName && propUsage[rightName]) {\r\n          propUsage[rightName].usedAsNumber = true;\r\n          propUsage[rightName].hasNumberOperations = true;\r\n        }\r\n      }\r\n\r\n      analyzePropUsage(node.left);\r\n      analyzePropUsage(node.right);\r\n    }\r\n\r\n    // Check member access for .length (could be array or string)\r\n    if (t.isMemberExpression(node)) {\r\n      const objectName = extractPropName(node.object);\r\n      const propertyName = t.isIdentifier(node.property) ? node.property.name : null;\r\n\r\n      if (objectName && propUsage[objectName]) {\r\n        if (propertyName === 'length') {\r\n          // Could be array or string, mark both\r\n          propUsage[objectName].usedAsArray = true;\r\n          propUsage[objectName].usedAsString = true;\r\n        } else if (propertyName) {\r\n          // Accessing a property implies object\r\n          propUsage[objectName].usedAsObject = true;\r\n        }\r\n      }\r\n\r\n      analyzePropUsage(node.object);\r\n      if (node.computed) {\r\n        analyzePropUsage(node.property);\r\n      }\r\n    }\r\n\r\n    // Recurse into JSX elements\r\n    if (t.isJSXElement(node)) {\r\n      for (const child of node.children) {\r\n        analyzePropUsage(child);\r\n      }\r\n      for (const attr of node.openingElement.attributes) {\r\n        if (t.isJSXAttribute(attr) && t.isJSXExpressionContainer(attr.value)) {\r\n          analyzePropUsage(attr.value.expression);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (t.isJSXExpressionContainer(node)) {\r\n      analyzePropUsage(node.expression);\r\n    }\r\n\r\n    // Recurse into arrow functions\r\n    if (t.isArrowFunctionExpression(node)) {\r\n      analyzePropUsage(node.body);\r\n    }\r\n\r\n    // Recurse into arrays\r\n    if (Array.isArray(node)) {\r\n      for (const item of node) {\r\n        analyzePropUsage(item);\r\n      }\r\n    }\r\n  }\r\n\r\n  analyzePropUsage(body);\r\n\r\n  // Now infer types based on usage patterns\r\n  for (const prop of component.props) {\r\n    if (prop.type !== 'dynamic') {\r\n      // Already has explicit type from TypeScript, don't override\r\n      continue;\r\n    }\r\n\r\n    const usage = propUsage[prop.name];\r\n\r\n    if (usage.hasArrayMethods) {\r\n      // Definitely an array if array methods are called\r\n      prop.type = 'List<dynamic>';\r\n    } else if (usage.usedAsArray && !usage.hasNumberOperations) {\r\n      // Used as array (e.g., .length on array)\r\n      prop.type = 'List<dynamic>';\r\n    } else if (usage.usedAsBoolean && !usage.usedAsNumber && !usage.usedAsString && !usage.usedAsObject && !usage.usedAsArray) {\r\n      // Used only as boolean\r\n      prop.type = 'bool';\r\n    } else if (usage.hasNumberOperations && !usage.usedAsBoolean && !usage.usedAsArray) {\r\n      // Used in arithmetic operations\r\n      prop.type = 'double';\r\n    } else if (usage.usedAsObject && !usage.usedAsArray && !usage.usedAsBoolean) {\r\n      // Used as object with property access\r\n      prop.type = 'dynamic';\r\n    } else {\r\n      // Keep as dynamic for complex cases\r\n      prop.type = 'dynamic';\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Extract prop name from an expression\r\n */\r\nfunction extractPropName(node) {\r\n  if (t.isIdentifier(node)) {\r\n    return node.name;\r\n  }\r\n  if (t.isMemberExpression(node)) {\r\n    return extractPropName(node.object);\r\n  }\r\n  return null;\r\n}\r\n\r\nmodule.exports = {\r\n  inferPropTypes\r\n};\r\n","/**\r\n * Template Extractor for Hot Reload\r\n *\r\n * Extracts parameterized templates from JSX text nodes for instant hot reload.\r\n * This enables 100% coverage with minimal memory (2KB vs 100KB per component).\r\n *\r\n * Architecture:\r\n * - Build time: Extract templates with {0}, {1} placeholders\r\n * - Runtime: Re-hydrate templates with current state values\r\n * - Hot reload: Send template patches instead of re-rendering\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Extract all templates from JSX render body\r\n *\r\n * Returns a map of node paths to templates:\r\n * {\r\n *   \"div[0].h1[0].text\": {\r\n *     template: \"Count: {0}\",\r\n *     bindings: [\"count\"],\r\n *     slots: [7],\r\n *     path: [0, 0]\r\n *   }\r\n * }\r\n */\r\nfunction extractTemplates(renderBody, component) {\r\n  if (!renderBody) return {};\r\n\r\n  const templates = {};\r\n  let templateCounter = 0;\r\n\r\n  // Build path stack for tracking node positions\r\n  const pathStack = [];\r\n\r\n  /**\r\n   * Traverse JSX tree and extract text templates\r\n   */\r\n  function traverseJSX(node, parentPath = []) {\r\n    if (t.isJSXElement(node)) {\r\n      const tagName = node.openingElement.name.name;\r\n      const elementIndex = pathStack.filter(p => p.tag === tagName).length;\r\n      const currentPath = [...parentPath, elementIndex];\r\n      const pathKey = buildPathKey(tagName, elementIndex, parentPath);\r\n\r\n      pathStack.push({ tag: tagName, index: elementIndex });\r\n\r\n      // Process children\r\n      let textNodeIndex = 0;\r\n      for (const child of node.children) {\r\n        if (t.isJSXText(child)) {\r\n          const text = child.value.trim();\r\n          if (text) {\r\n            // Static text - create template without bindings\r\n            const textPath = `${pathKey}.text[${textNodeIndex}]`;\r\n            templates[textPath] = {\r\n              template: text,\r\n              bindings: [],\r\n              slots: [],\r\n              path: [...currentPath, textNodeIndex],\r\n              type: 'static'\r\n            };\r\n            textNodeIndex++;\r\n          }\r\n        } else if (t.isJSXExpressionContainer(child)) {\r\n          // Expression in text position: <h1>{count}</h1>\r\n          const template = extractTextTemplate(node.children, currentPath, textNodeIndex);\r\n          if (template) {\r\n            const textPath = `${pathKey}.text[${textNodeIndex}]`;\r\n            templates[textPath] = template;\r\n            textNodeIndex++;\r\n          }\r\n        } else if (t.isJSXElement(child)) {\r\n          traverseJSX(child, currentPath);\r\n        }\r\n      }\r\n\r\n      pathStack.pop();\r\n    } else if (t.isJSXFragment(node)) {\r\n      // Handle fragments\r\n      for (const child of node.children) {\r\n        if (t.isJSXElement(child)) {\r\n          traverseJSX(child, parentPath);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract template from mixed text/expression children\r\n   * Example: <h1>Count: {count}</h1> → \"Count: {0}\"\r\n   */\r\n  function extractTextTemplate(children, currentPath, textIndex) {\r\n    let templateStr = '';\r\n    const bindings = [];\r\n    const slots = [];\r\n    let paramIndex = 0;\r\n    let hasExpressions = false;\r\n\r\n    for (const child of children) {\r\n      if (t.isJSXText(child)) {\r\n        const text = child.value;\r\n        templateStr += text;\r\n      } else if (t.isJSXExpressionContainer(child)) {\r\n        hasExpressions = true;\r\n        const binding = extractBinding(child.expression, component);\r\n\r\n        if (binding) {\r\n          // Record placeholder position\r\n          slots.push(templateStr.length);\r\n          templateStr += `{${paramIndex}}`;\r\n          bindings.push(binding);\r\n          paramIndex++;\r\n        } else {\r\n          // Complex expression - can't template it\r\n          templateStr += `{${paramIndex}}`;\r\n          bindings.push('__complex__');\r\n          paramIndex++;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Clean up whitespace\r\n    templateStr = templateStr.trim();\r\n\r\n    if (!hasExpressions) return null;\r\n\r\n    return {\r\n      template: templateStr,\r\n      bindings,\r\n      slots,\r\n      path: [...currentPath, textIndex],\r\n      type: 'dynamic'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract binding name from expression\r\n   * Supports:\r\n   * - Identifiers: {count}\r\n   * - Member expressions: {user.name}\r\n   * - Simple operations: {count + 1}\r\n   */\r\n  function extractBinding(expr, component) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      return buildMemberPath(expr);\r\n    } else if (t.isBinaryExpression(expr) || t.isUnaryExpression(expr)) {\r\n      // Simple operations - extract all identifiers\r\n      const identifiers = [];\r\n      extractIdentifiers(expr, identifiers);\r\n      return identifiers.join('.');\r\n    } else {\r\n      // Complex expression\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build member expression path: user.name → \"user.name\"\r\n   */\r\n  function buildMemberPath(expr) {\r\n    const parts = [];\r\n    let current = expr;\r\n\r\n    while (t.isMemberExpression(current)) {\r\n      if (t.isIdentifier(current.property)) {\r\n        parts.unshift(current.property.name);\r\n      }\r\n      current = current.object;\r\n    }\r\n\r\n    if (t.isIdentifier(current)) {\r\n      parts.unshift(current.name);\r\n    }\r\n\r\n    return parts.join('.');\r\n  }\r\n\r\n  /**\r\n   * Extract all identifiers from expression\r\n   */\r\n  function extractIdentifiers(expr, result) {\r\n    if (t.isIdentifier(expr)) {\r\n      result.push(expr.name);\r\n    } else if (t.isBinaryExpression(expr) || t.isLogicalExpression(expr)) {\r\n      extractIdentifiers(expr.left, result);\r\n      extractIdentifiers(expr.right, result);\r\n    } else if (t.isUnaryExpression(expr)) {\r\n      extractIdentifiers(expr.argument, result);\r\n    } else if (t.isMemberExpression(expr)) {\r\n      result.push(buildMemberPath(expr));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build path key for template map\r\n   * Example: div[0].h1[0].text → \"div[0].h1[0]\"\r\n   */\r\n  function buildPathKey(tagName, index, parentPath) {\r\n    const parentKeys = [];\r\n    let currentPath = parentPath;\r\n\r\n    // Build parent path from indices\r\n    // This is simplified - in production we'd track tag names\r\n    for (let i = 0; i < currentPath.length; i++) {\r\n      parentKeys.push(`[${currentPath[i]}]`);\r\n    }\r\n\r\n    return `${parentKeys.join('.')}.${tagName}[${index}]`.replace(/^\\./, '');\r\n  }\r\n\r\n  // Start traversal\r\n  traverseJSX(renderBody);\r\n\r\n  return templates;\r\n}\r\n\r\n/**\r\n * Extract templates for attributes (props)\r\n * Example: <div className={`count-${count}`} />\r\n */\r\nfunction extractAttributeTemplates(renderBody, component) {\r\n  const templates = {};\r\n\r\n  function traverseJSX(node, parentPath = []) {\r\n    if (t.isJSXElement(node)) {\r\n      const tagName = node.openingElement.name.name;\r\n      const currentPath = [...parentPath, 0]; // Simplified\r\n\r\n      // Check attributes for template expressions\r\n      for (const attr of node.openingElement.attributes) {\r\n        if (t.isJSXAttribute(attr) && t.isJSXExpressionContainer(attr.value)) {\r\n          const expr = attr.value.expression;\r\n\r\n          // Template literal: className={`count-${count}`}\r\n          if (t.isTemplateLiteral(expr)) {\r\n            const template = extractTemplateLiteral(expr);\r\n            if (template) {\r\n              const attrPath = `${tagName}[${currentPath.join(',')}].@${attr.name.name}`;\r\n              templates[attrPath] = {\r\n                ...template,\r\n                path: currentPath,\r\n                attribute: attr.name.name\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Traverse children\r\n      for (const child of node.children) {\r\n        if (t.isJSXElement(child)) {\r\n          traverseJSX(child, currentPath);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function extractTemplateLiteral(node) {\r\n    let templateStr = '';\r\n    const bindings = [];\r\n    const slots = [];\r\n\r\n    for (let i = 0; i < node.quasis.length; i++) {\r\n      const quasi = node.quasis[i];\r\n      templateStr += quasi.value.raw;\r\n\r\n      if (i < node.expressions.length) {\r\n        const expr = node.expressions[i];\r\n        slots.push(templateStr.length);\r\n        templateStr += `{${i}}`;\r\n\r\n        if (t.isIdentifier(expr)) {\r\n          bindings.push(expr.name);\r\n        } else {\r\n          bindings.push('__complex__');\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      template: templateStr,\r\n      bindings,\r\n      slots,\r\n      type: 'attribute'\r\n    };\r\n  }\r\n\r\n  if (renderBody) {\r\n    traverseJSX(renderBody);\r\n  }\r\n\r\n  return templates;\r\n}\r\n\r\n/**\r\n * Generate template map JSON file content\r\n */\r\nfunction generateTemplateMapJSON(componentName, templates, attributeTemplates) {\r\n  const allTemplates = {\r\n    ...templates,\r\n    ...attributeTemplates\r\n  };\r\n\r\n  return {\r\n    component: componentName,\r\n    version: '1.0',\r\n    generatedAt: Date.now(),\r\n    templates: Object.entries(allTemplates).reduce((acc, [path, template]) => {\r\n      acc[path] = {\r\n        template: template.template,\r\n        bindings: template.bindings,\r\n        slots: template.slots,\r\n        path: template.path,\r\n        type: template.type\r\n      };\r\n      return acc;\r\n    }, {})\r\n  };\r\n}\r\n\r\n/**\r\n * Add template metadata to component for C# code generation\r\n */\r\nfunction addTemplateMetadata(component, templates) {\r\n  component.templates = templates;\r\n\r\n  // Add template bindings to track which state affects which templates\r\n  component.templateBindings = new Map();\r\n\r\n  for (const [path, template] of Object.entries(templates)) {\r\n    for (const binding of template.bindings) {\r\n      if (!component.templateBindings.has(binding)) {\r\n        component.templateBindings.set(binding, []);\r\n      }\r\n      component.templateBindings.get(binding).push(path);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  extractTemplates,\r\n  extractAttributeTemplates,\r\n  generateTemplateMapJSON,\r\n  addTemplateMetadata\r\n};\r\n","/**\r\n * Loop Template Extractor\r\n *\r\n * Extracts parameterized loop templates from .map() expressions for predictive rendering.\r\n * This enables 100% coverage for list rendering patterns with O(1) memory.\r\n *\r\n * Architecture:\r\n * - Build time: Detect .map() patterns and extract item templates\r\n * - Runtime (Rust predictor): Use Babel-generated templates as primary source\r\n * - Fallback: Rust runtime extraction if Babel can't generate template\r\n *\r\n * Example:\r\n * {todos.map(todo => <li>{todo.text}</li>)}\r\n * →\r\n * LoopTemplate {\r\n *   arrayBinding: \"todos\",\r\n *   itemVar: \"todo\",\r\n *   itemTemplate: ElementTemplate {\r\n *     tag: \"li\",\r\n *     children: [TextTemplate { template: \"{0}\", bindings: [\"item.text\"] }]\r\n *   }\r\n * }\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Extract all loop templates from JSX render body\r\n *\r\n * Returns array of loop template metadata:\r\n * [\r\n *   {\r\n *     stateKey: \"todos\",\r\n *     arrayBinding: \"todos\",\r\n *     itemVar: \"todo\",\r\n *     indexVar: \"index\",\r\n *     keyBinding: \"item.id\",\r\n *     itemTemplate: { ... }\r\n *   }\r\n * ]\r\n */\r\nfunction extractLoopTemplates(renderBody, component) {\r\n  if (!renderBody) return [];\r\n\r\n  const loopTemplates = [];\r\n\r\n  /**\r\n   * Traverse JSX tree looking for .map() call expressions\r\n   */\r\n  function traverseJSX(node) {\r\n    if (t.isJSXElement(node)) {\r\n      // Check attributes for .map() expressions\r\n      for (const attr of node.openingElement.attributes) {\r\n        if (t.isJSXAttribute(attr) && t.isJSXExpressionContainer(attr.value)) {\r\n          findMapExpressions(attr.value.expression);\r\n        }\r\n      }\r\n\r\n      // Check children for .map() expressions\r\n      for (const child of node.children) {\r\n        if (t.isJSXExpressionContainer(child)) {\r\n          findMapExpressions(child.expression);\r\n        } else if (t.isJSXElement(child)) {\r\n          traverseJSX(child);\r\n        } else if (t.isJSXFragment(child)) {\r\n          for (const fragmentChild of child.children) {\r\n            if (t.isJSXElement(fragmentChild)) {\r\n              traverseJSX(fragmentChild);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (t.isJSXFragment(node)) {\r\n      for (const child of node.children) {\r\n        if (t.isJSXElement(child)) {\r\n          traverseJSX(child);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find .map() call expressions recursively\r\n   */\r\n  function findMapExpressions(expr) {\r\n    if (!expr) return;\r\n\r\n    // Direct .map() call: items.map(...)\r\n    if (t.isCallExpression(expr) &&\r\n        t.isMemberExpression(expr.callee) &&\r\n        t.isIdentifier(expr.callee.property) &&\r\n        expr.callee.property.name === 'map') {\r\n\r\n      const loopTemplate = extractLoopTemplate(expr);\r\n      if (loopTemplate) {\r\n        loopTemplates.push(loopTemplate);\r\n      }\r\n    }\r\n\r\n    // Chained operations: items.filter(...).map(...)\r\n    if (t.isCallExpression(expr) &&\r\n        t.isMemberExpression(expr.callee)) {\r\n      findMapExpressions(expr.callee.object);\r\n    }\r\n\r\n    // Wrapped in other expressions\r\n    if (t.isLogicalExpression(expr) || t.isConditionalExpression(expr)) {\r\n      findMapExpressions(expr.left || expr.test);\r\n      findMapExpressions(expr.right || expr.consequent);\r\n      if (expr.alternate) findMapExpressions(expr.alternate);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract loop template from .map() call expression\r\n   *\r\n   * Example:\r\n   * todos.map((todo, index) => <li key={todo.id}>{todo.text}</li>)\r\n   */\r\n  function extractLoopTemplate(mapCallExpr) {\r\n    // Get array binding (the object being mapped)\r\n    const arrayBinding = extractArrayBinding(mapCallExpr.callee.object);\r\n    if (!arrayBinding) {\r\n      console.warn('[Loop Template] Could not extract array binding from .map()');\r\n      return null;\r\n    }\r\n\r\n    // Get callback function (arrow function or function expression)\r\n    const callback = mapCallExpr.arguments[0];\r\n    if (!t.isArrowFunctionExpression(callback) && !t.isFunctionExpression(callback)) {\r\n      console.warn('[Loop Template] .map() callback is not a function');\r\n      return null;\r\n    }\r\n\r\n    // Get item and index parameter names\r\n    const itemVar = callback.params[0] ? callback.params[0].name : 'item';\r\n    const indexVar = callback.params[1] ? callback.params[1].name : null;\r\n\r\n    // Get JSX element returned by callback\r\n    const jsxElement = extractJSXFromCallback(callback);\r\n    if (!jsxElement) {\r\n      console.warn('[Loop Template] .map() callback does not return JSX element');\r\n      return null;\r\n    }\r\n\r\n    // Extract item template from JSX element\r\n    const itemTemplate = extractElementTemplate(jsxElement, itemVar, indexVar);\r\n    if (!itemTemplate) {\r\n      console.warn('[Loop Template] Could not extract item template from JSX');\r\n      return null;\r\n    }\r\n\r\n    // Extract key binding\r\n    const keyBinding = extractKeyBinding(jsxElement, itemVar);\r\n\r\n    return {\r\n      stateKey: arrayBinding,  // For C# attribute: which state variable triggers this template\r\n      arrayBinding,            // Runtime: which array to iterate\r\n      itemVar,                 // Runtime: variable name for each item\r\n      indexVar,                // Runtime: variable name for index (optional)\r\n      keyBinding,              // Runtime: expression for React key (optional)\r\n      itemTemplate             // Runtime: template for each list item\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract array binding from member expression\r\n   *\r\n   * Examples:\r\n   * - todos.map(...) → \"todos\"\r\n   * - this.state.items.map(...) → \"items\"\r\n   * - [...todos].map(...) → \"todos\"\r\n   */\r\n  function extractArrayBinding(expr) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      // Get the last property name\r\n      if (t.isIdentifier(expr.property)) {\r\n        return expr.property.name;\r\n      }\r\n    } else if (t.isCallExpression(expr)) {\r\n      // Handle array methods like .reverse(), .slice()\r\n      if (t.isMemberExpression(expr.callee)) {\r\n        return extractArrayBinding(expr.callee.object);\r\n      }\r\n    } else if (t.isArrayExpression(expr)) {\r\n      // Spread array: [...todos]\r\n      if (expr.elements.length > 0 && t.isSpreadElement(expr.elements[0])) {\r\n        return extractArrayBinding(expr.elements[0].argument);\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract JSX element from callback function body\r\n   */\r\n  function extractJSXFromCallback(callback) {\r\n    const body = callback.body;\r\n\r\n    // Arrow function with direct JSX return: (...) => <li>...</li>\r\n    if (t.isJSXElement(body)) {\r\n      return body;\r\n    }\r\n\r\n    // Arrow function or function expression with block body\r\n    if (t.isBlockStatement(body)) {\r\n      // Find return statement\r\n      for (const stmt of body.body) {\r\n        if (t.isReturnStatement(stmt) && t.isJSXElement(stmt.argument)) {\r\n          return stmt.argument;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Expression wrapped in parentheses or conditional\r\n    if (t.isConditionalExpression(body)) {\r\n      // Handle ternary: condition ? <div/> : <span/>\r\n      // For now, just take the consequent (true branch)\r\n      if (t.isJSXElement(body.consequent)) {\r\n        return body.consequent;\r\n      }\r\n    }\r\n\r\n    if (t.isLogicalExpression(body) && body.operator === '&&') {\r\n      // Handle logical AND: condition && <div/>\r\n      if (t.isJSXElement(body.right)) {\r\n        return body.right;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract key binding from JSX element\r\n   *\r\n   * Example: <li key={todo.id}> → \"item.id\"\r\n   */\r\n  function extractKeyBinding(jsxElement, itemVar) {\r\n    const keyAttr = jsxElement.openingElement.attributes.find(\r\n      attr => t.isJSXAttribute(attr) &&\r\n              t.isIdentifier(attr.name) &&\r\n              attr.name.name === 'key'\r\n    );\r\n\r\n    if (!keyAttr) return null;\r\n\r\n    const keyValue = keyAttr.value;\r\n    if (t.isJSXExpressionContainer(keyValue)) {\r\n      return buildBindingPath(keyValue.expression, itemVar);\r\n    } else if (t.isStringLiteral(keyValue)) {\r\n      return null; // Static key (not based on item data)\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract element template from JSX element\r\n   *\r\n   * Returns template in format compatible with Rust LoopTemplate:\r\n   * {\r\n   *   type: \"Element\",\r\n   *   tag: \"li\",\r\n   *   propsTemplates: { className: { template: \"{0}\", bindings: [\"item.done\"], ... } },\r\n   *   childrenTemplates: [ ... ],\r\n   *   keyBinding: \"item.id\"\r\n   * }\r\n   */\r\n  function extractElementTemplate(jsxElement, itemVar, indexVar) {\r\n    const tagName = jsxElement.openingElement.name.name;\r\n\r\n    // Extract prop templates\r\n    const propsTemplates = extractPropTemplates(\r\n      jsxElement.openingElement.attributes,\r\n      itemVar,\r\n      indexVar\r\n    );\r\n\r\n    // Extract children templates\r\n    const childrenTemplates = extractChildrenTemplates(\r\n      jsxElement.children,\r\n      itemVar,\r\n      indexVar\r\n    );\r\n\r\n    return {\r\n      type: 'Element',\r\n      tag: tagName,\r\n      propsTemplates: Object.keys(propsTemplates).length > 0 ? propsTemplates : null,\r\n      childrenTemplates: childrenTemplates.length > 0 ? childrenTemplates : null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract prop templates from JSX attributes\r\n   *\r\n   * Handles:\r\n   * - Simple bindings: checked={todo.done} → { template: \"{0}\", bindings: [\"item.done\"] }\r\n   * - Conditionals: className={todo.done ? 'done' : 'pending'} → conditional template\r\n   * - Template literals: className={`item-${todo.id}`} → template with placeholder\r\n   */\r\n  function extractPropTemplates(attributes, itemVar, indexVar) {\r\n    const templates = {};\r\n\r\n    for (const attr of attributes) {\r\n      // Skip non-JSXAttribute (spreads, etc.)\r\n      if (!t.isJSXAttribute(attr)) continue;\r\n\r\n      // Skip key attribute (handled separately)\r\n      if (attr.name.name === 'key') continue;\r\n\r\n      const propName = attr.name.name;\r\n      const propValue = attr.value;\r\n\r\n      // Static string: className=\"static\"\r\n      if (t.isStringLiteral(propValue)) {\r\n        templates[propName] = {\r\n          template: propValue.value,\r\n          bindings: [],\r\n          slots: [],\r\n          type: 'static'\r\n        };\r\n        continue;\r\n      }\r\n\r\n      // Expression: {todo.done}, {todo.done ? 'yes' : 'no'}\r\n      if (t.isJSXExpressionContainer(propValue)) {\r\n        const expr = propValue.expression;\r\n\r\n        // Conditional: {todo.done ? 'active' : 'inactive'}\r\n        if (t.isConditionalExpression(expr)) {\r\n          const conditionalTemplate = extractConditionalTemplate(expr, itemVar, indexVar);\r\n          if (conditionalTemplate) {\r\n            templates[propName] = conditionalTemplate;\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // Template literal: {`item-${todo.id}`}\r\n        if (t.isTemplateLiteral(expr)) {\r\n          const template = extractTemplateFromTemplateLiteral(expr, itemVar, indexVar);\r\n          if (template) {\r\n            templates[propName] = template;\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // Simple binding: {todo.text}, {todo.done}\r\n        const binding = buildBindingPath(expr, itemVar);\r\n        if (binding) {\r\n          templates[propName] = {\r\n            template: '{0}',\r\n            bindings: [binding],\r\n            slots: [0],\r\n            type: 'binding'\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return templates;\r\n  }\r\n\r\n  /**\r\n   * Extract conditional template from ternary expression\r\n   *\r\n   * Example: todo.done ? 'completed' : 'pending'\r\n   * →\r\n   * {\r\n   *   template: \"{0}\",\r\n   *   bindings: [\"item.done\"],\r\n   *   conditionalTemplates: { \"true\": \"completed\", \"false\": \"pending\" },\r\n   *   conditionalBindingIndex: 0\r\n   * }\r\n   */\r\n  function extractConditionalTemplate(conditionalExpr, itemVar, indexVar) {\r\n    const test = conditionalExpr.test;\r\n    const consequent = conditionalExpr.consequent;\r\n    const alternate = conditionalExpr.alternate;\r\n\r\n    // Extract binding from test expression\r\n    const binding = buildBindingPath(test, itemVar);\r\n    if (!binding) return null;\r\n\r\n    // Extract literal values from consequent and alternate\r\n    const trueValue = extractLiteralValue(consequent);\r\n    const falseValue = extractLiteralValue(alternate);\r\n\r\n    if (trueValue === null || falseValue === null) {\r\n      // Complex expressions in branches - can't template it\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      template: '{0}',\r\n      bindings: [binding],\r\n      slots: [0],\r\n      conditionalTemplates: {\r\n        'true': trueValue,\r\n        'false': falseValue\r\n      },\r\n      conditionalBindingIndex: 0,\r\n      type: 'conditional'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract template from template literal\r\n   *\r\n   * Example: `item-${todo.id}`\r\n   * →\r\n   * {\r\n   *   template: \"item-{0}\",\r\n   *   bindings: [\"item.id\"],\r\n   *   slots: [5]\r\n   * }\r\n   */\r\n  function extractTemplateFromTemplateLiteral(templateLiteral, itemVar, indexVar) {\r\n    let templateStr = '';\r\n    const bindings = [];\r\n    const slots = [];\r\n\r\n    for (let i = 0; i < templateLiteral.quasis.length; i++) {\r\n      const quasi = templateLiteral.quasis[i];\r\n      templateStr += quasi.value.raw;\r\n\r\n      if (i < templateLiteral.expressions.length) {\r\n        const expr = templateLiteral.expressions[i];\r\n        const binding = buildBindingPath(expr, itemVar);\r\n\r\n        if (binding) {\r\n          slots.push(templateStr.length);\r\n          templateStr += `{${bindings.length}}`;\r\n          bindings.push(binding);\r\n        } else {\r\n          // Complex expression - can't template it\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      template: templateStr,\r\n      bindings,\r\n      slots,\r\n      type: 'template-literal'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract children templates from JSX children\r\n   *\r\n   * Returns array of templates (text or element)\r\n   */\r\n  function extractChildrenTemplates(children, itemVar, indexVar) {\r\n    const templates = [];\r\n\r\n    for (const child of children) {\r\n      // Static text: <li>Static text</li>\r\n      if (t.isJSXText(child)) {\r\n        const text = child.value.trim();\r\n        if (text) {\r\n          templates.push({\r\n            type: 'Text',\r\n            template: text,\r\n            bindings: [],\r\n            slots: []\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Expression: <li>{todo.text}</li>\r\n      if (t.isJSXExpressionContainer(child)) {\r\n        const template = extractTextTemplate(child.expression, itemVar, indexVar);\r\n        if (template) {\r\n          templates.push(template);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Nested element: <li><span>{todo.text}</span></li>\r\n      if (t.isJSXElement(child)) {\r\n        const elementTemplate = extractElementTemplate(child, itemVar, indexVar);\r\n        if (elementTemplate) {\r\n          templates.push(elementTemplate);\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    return templates;\r\n  }\r\n\r\n  /**\r\n   * Extract text template from expression\r\n   *\r\n   * Handles:\r\n   * - Simple binding: {todo.text} → { template: \"{0}\", bindings: [\"item.text\"] }\r\n   * - Conditional: {todo.done ? '✓' : '○'} → conditional template\r\n   * - Complex: {todo.count + 1} → transformation template (future)\r\n   */\r\n  function extractTextTemplate(expr, itemVar, indexVar) {\r\n    // Conditional expression: {todo.done ? '✓' : '○'}\r\n    if (t.isConditionalExpression(expr)) {\r\n      const conditionalTemplate = extractConditionalTemplate(expr, itemVar, indexVar);\r\n      if (conditionalTemplate) {\r\n        return {\r\n          type: 'Text',\r\n          ...conditionalTemplate\r\n        };\r\n      }\r\n    }\r\n\r\n    // Simple binding: {todo.text}\r\n    const binding = buildBindingPath(expr, itemVar);\r\n    if (binding) {\r\n      return {\r\n        type: 'Text',\r\n        template: '{0}',\r\n        bindings: [binding],\r\n        slots: [0]\r\n      };\r\n    }\r\n\r\n    // TODO: Handle binary expressions (todo.count + 1), method calls (todo.text.toUpperCase()), etc.\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Build binding path from expression relative to item variable\r\n   *\r\n   * Examples:\r\n   * - todo → null (just the item itself)\r\n   * - todo.text → \"item.text\"\r\n   * - todo.author.name → \"item.author.name\"\r\n   * - index → \"index\"\r\n   */\r\n  function buildBindingPath(expr, itemVar) {\r\n    if (t.isIdentifier(expr)) {\r\n      // Just the item variable itself\r\n      if (expr.name === itemVar) {\r\n        return null; // Can't template the entire item object\r\n      }\r\n      // Index variable\r\n      if (expr.name === 'index') {\r\n        return 'index';\r\n      }\r\n      // Other identifier (likely a closure variable)\r\n      return null;\r\n    }\r\n\r\n    if (t.isMemberExpression(expr)) {\r\n      const path = buildMemberExpressionPath(expr);\r\n      if (path && path.startsWith(itemVar + '.')) {\r\n        // Replace item variable with \"item\" prefix\r\n        return 'item' + path.substring(itemVar.length);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Build full path from member expression\r\n   *\r\n   * Example: todo.author.name → \"todo.author.name\"\r\n   */\r\n  function buildMemberExpressionPath(expr) {\r\n    const parts = [];\r\n    let current = expr;\r\n\r\n    while (t.isMemberExpression(current)) {\r\n      if (t.isIdentifier(current.property)) {\r\n        parts.unshift(current.property.name);\r\n      } else {\r\n        return null; // Computed property (not supported)\r\n      }\r\n      current = current.object;\r\n    }\r\n\r\n    if (t.isIdentifier(current)) {\r\n      parts.unshift(current.name);\r\n      return parts.join('.');\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract literal value from expression\r\n   */\r\n  function extractLiteralValue(expr) {\r\n    if (t.isStringLiteral(expr)) {\r\n      return expr.value;\r\n    } else if (t.isNumericLiteral(expr)) {\r\n      return expr.value;\r\n    } else if (t.isBooleanLiteral(expr)) {\r\n      return expr.value;\r\n    } else if (t.isNullLiteral(expr)) {\r\n      return null;\r\n    }\r\n    return null; // Complex expression\r\n  }\r\n\r\n  // Start traversal\r\n  traverseJSX(renderBody);\r\n\r\n  return loopTemplates;\r\n}\r\n\r\nmodule.exports = {\r\n  extractLoopTemplates\r\n};\r\n","/**\r\n * Structural Template Extractor (Phase 5)\r\n *\r\n * Extracts templates for conditional rendering patterns where the DOM structure changes.\r\n * This handles cases like loading states, authentication states, error boundaries, etc.\r\n *\r\n * Examples:\r\n * - {isLoading ? <Spinner /> : <Content />}\r\n * - {user ? <Dashboard /> : <LoginForm />}\r\n * - {error && <ErrorMessage />}\r\n *\r\n * Architecture:\r\n * - Build time: Detect conditional patterns and extract both branches\r\n * - Runtime: Store structural templates with condition binding\r\n * - Prediction: Choose correct branch based on current state\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Extract structural templates from JSX render body\r\n *\r\n * Returns array of structural template metadata:\r\n * [\r\n *   {\r\n *     type: 'conditional',\r\n *     stateKey: 'isLoggedIn',\r\n *     conditionBinding: 'isLoggedIn',\r\n *     branches: {\r\n *       'true': { type: 'Element', tag: 'div', ... },\r\n *       'false': { type: 'Element', tag: 'div', ... }\r\n *     }\r\n *   }\r\n * ]\r\n */\r\nfunction extractStructuralTemplates(renderBody, component) {\r\n  if (!renderBody) return [];\r\n\r\n  const structuralTemplates = [];\r\n\r\n  /**\r\n   * Traverse JSX tree looking for conditional expressions that affect structure\r\n   */\r\n  function traverseJSX(node, path = []) {\r\n    if (t.isJSXElement(node)) {\r\n      // Check children for conditional expressions\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n\r\n        if (t.isJSXExpressionContainer(child)) {\r\n          const expr = child.expression;\r\n\r\n          // Ternary: {condition ? <A /> : <B />}\r\n          if (t.isConditionalExpression(expr)) {\r\n            const template = extractConditionalStructuralTemplate(expr, component, [...path, i]);\r\n            if (template) {\r\n              structuralTemplates.push(template);\r\n            }\r\n          }\r\n\r\n          // Logical AND: {condition && <Component />}\r\n          if (t.isLogicalExpression(expr) && expr.operator === '&&') {\r\n            const template = extractLogicalAndTemplate(expr, component, [...path, i]);\r\n            if (template) {\r\n              structuralTemplates.push(template);\r\n            }\r\n          }\r\n        } else if (t.isJSXElement(child)) {\r\n          traverseJSX(child, [...path, i]);\r\n        }\r\n      }\r\n    } else if (t.isJSXFragment(node)) {\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n        if (t.isJSXElement(child)) {\r\n          traverseJSX(child, [...path, i]);\r\n        } else if (t.isJSXExpressionContainer(child)) {\r\n          const expr = child.expression;\r\n\r\n          if (t.isConditionalExpression(expr)) {\r\n            const template = extractConditionalStructuralTemplate(expr, component, [...path, i]);\r\n            if (template) {\r\n              structuralTemplates.push(template);\r\n            }\r\n          }\r\n\r\n          if (t.isLogicalExpression(expr) && expr.operator === '&&') {\r\n            const template = extractLogicalAndTemplate(expr, component, [...path, i]);\r\n            if (template) {\r\n              structuralTemplates.push(template);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract structural template from ternary conditional\r\n   *\r\n   * Example: {isLoggedIn ? <Dashboard /> : <LoginForm />}\r\n   * →\r\n   * {\r\n   *   type: 'conditional',\r\n   *   conditionBinding: 'isLoggedIn',\r\n   *   branches: {\r\n   *     'true': ElementTemplate { tag: 'Dashboard', ... },\r\n   *     'false': ElementTemplate { tag: 'LoginForm', ... }\r\n   *   }\r\n   * }\r\n   */\r\n  function extractConditionalStructuralTemplate(conditionalExpr, component, path) {\r\n    const test = conditionalExpr.test;\r\n    const consequent = conditionalExpr.consequent;\r\n    const alternate = conditionalExpr.alternate;\r\n\r\n    // Extract condition binding\r\n    const conditionBinding = extractBinding(test, component);\r\n    if (!conditionBinding) {\r\n      console.warn('[Structural Template] Could not extract condition binding');\r\n      return null;\r\n    }\r\n\r\n    // Check if both branches are JSX elements (structural change)\r\n    const hasTrueBranch = t.isJSXElement(consequent) || t.isJSXFragment(consequent);\r\n    const hasFalseBranch = t.isJSXElement(alternate) || t.isJSXFragment(alternate) || t.isNullLiteral(alternate);\r\n\r\n    if (!hasTrueBranch && !hasFalseBranch) {\r\n      // Not a structural template (probably just conditional text)\r\n      return null;\r\n    }\r\n\r\n    // Extract templates for both branches\r\n    const branches = {};\r\n\r\n    if (hasTrueBranch) {\r\n      const trueBranch = extractElementOrFragmentTemplate(consequent, component);\r\n      if (trueBranch) {\r\n        branches['true'] = trueBranch;\r\n      }\r\n    }\r\n\r\n    if (hasFalseBranch) {\r\n      if (t.isNullLiteral(alternate)) {\r\n        branches['false'] = { type: 'Null' };\r\n      } else {\r\n        const falseBranch = extractElementOrFragmentTemplate(alternate, component);\r\n        if (falseBranch) {\r\n          branches['false'] = falseBranch;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Determine state key (for C# attribute)\r\n    const stateKey = extractStateKey(test, component);\r\n\r\n    return {\r\n      type: 'conditional',\r\n      stateKey: stateKey || conditionBinding,\r\n      conditionBinding,\r\n      branches,\r\n      path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract structural template from logical AND\r\n   *\r\n   * Example: {error && <ErrorMessage />}\r\n   * →\r\n   * {\r\n   *   type: 'logicalAnd',\r\n   *   conditionBinding: 'error',\r\n   *   branches: {\r\n   *     'truthy': ElementTemplate { tag: 'ErrorMessage', ... },\r\n   *     'falsy': { type: 'Null' }\r\n   *   }\r\n   * }\r\n   */\r\n  function extractLogicalAndTemplate(logicalExpr, component, path) {\r\n    const left = logicalExpr.left;\r\n    const right = logicalExpr.right;\r\n\r\n    // Extract condition binding from left side\r\n    const conditionBinding = extractBinding(left, component);\r\n    if (!conditionBinding) {\r\n      return null;\r\n    }\r\n\r\n    // Check if right side is JSX element (structural change)\r\n    if (!t.isJSXElement(right) && !t.isJSXFragment(right)) {\r\n      return null;\r\n    }\r\n\r\n    // Extract template for truthy case\r\n    const truthyBranch = extractElementOrFragmentTemplate(right, component);\r\n    if (!truthyBranch) {\r\n      return null;\r\n    }\r\n\r\n    const stateKey = extractStateKey(left, component);\r\n\r\n    return {\r\n      type: 'logicalAnd',\r\n      stateKey: stateKey || conditionBinding,\r\n      conditionBinding,\r\n      branches: {\r\n        'truthy': truthyBranch,\r\n        'falsy': { type: 'Null' }\r\n      },\r\n      path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract element or fragment template\r\n   */\r\n  function extractElementOrFragmentTemplate(node, component) {\r\n    if (t.isJSXElement(node)) {\r\n      return extractSimpleElementTemplate(node, component);\r\n    } else if (t.isJSXFragment(node)) {\r\n      return {\r\n        type: 'Fragment',\r\n        children: node.children\r\n          .filter(child => t.isJSXElement(child) || t.isJSXText(child))\r\n          .map(child => {\r\n            if (t.isJSXElement(child)) {\r\n              return extractSimpleElementTemplate(child, component);\r\n            } else if (t.isJSXText(child)) {\r\n              const text = child.value.trim();\r\n              return text ? { type: 'Text', content: text } : null;\r\n            }\r\n          })\r\n          .filter(Boolean)\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract simple element template (without nested state dependencies)\r\n   *\r\n   * For structural templates, we extract a simplified version that captures:\r\n   * - Tag name\r\n   * - Static props\r\n   * - Structure (not deeply nested templates)\r\n   */\r\n  function extractSimpleElementTemplate(jsxElement, component) {\r\n    const tagName = jsxElement.openingElement.name.name;\r\n    const attributes = jsxElement.openingElement.attributes;\r\n\r\n    // Extract static props only (complex props handled separately)\r\n    const props = {};\r\n    for (const attr of attributes) {\r\n      if (t.isJSXAttribute(attr)) {\r\n        const propName = attr.name.name;\r\n        const propValue = attr.value;\r\n\r\n        if (t.isStringLiteral(propValue)) {\r\n          props[propName] = propValue.value;\r\n        } else if (t.isJSXExpressionContainer(propValue)) {\r\n          // Mark as dynamic (will be re-evaluated)\r\n          const expr = propValue.expression;\r\n          if (t.isIdentifier(expr)) {\r\n            props[propName] = { binding: expr.name };\r\n          } else {\r\n            props[propName] = { expression: true };\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Extract children (simplified)\r\n    const children = jsxElement.children\r\n      .filter(child => t.isJSXElement(child) || t.isJSXText(child))\r\n      .map(child => {\r\n        if (t.isJSXElement(child)) {\r\n          return extractSimpleElementTemplate(child, component);\r\n        } else if (t.isJSXText(child)) {\r\n          const text = child.value.trim();\r\n          return text ? { type: 'Text', content: text } : null;\r\n        }\r\n      })\r\n      .filter(Boolean);\r\n\r\n    return {\r\n      type: 'Element',\r\n      tag: tagName,\r\n      props: Object.keys(props).length > 0 ? props : null,\r\n      children: children.length > 0 ? children : null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract binding from expression\r\n   */\r\n  function extractBinding(expr, component) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      return buildMemberPath(expr);\r\n    } else if (t.isUnaryExpression(expr) && expr.operator === '!') {\r\n      // Handle !isLoading\r\n      const binding = extractBinding(expr.argument, component);\r\n      return binding ? `!${binding}` : null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract state key (root variable name) from expression\r\n   */\r\n  function extractStateKey(expr, component) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      // Get root object: user.isLoggedIn → \"user\"\r\n      let current = expr;\r\n      while (t.isMemberExpression(current)) {\r\n        current = current.object;\r\n      }\r\n      if (t.isIdentifier(current)) {\r\n        return current.name;\r\n      }\r\n    } else if (t.isUnaryExpression(expr)) {\r\n      return extractStateKey(expr.argument, component);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Build member expression path\r\n   */\r\n  function buildMemberPath(expr) {\r\n    const parts = [];\r\n    let current = expr;\r\n\r\n    while (t.isMemberExpression(current)) {\r\n      if (t.isIdentifier(current.property)) {\r\n        parts.unshift(current.property.name);\r\n      }\r\n      current = current.object;\r\n    }\r\n\r\n    if (t.isIdentifier(current)) {\r\n      parts.unshift(current.name);\r\n    }\r\n\r\n    return parts.join('.');\r\n  }\r\n\r\n  // Start traversal\r\n  traverseJSX(renderBody);\r\n\r\n  return structuralTemplates;\r\n}\r\n\r\nmodule.exports = {\r\n  extractStructuralTemplates\r\n};\r\n","/**\r\n * Expression Template Extractor (Phase 6)\r\n *\r\n * Extracts templates for computed values and transformations.\r\n * This handles cases like number formatting, arithmetic, string operations, etc.\r\n *\r\n * Examples:\r\n * - {price.toFixed(2)}\r\n * - {count * 2 + 1}\r\n * - {name.toUpperCase()}\r\n * - {items.length}\r\n *\r\n * Architecture:\r\n * - Build time: Detect expression patterns and extract transformation metadata\r\n * - Runtime: Store expression templates with bindings and transforms\r\n * - Prediction: Apply transforms to current state values\r\n *\r\n * Security Note:\r\n * Only safe, whitelisted transformations are supported. No arbitrary JavaScript execution.\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Supported transformation types\r\n */\r\nconst SUPPORTED_TRANSFORMS = {\r\n  // Number formatting\r\n  'toFixed': { type: 'numberFormat', safe: true },\r\n  'toPrecision': { type: 'numberFormat', safe: true },\r\n  'toExponential': { type: 'numberFormat', safe: true },\r\n\r\n  // String operations\r\n  'toUpperCase': { type: 'stringTransform', safe: true },\r\n  'toLowerCase': { type: 'stringTransform', safe: true },\r\n  'trim': { type: 'stringTransform', safe: true },\r\n  'substring': { type: 'stringTransform', safe: true },\r\n  'substr': { type: 'stringTransform', safe: true },\r\n  'slice': { type: 'stringTransform', safe: true },\r\n\r\n  // Array operations\r\n  'length': { type: 'property', safe: true },\r\n  'join': { type: 'arrayTransform', safe: true },\r\n\r\n  // Math operations (handled separately via binary expressions)\r\n  // +, -, *, /, %\r\n};\r\n\r\n/**\r\n * Extract expression templates from JSX render body\r\n *\r\n * Returns array of expression template metadata:\r\n * [\r\n *   {\r\n *     type: 'expression',\r\n *     template: '${0}',\r\n *     bindings: ['price'],\r\n *     transforms: [\r\n *       { type: 'toFixed', args: [2] }\r\n *     ]\r\n *   }\r\n * ]\r\n */\r\nfunction extractExpressionTemplates(renderBody, component) {\r\n  if (!renderBody) return [];\r\n\r\n  const expressionTemplates = [];\r\n\r\n  /**\r\n   * Traverse JSX tree looking for expression containers\r\n   */\r\n  function traverseJSX(node, path = []) {\r\n    if (t.isJSXElement(node)) {\r\n      // Check children for expressions\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n\r\n        if (t.isJSXExpressionContainer(child)) {\r\n          const template = extractExpressionTemplate(child.expression, component, [...path, i]);\r\n          if (template) {\r\n            expressionTemplates.push(template);\r\n          }\r\n        } else if (t.isJSXElement(child)) {\r\n          traverseJSX(child, [...path, i]);\r\n        }\r\n      }\r\n\r\n      // Check attributes for expressions\r\n      for (const attr of node.openingElement.attributes) {\r\n        if (t.isJSXAttribute(attr) && t.isJSXExpressionContainer(attr.value)) {\r\n          const template = extractExpressionTemplate(attr.value.expression, component, path);\r\n          if (template) {\r\n            template.attribute = attr.name.name;\r\n            expressionTemplates.push(template);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract expression template from expression node\r\n   */\r\n  function extractExpressionTemplate(expr, component, path) {\r\n    // Skip if it's a simple identifier (no transformation)\r\n    if (t.isIdentifier(expr)) {\r\n      return null;\r\n    }\r\n\r\n    // Skip conditionals (handled by structural templates)\r\n    if (t.isConditionalExpression(expr) || t.isLogicalExpression(expr)) {\r\n      return null;\r\n    }\r\n\r\n    // Method call: price.toFixed(2)\r\n    if (t.isCallExpression(expr) && t.isMemberExpression(expr.callee)) {\r\n      return extractMethodCallTemplate(expr, component, path);\r\n    }\r\n\r\n    // Binary expression: count * 2 + 1\r\n    if (t.isBinaryExpression(expr)) {\r\n      return extractBinaryExpressionTemplate(expr, component, path);\r\n    }\r\n\r\n    // Member expression: user.name, items.length\r\n    if (t.isMemberExpression(expr)) {\r\n      return extractMemberExpressionTemplate(expr, component, path);\r\n    }\r\n\r\n    // Unary expression: -count, +value\r\n    if (t.isUnaryExpression(expr)) {\r\n      return extractUnaryExpressionTemplate(expr, component, path);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract template from method call\r\n   *\r\n   * Example: price.toFixed(2)\r\n   * →\r\n   * {\r\n   *   type: 'methodCall',\r\n   *   binding: 'price',\r\n   *   method: 'toFixed',\r\n   *   args: [2],\r\n   *   transform: { type: 'numberFormat', method: 'toFixed', args: [2] }\r\n   * }\r\n   */\r\n  function extractMethodCallTemplate(callExpr, component, path) {\r\n    const callee = callExpr.callee;\r\n    const args = callExpr.arguments;\r\n\r\n    // Get binding (e.g., 'price' from price.toFixed())\r\n    const binding = extractBinding(callee.object);\r\n    if (!binding) return null;\r\n\r\n    // Get method name\r\n    const methodName = callee.property.name;\r\n\r\n    // Check if this is a supported transformation\r\n    if (!SUPPORTED_TRANSFORMS[methodName]) {\r\n      console.warn(`[Expression Template] Unsupported method: ${methodName}`);\r\n      return null;\r\n    }\r\n\r\n    // Extract arguments\r\n    const extractedArgs = args.map(arg => {\r\n      if (t.isNumericLiteral(arg)) return arg.value;\r\n      if (t.isStringLiteral(arg)) return arg.value;\r\n      if (t.isBooleanLiteral(arg)) return arg.value;\r\n      return null;\r\n    }).filter(a => a !== null);\r\n\r\n    // Determine state key\r\n    const stateKey = extractStateKey(callee.object, component);\r\n\r\n    return {\r\n      type: 'methodCall',\r\n      stateKey: stateKey || binding,\r\n      binding,\r\n      method: methodName,\r\n      args: extractedArgs,\r\n      transform: {\r\n        type: SUPPORTED_TRANSFORMS[methodName].type,\r\n        method: methodName,\r\n        args: extractedArgs\r\n      },\r\n      path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract template from binary expression\r\n   *\r\n   * Example: count * 2 + 1\r\n   * →\r\n   * {\r\n   *   type: 'binaryExpression',\r\n   *   bindings: ['count'],\r\n   *   expression: 'count * 2 + 1',\r\n   *   transform: {\r\n   *     type: 'arithmetic',\r\n   *     operations: [\r\n   *       { op: '*', right: 2 },\r\n   *       { op: '+', right: 1 }\r\n   *     ]\r\n   *   }\r\n   * }\r\n   */\r\n  function extractBinaryExpressionTemplate(binaryExpr, component, path) {\r\n    // Extract all identifiers\r\n    const identifiers = [];\r\n    extractIdentifiers(binaryExpr, identifiers);\r\n\r\n    if (identifiers.length === 0) return null;\r\n\r\n    // For simple cases (single identifier with constant), extract transform\r\n    if (identifiers.length === 1) {\r\n      const binding = identifiers[0];\r\n      const transform = analyzeBinaryExpression(binaryExpr, binding);\r\n\r\n      if (transform) {\r\n        const stateKey = binding.split('.')[0];\r\n        return {\r\n          type: 'binaryExpression',\r\n          stateKey,\r\n          bindings: [binding],\r\n          transform,\r\n          path\r\n        };\r\n      }\r\n    }\r\n\r\n    // Complex multi-variable expression - store as formula\r\n    return {\r\n      type: 'complexExpression',\r\n      stateKey: identifiers[0].split('.')[0],\r\n      bindings: identifiers,\r\n      expression: generateExpressionString(binaryExpr),\r\n      path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Analyze binary expression to extract arithmetic operations\r\n   *\r\n   * Example: count * 2 + 1 with binding=\"count\"\r\n   * →\r\n   * {\r\n   *   type: 'arithmetic',\r\n   *   operations: [\r\n   *     { op: '*', value: 2 },\r\n   *     { op: '+', value: 1 }\r\n   *   ]\r\n   * }\r\n   */\r\n  function analyzeBinaryExpression(expr, targetBinding) {\r\n    const operations = [];\r\n\r\n    function analyze(node) {\r\n      if (t.isBinaryExpression(node)) {\r\n        const { left, operator, right } = node;\r\n\r\n        // Check if one side is our target binding\r\n        const leftIsTarget = isBindingExpression(left, targetBinding);\r\n        const rightIsTarget = isBindingExpression(right, targetBinding);\r\n\r\n        if (leftIsTarget && t.isNumericLiteral(right)) {\r\n          operations.push({ op: operator, value: right.value, side: 'right' });\r\n        } else if (rightIsTarget && t.isNumericLiteral(left)) {\r\n          operations.push({ op: operator, value: left.value, side: 'left' });\r\n        } else {\r\n          // Recurse\r\n          analyze(left);\r\n          analyze(right);\r\n        }\r\n      }\r\n    }\r\n\r\n    analyze(expr);\r\n\r\n    if (operations.length > 0) {\r\n      return {\r\n        type: 'arithmetic',\r\n        operations\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if expression is our target binding\r\n   */\r\n  function isBindingExpression(expr, targetBinding) {\r\n    const binding = extractBinding(expr);\r\n    return binding === targetBinding;\r\n  }\r\n\r\n  /**\r\n   * Extract template from member expression\r\n   *\r\n   * Example: items.length\r\n   * →\r\n   * {\r\n   *   type: 'memberExpression',\r\n   *   binding: 'items.length',\r\n   *   transform: { type: 'property', property: 'length' }\r\n   * }\r\n   */\r\n  function extractMemberExpressionTemplate(memberExpr, component, path) {\r\n    const binding = buildMemberPath(memberExpr);\r\n    if (!binding) return null;\r\n\r\n    // Get property name\r\n    const propertyName = memberExpr.property.name;\r\n\r\n    // Check if it's a supported property\r\n    if (!SUPPORTED_TRANSFORMS[propertyName]) {\r\n      return null;\r\n    }\r\n\r\n    const stateKey = extractStateKey(memberExpr, component);\r\n\r\n    return {\r\n      type: 'memberExpression',\r\n      stateKey: stateKey || binding.split('.')[0],\r\n      binding,\r\n      property: propertyName,\r\n      transform: {\r\n        type: SUPPORTED_TRANSFORMS[propertyName].type,\r\n        property: propertyName\r\n      },\r\n      path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract template from unary expression\r\n   *\r\n   * Example: -count, +value\r\n   */\r\n  function extractUnaryExpressionTemplate(unaryExpr, component, path) {\r\n    const { operator, argument } = unaryExpr;\r\n\r\n    const binding = extractBinding(argument);\r\n    if (!binding) return null;\r\n\r\n    if (operator === '-' || operator === '+') {\r\n      const stateKey = extractStateKey(argument, component);\r\n\r\n      return {\r\n        type: 'unaryExpression',\r\n        stateKey: stateKey || binding,\r\n        binding,\r\n        operator,\r\n        transform: {\r\n          type: 'unary',\r\n          operator\r\n        },\r\n        path\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract binding from expression\r\n   */\r\n  function extractBinding(expr) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      return buildMemberPath(expr);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract state key (root variable)\r\n   */\r\n  function extractStateKey(expr, component) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      let current = expr;\r\n      while (t.isMemberExpression(current)) {\r\n        current = current.object;\r\n      }\r\n      if (t.isIdentifier(current)) {\r\n        return current.name;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Build member expression path\r\n   */\r\n  function buildMemberPath(expr) {\r\n    const parts = [];\r\n    let current = expr;\r\n\r\n    while (t.isMemberExpression(current)) {\r\n      if (t.isIdentifier(current.property)) {\r\n        parts.unshift(current.property.name);\r\n      }\r\n      current = current.object;\r\n    }\r\n\r\n    if (t.isIdentifier(current)) {\r\n      parts.unshift(current.name);\r\n    }\r\n\r\n    return parts.join('.');\r\n  }\r\n\r\n  /**\r\n   * Extract all identifiers from expression\r\n   */\r\n  function extractIdentifiers(expr, result) {\r\n    if (t.isIdentifier(expr)) {\r\n      result.push(expr.name);\r\n    } else if (t.isBinaryExpression(expr)) {\r\n      extractIdentifiers(expr.left, result);\r\n      extractIdentifiers(expr.right, result);\r\n    } else if (t.isUnaryExpression(expr)) {\r\n      extractIdentifiers(expr.argument, result);\r\n    } else if (t.isMemberExpression(expr)) {\r\n      const path = buildMemberPath(expr);\r\n      if (path) result.push(path);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate expression string for complex expressions\r\n   */\r\n  function generateExpressionString(expr) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isNumericLiteral(expr)) {\r\n      return String(expr.value);\r\n    } else if (t.isBinaryExpression(expr)) {\r\n      const left = generateExpressionString(expr.left);\r\n      const right = generateExpressionString(expr.right);\r\n      return `${left} ${expr.operator} ${right}`;\r\n    } else if (t.isUnaryExpression(expr)) {\r\n      const arg = generateExpressionString(expr.argument);\r\n      return `${expr.operator}${arg}`;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      return buildMemberPath(expr);\r\n    }\r\n    return '?';\r\n  }\r\n\r\n  // Start traversal\r\n  traverseJSX(renderBody);\r\n\r\n  return expressionTemplates;\r\n}\r\n\r\nmodule.exports = {\r\n  extractExpressionTemplates,\r\n  SUPPORTED_TRANSFORMS\r\n};\r\n","/**\r\n * Component Processor\r\n *\r\n * Main entry point for processing a component function/class.\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { getComponentName } = require('./utils/helpers.cjs');\r\nconst { tsTypeToCSharpType } = require('./types/typeConversion.cjs');\r\nconst { extractHook } = require('./extractors/hooks.cjs');\r\nconst { extractLocalVariables } = require('./extractors/localVariables.cjs');\r\nconst { inferPropTypes } = require('./analyzers/propTypeInference.cjs');\r\nconst {\r\n  extractTemplates,\r\n  extractAttributeTemplates,\r\n  addTemplateMetadata\r\n} = require('./extractors/templates.cjs');\r\nconst { extractLoopTemplates } = require('./extractors/loopTemplates.cjs');\r\nconst { extractStructuralTemplates } = require('./extractors/structuralTemplates.cjs');\r\nconst { extractExpressionTemplates } = require('./extractors/expressionTemplates.cjs');\r\n\r\n/**\r\n * Process a component function\r\n */\r\nfunction processComponent(path, state) {\r\n  const componentName = getComponentName(path);\r\n\r\n  if (!componentName) return;\r\n  if (componentName[0] !== componentName[0].toUpperCase()) return; // Not a component\r\n\r\n  state.file.minimactComponents = state.file.minimactComponents || [];\r\n\r\n  const component = {\r\n    name: componentName,\r\n    props: [],\r\n    useState: [],\r\n    useClientState: [],\r\n    useEffect: [],\r\n    useRef: [],\r\n    useMarkdown: [],\r\n    useTemplate: null,\r\n    useValidation: [],\r\n    useModal: [],\r\n    useToggle: [],\r\n    useDropdown: [],\r\n    eventHandlers: [],\r\n    localVariables: [], // Local variables (const/let/var) in function body\r\n    renderBody: null,\r\n    stateTypes: new Map(), // Track which hook each state came from\r\n    dependencies: new Map(), // Track dependencies per JSX node\r\n    externalImports: new Set(), // Track external library identifiers\r\n    clientComputedVars: new Set() // Track variables using external libs\r\n  };\r\n\r\n  // Track external imports at file level\r\n  state.file.path.traverse({\r\n    ImportDeclaration(importPath) {\r\n      const source = importPath.node.source.value;\r\n\r\n      // Skip Minimact imports, relative imports, and CSS imports\r\n      if (source.startsWith('minimact') ||\r\n          source.startsWith('.') ||\r\n          source.startsWith('/') ||\r\n          source.endsWith('.css') ||\r\n          source.endsWith('.scss') ||\r\n          source.endsWith('.sass')) {\r\n        return;\r\n      }\r\n\r\n      // Track external library identifiers\r\n      importPath.node.specifiers.forEach(spec => {\r\n        if (t.isImportDefaultSpecifier(spec)) {\r\n          // import _ from 'lodash'\r\n          component.externalImports.add(spec.local.name);\r\n        } else if (t.isImportSpecifier(spec)) {\r\n          // import { sortBy } from 'lodash'\r\n          component.externalImports.add(spec.local.name);\r\n        } else if (t.isImportNamespaceSpecifier(spec)) {\r\n          // import * as _ from 'lodash'\r\n          component.externalImports.add(spec.local.name);\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  // Extract props from function parameters\r\n  const params = path.node.params;\r\n  if (params.length > 0 && t.isObjectPattern(params[0])) {\r\n    // Destructured props: function Component({ prop1, prop2 })\r\n    // Check if there's a type annotation on the parameter\r\n    const paramTypeAnnotation = params[0].typeAnnotation?.typeAnnotation;\r\n\r\n    for (const property of params[0].properties) {\r\n      if (t.isObjectProperty(property) && t.isIdentifier(property.key)) {\r\n        let propType = 'dynamic';\r\n\r\n        // Try to extract type from TypeScript annotation\r\n        if (paramTypeAnnotation && t.isTSTypeLiteral(paramTypeAnnotation)) {\r\n          const propName = property.key.name;\r\n          const tsProperty = paramTypeAnnotation.members.find(\r\n            member => t.isTSPropertySignature(member) &&\r\n                     t.isIdentifier(member.key) &&\r\n                     member.key.name === propName\r\n          );\r\n          if (tsProperty && tsProperty.typeAnnotation) {\r\n            propType = tsTypeToCSharpType(tsProperty.typeAnnotation.typeAnnotation);\r\n          }\r\n        }\r\n\r\n        component.props.push({\r\n          name: property.key.name,\r\n          type: propType\r\n        });\r\n      }\r\n    }\r\n  } else if (params.length > 0 && t.isIdentifier(params[0])) {\r\n    // Props as single object: function Component(props)\r\n    // Use 'dynamic' to allow property access\r\n    component.props.push({\r\n      name: params[0].name,\r\n      type: 'dynamic'\r\n    });\r\n  }\r\n\r\n  // Find function body\r\n  const body = path.node.body.type === 'BlockStatement'\r\n    ? path.node.body\r\n    : t.blockStatement([t.returnStatement(path.node.body)]);\r\n\r\n  // Extract hooks and local variables\r\n  path.traverse({\r\n    CallExpression(hookPath) {\r\n      extractHook(hookPath, component);\r\n    },\r\n\r\n    VariableDeclaration(varPath) {\r\n      // Only extract local variables at the top level of the function body\r\n      if (varPath.getFunctionParent() === path && varPath.parent.type === 'BlockStatement') {\r\n        extractLocalVariables(varPath, component, t);\r\n      }\r\n    },\r\n\r\n    ReturnStatement(returnPath) {\r\n      if (returnPath.getFunctionParent() === path) {\r\n        // Deep clone the AST node to preserve it before we replace JSX with null\r\n        component.renderBody = t.cloneNode(returnPath.node.argument, true);\r\n      }\r\n    }\r\n  });\r\n\r\n  // Infer prop types from usage BEFORE replacing JSX with null\r\n  // Pass the entire function body to analyze all usage (including JSX)\r\n  inferPropTypes(component, body);\r\n\r\n  // Extract templates from JSX for hot reload (BEFORE replacing JSX with null)\r\n  if (component.renderBody) {\r\n    const textTemplates = extractTemplates(component.renderBody, component);\r\n    const attrTemplates = extractAttributeTemplates(component.renderBody, component);\r\n    const allTemplates = { ...textTemplates, ...attrTemplates };\r\n\r\n    // Add template metadata to component\r\n    addTemplateMetadata(component, allTemplates);\r\n\r\n    console.log(`[Minimact Templates] Extracted ${Object.keys(allTemplates).length} templates from ${componentName}`);\r\n\r\n    // Extract loop templates for predictive rendering (.map() patterns)\r\n    const loopTemplates = extractLoopTemplates(component.renderBody, component);\r\n    component.loopTemplates = loopTemplates;\r\n\r\n    if (loopTemplates.length > 0) {\r\n      console.log(`[Minimact Loop Templates] Extracted ${loopTemplates.length} loop templates from ${componentName}:`);\r\n      loopTemplates.forEach(lt => {\r\n        console.log(`  - ${lt.stateKey}.map(${lt.itemVar} => ...)`);\r\n      });\r\n    }\r\n\r\n    // Extract structural templates for conditional rendering (Phase 5)\r\n    const structuralTemplates = extractStructuralTemplates(component.renderBody, component);\r\n    component.structuralTemplates = structuralTemplates;\r\n\r\n    if (structuralTemplates.length > 0) {\r\n      console.log(`[Minimact Structural Templates] Extracted ${structuralTemplates.length} structural templates from ${componentName}:`);\r\n      structuralTemplates.forEach(st => {\r\n        console.log(`  - ${st.type === 'conditional' ? 'Ternary' : 'Logical AND'}: ${st.conditionBinding}`);\r\n      });\r\n    }\r\n\r\n    // Extract expression templates for computed values (Phase 6)\r\n    const expressionTemplates = extractExpressionTemplates(component.renderBody, component);\r\n    component.expressionTemplates = expressionTemplates;\r\n\r\n    if (expressionTemplates.length > 0) {\r\n      console.log(`[Minimact Expression Templates] Extracted ${expressionTemplates.length} expression templates from ${componentName}:`);\r\n      expressionTemplates.forEach(et => {\r\n        if (et.method) {\r\n          console.log(`  - ${et.binding}.${et.method}(${et.args.join(', ')})`);\r\n        } else if (et.operator) {\r\n          console.log(`  - ${et.operator}${et.binding}`);\r\n        } else {\r\n          console.log(`  - ${et.bindings.join(', ')}`);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // Now replace JSX to prevent @babel/preset-react from transforming it\r\n  path.traverse({\r\n    ReturnStatement(returnPath) {\r\n      if (returnPath.getFunctionParent() === path) {\r\n        returnPath.node.argument = t.nullLiteral();\r\n      }\r\n    }\r\n  });\r\n\r\n  state.file.minimactComponents.push(component);\r\n}\r\n\r\nmodule.exports = {\r\n  processComponent\r\n};\r\n","/**\r\n * Render Body Generator\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { generateJSXElement } = require('./jsx.cjs');\r\nconst { generateConditional, generateShortCircuit, generateMapExpression } = require('./expressions.cjs');\r\n\r\n/**\r\n * Generate C# code for render body\r\n */\r\nfunction generateRenderBody(node, component, indent) {\r\n  const indentStr = '    '.repeat(indent);\r\n\r\n  if (!node) {\r\n    return `${indentStr}return new VText(\"\");`;\r\n  }\r\n\r\n  // Handle different node types\r\n  if (t.isJSXElement(node) || t.isJSXFragment(node)) {\r\n    return `${indentStr}return ${generateJSXElement(node, component, indent)};`;\r\n  }\r\n\r\n  if (t.isConditionalExpression(node)) {\r\n    // Ternary: condition ? a : b\r\n    return generateConditional(node, component, indent);\r\n  }\r\n\r\n  if (t.isLogicalExpression(node) && node.operator === '&&') {\r\n    // Short-circuit: condition && <Element>\r\n    return generateShortCircuit(node, component, indent);\r\n  }\r\n\r\n  if (t.isCallExpression(node) && t.isMemberExpression(node.callee) && node.callee.property.name === 'map') {\r\n    // Array.map()\r\n    return generateMapExpression(node, component, indent);\r\n  }\r\n\r\n  // Fallback\r\n  return `${indentStr}return new VText(\"${node.type}\");`;\r\n}\r\n\r\nmodule.exports = {\r\n  generateRenderBody\r\n};\r\n","/**\r\n * TypeScript → C# Transpiler\r\n *\r\n * Transpiles TypeScript async functions to C# async Tasks\r\n * for useServerTask support\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Transpile async function body → C# code\r\n */\r\nfunction transpileAsyncFunctionToCSharp(asyncFunction) {\r\n  const body = asyncFunction.body;\r\n  const params = asyncFunction.params;\r\n\r\n  let csharpCode = '';\r\n\r\n  // Transpile body\r\n  if (t.isBlockStatement(body)) {\r\n    csharpCode = transpileBlockStatement(body);\r\n  } else {\r\n    // Arrow function with expression body: () => expr\r\n    csharpCode = `return ${transpileExpression(body)};`;\r\n  }\r\n\r\n  return csharpCode;\r\n}\r\n\r\n/**\r\n * Transpile TypeScript block statement → C# code\r\n */\r\nfunction transpileBlockStatement(block) {\r\n  let code = '';\r\n\r\n  for (const statement of block.body) {\r\n    code += transpileStatement(statement) + '\\n';\r\n  }\r\n\r\n  return code;\r\n}\r\n\r\n/**\r\n * Transpile individual TypeScript statement → C# statement\r\n */\r\nfunction transpileStatement(statement) {\r\n  if (t.isVariableDeclaration(statement)) {\r\n    const declarations = statement.declarations.map(decl => {\r\n      const name = decl.id.name;\r\n      const init = decl.init ? transpileExpression(decl.init) : 'null';\r\n      return `var ${name} = ${init};`;\r\n    });\r\n    return declarations.join('\\n');\r\n  }\r\n\r\n  if (t.isReturnStatement(statement)) {\r\n    return `return ${transpileExpression(statement.argument)};`;\r\n  }\r\n\r\n  if (t.isExpressionStatement(statement)) {\r\n    // Check for yield expression (streaming)\r\n    if (t.isYieldExpression(statement.expression)) {\r\n      return `yield return ${transpileExpression(statement.expression.argument)};`;\r\n    }\r\n    return `${transpileExpression(statement.expression)};`;\r\n  }\r\n\r\n  if (t.isForStatement(statement)) {\r\n    const init = statement.init ? transpileStatement(statement.init).replace(/;$/, '') : '';\r\n    const test = statement.test ? transpileExpression(statement.test) : 'true';\r\n    const update = statement.update ? transpileExpression(statement.update) : '';\r\n    const body = transpileStatement(statement.body);\r\n    return `for (${init}; ${test}; ${update})\\n{\\n${indent(body, 4)}\\n}`;\r\n  }\r\n\r\n  if (t.isForOfStatement(statement)) {\r\n    const left = t.isVariableDeclaration(statement.left)\r\n      ? statement.left.declarations[0].id.name\r\n      : statement.left.name;\r\n    const right = transpileExpression(statement.right);\r\n    const body = transpileStatement(statement.body);\r\n\r\n    // Check if it's for await of (streaming)\r\n    if (statement.await) {\r\n      return `await foreach (var ${left} in ${right})\\n{\\n${indent(body, 4)}\\n}`;\r\n    }\r\n\r\n    return `foreach (var ${left} in ${right})\\n{\\n${indent(body, 4)}\\n}`;\r\n  }\r\n\r\n  if (t.isWhileStatement(statement)) {\r\n    const test = transpileExpression(statement.test);\r\n    const body = transpileStatement(statement.body);\r\n    return `while (${test})\\n{\\n${indent(body, 4)}\\n}`;\r\n  }\r\n\r\n  if (t.isIfStatement(statement)) {\r\n    const test = transpileExpression(statement.test);\r\n    const consequent = transpileStatement(statement.consequent);\r\n    const alternate = statement.alternate\r\n      ? `\\nelse\\n{\\n${indent(transpileStatement(statement.alternate), 4)}\\n}`\r\n      : '';\r\n    return `if (${test})\\n{\\n${indent(consequent, 4)}\\n}${alternate}`;\r\n  }\r\n\r\n  if (t.isBlockStatement(statement)) {\r\n    return transpileBlockStatement(statement);\r\n  }\r\n\r\n  if (t.isTryStatement(statement)) {\r\n    const block = transpileBlockStatement(statement.block);\r\n    const handler = statement.handler ? transpileCatchClause(statement.handler) : '';\r\n    const finalizer = statement.finalizer\r\n      ? `\\nfinally\\n{\\n${indent(transpileBlockStatement(statement.finalizer), 4)}\\n}`\r\n      : '';\r\n    return `try\\n{\\n${indent(block, 4)}\\n}${handler}${finalizer}`;\r\n  }\r\n\r\n  if (t.isThrowStatement(statement)) {\r\n    return `throw ${transpileExpression(statement.argument)};`;\r\n  }\r\n\r\n  if (t.isBreakStatement(statement)) {\r\n    return 'break;';\r\n  }\r\n\r\n  if (t.isContinueStatement(statement)) {\r\n    return 'continue;';\r\n  }\r\n\r\n  // Default: convert to string (may need refinement)\r\n  return `/* TODO: Transpile ${statement.type} */`;\r\n}\r\n\r\n/**\r\n * Transpile TypeScript expression → C# expression\r\n */\r\nfunction transpileExpression(expr) {\r\n  if (!expr) return 'null';\r\n\r\n  if (t.isStringLiteral(expr)) {\r\n    return `\"${escapeString(expr.value)}\"`;\r\n  }\r\n\r\n  if (t.isNumericLiteral(expr)) {\r\n    return expr.value.toString();\r\n  }\r\n\r\n  if (t.isBooleanLiteral(expr)) {\r\n    return expr.value ? 'true' : 'false';\r\n  }\r\n\r\n  if (t.isNullLiteral(expr)) {\r\n    return 'null';\r\n  }\r\n\r\n  if (t.isIdentifier(expr)) {\r\n    // Special handling for progress parameter\r\n    if (expr.name === 'progress') {\r\n      return 'progress';\r\n    }\r\n    // Special handling for cancellation token\r\n    if (expr.name === 'cancellationToken' || expr.name === 'cancel') {\r\n      return 'cancellationToken';\r\n    }\r\n    return expr.name;\r\n  }\r\n\r\n  if (t.isMemberExpression(expr)) {\r\n    const object = transpileExpression(expr.object);\r\n    const property = expr.computed\r\n      ? `[${transpileExpression(expr.property)}]`\r\n      : `.${expr.property.name}`;\r\n\r\n    // Handle special member expressions\r\n    const fullExpr = `${object}${property}`;\r\n    return transpileMemberExpression(fullExpr, object, property);\r\n  }\r\n\r\n  if (t.isCallExpression(expr)) {\r\n    const callee = transpileExpression(expr.callee);\r\n    const args = expr.arguments.map(arg => transpileExpression(arg)).join(', ');\r\n\r\n    // Handle special method calls\r\n    return transpileMethodCall(callee, args);\r\n  }\r\n\r\n  if (t.isAwaitExpression(expr)) {\r\n    return `await ${transpileExpression(expr.argument)}`;\r\n  }\r\n\r\n  if (t.isArrayExpression(expr)) {\r\n    const elements = expr.elements.map(el => transpileExpression(el)).join(', ');\r\n    return `new[] { ${elements} }`;\r\n  }\r\n\r\n  if (t.isObjectExpression(expr)) {\r\n    const props = expr.properties.map(prop => {\r\n      if (t.isObjectProperty(prop)) {\r\n        const key = t.isIdentifier(prop.key) ? prop.key.name : transpileExpression(prop.key);\r\n        const value = transpileExpression(prop.value);\r\n        return `${capitalize(key)} = ${value}`;\r\n      }\r\n      if (t.isSpreadElement(prop)) {\r\n        // C# object spread using with expression (C# 9+)\r\n        return `/* spread: ${transpileExpression(prop.argument)} */`;\r\n      }\r\n      return '';\r\n    }).filter(Boolean).join(', ');\r\n    return `new { ${props} }`;\r\n  }\r\n\r\n  if (t.isArrowFunctionExpression(expr)) {\r\n    const params = expr.params.map(p => p.name).join(', ');\r\n    const body = t.isBlockStatement(expr.body)\r\n      ? `{\\n${indent(transpileBlockStatement(expr.body), 4)}\\n}`\r\n      : transpileExpression(expr.body);\r\n    return `(${params}) => ${body}`;\r\n  }\r\n\r\n  if (t.isBinaryExpression(expr)) {\r\n    const left = transpileExpression(expr.left);\r\n    const right = transpileExpression(expr.right);\r\n    const operator = transpileOperator(expr.operator);\r\n    return `(${left} ${operator} ${right})`;\r\n  }\r\n\r\n  if (t.isLogicalExpression(expr)) {\r\n    const left = transpileExpression(expr.left);\r\n    const right = transpileExpression(expr.right);\r\n    const operator = transpileOperator(expr.operator);\r\n    return `(${left} ${operator} ${right})`;\r\n  }\r\n\r\n  if (t.isUnaryExpression(expr)) {\r\n    const operator = transpileOperator(expr.operator);\r\n    const argument = transpileExpression(expr.argument);\r\n    return expr.prefix ? `${operator}${argument}` : `${argument}${operator}`;\r\n  }\r\n\r\n  if (t.isConditionalExpression(expr)) {\r\n    const test = transpileExpression(expr.test);\r\n    const consequent = transpileExpression(expr.consequent);\r\n    const alternate = transpileExpression(expr.alternate);\r\n    return `(${test} ? ${consequent} : ${alternate})`;\r\n  }\r\n\r\n  if (t.isTemplateLiteral(expr)) {\r\n    // Convert template literal to C# interpolated string\r\n    return transpileTemplateLiteral(expr);\r\n  }\r\n\r\n  if (t.isNewExpression(expr)) {\r\n    const callee = transpileExpression(expr.callee);\r\n    const args = expr.arguments.map(arg => transpileExpression(arg)).join(', ');\r\n    return `new ${callee}(${args})`;\r\n  }\r\n\r\n  if (t.isAssignmentExpression(expr)) {\r\n    const left = transpileExpression(expr.left);\r\n    const right = transpileExpression(expr.right);\r\n    const operator = transpileOperator(expr.operator);\r\n    return `${left} ${operator} ${right}`;\r\n  }\r\n\r\n  if (t.isUpdateExpression(expr)) {\r\n    const argument = transpileExpression(expr.argument);\r\n    const operator = expr.operator;\r\n    return expr.prefix ? `${operator}${argument}` : `${argument}${operator}`;\r\n  }\r\n\r\n  return `/* TODO: ${expr.type} */`;\r\n}\r\n\r\n/**\r\n * Transpile member expression (handle special cases)\r\n */\r\nfunction transpileMemberExpression(fullExpr, object, property) {\r\n  // progress.report() → progress.Report()\r\n  if (object === 'progress' && property === '.report') {\r\n    return 'progress.Report';\r\n  }\r\n\r\n  // cancellationToken.requested → cancellationToken.IsCancellationRequested\r\n  if ((object === 'cancellationToken' || object === 'cancel') && property === '.requested') {\r\n    return 'cancellationToken.IsCancellationRequested';\r\n  }\r\n\r\n  return fullExpr;\r\n}\r\n\r\n/**\r\n * Transpile method call (handle special methods)\r\n */\r\nfunction transpileMethodCall(callee, args) {\r\n  // Array methods: .map → .Select, .filter → .Where, etc.\r\n  const mappings = {\r\n    '.map': '.Select',\r\n    '.filter': '.Where',\r\n    '.reduce': '.Aggregate',\r\n    '.find': '.FirstOrDefault',\r\n    '.findIndex': '.FindIndex',\r\n    '.some': '.Any',\r\n    '.every': '.All',\r\n    '.includes': '.Contains',\r\n    '.sort': '.OrderBy',\r\n    '.reverse': '.Reverse',\r\n    '.slice': '.Skip',\r\n    '.concat': '.Concat',\r\n    '.join': '.Join',\r\n    'console.log': 'Console.WriteLine',\r\n    'console.error': 'Console.Error.WriteLine',\r\n    'console.warn': 'Console.WriteLine',\r\n    'Math.floor': 'Math.Floor',\r\n    'Math.ceil': 'Math.Ceiling',\r\n    'Math.round': 'Math.Round',\r\n    'Math.abs': 'Math.Abs',\r\n    'Math.max': 'Math.Max',\r\n    'Math.min': 'Math.Min',\r\n    'Math.sqrt': 'Math.Sqrt',\r\n    'Math.pow': 'Math.Pow',\r\n    'JSON.stringify': 'JsonSerializer.Serialize',\r\n    'JSON.parse': 'JsonSerializer.Deserialize'\r\n  };\r\n\r\n  for (const [ts, csharp] of Object.entries(mappings)) {\r\n    if (callee.includes(ts)) {\r\n      const transpiledCallee = callee.replace(ts, csharp);\r\n      return `${transpiledCallee}(${args})`;\r\n    }\r\n  }\r\n\r\n  // Special handling for .toFixed()\r\n  if (callee.endsWith('.toFixed')) {\r\n    const obj = callee.replace('.toFixed', '');\r\n    return `${obj}.ToString(\"F\" + ${args})`;\r\n  }\r\n\r\n  // Special handling for .split()\r\n  if (callee.endsWith('.split')) {\r\n    const obj = callee.replace('.split', '');\r\n    return `${obj}.Split(${args})`;\r\n  }\r\n\r\n  // Special handling for fetch (convert to HttpClient call)\r\n  if (callee === 'fetch') {\r\n    return `await _httpClient.GetStringAsync(${args})`;\r\n  }\r\n\r\n  return `${callee}(${args})`;\r\n}\r\n\r\n/**\r\n * Transpile operator\r\n */\r\nfunction transpileOperator(op) {\r\n  const mappings = {\r\n    '===': '==',\r\n    '!==': '!=',\r\n    '&&': '&&',\r\n    '||': '||',\r\n    '!': '!',\r\n    '+': '+',\r\n    '-': '-',\r\n    '*': '*',\r\n    '/': '/',\r\n    '%': '%',\r\n    '<': '<',\r\n    '>': '>',\r\n    '<=': '<=',\r\n    '>=': '>=',\r\n    '=': '=',\r\n    '+=': '+=',\r\n    '-=': '-=',\r\n    '*=': '*=',\r\n    '/=': '/=',\r\n    '++': '++',\r\n    '--': '--'\r\n  };\r\n  return mappings[op] || op;\r\n}\r\n\r\n/**\r\n * Transpile catch clause\r\n */\r\nfunction transpileCatchClause(handler) {\r\n  const param = handler.param ? handler.param.name : 'ex';\r\n  const body = transpileBlockStatement(handler.body);\r\n  return `\\ncatch (Exception ${param})\\n{\\n${indent(body, 4)}\\n}`;\r\n}\r\n\r\n/**\r\n * Transpile template literal → C# interpolated string\r\n */\r\nfunction transpileTemplateLiteral(expr) {\r\n  let result = '$\"';\r\n\r\n  for (let i = 0; i < expr.quasis.length; i++) {\r\n    result += expr.quasis[i].value.cooked;\r\n\r\n    if (i < expr.expressions.length) {\r\n      result += `{${transpileExpression(expr.expressions[i])}}`;\r\n    }\r\n  }\r\n\r\n  result += '\"';\r\n  return result;\r\n}\r\n\r\n/**\r\n * Escape string for C#\r\n */\r\nfunction escapeString(str) {\r\n  return str\r\n    .replace(/\\\\/g, '\\\\\\\\')\r\n    .replace(/\"/g, '\\\\\"')\r\n    .replace(/\\n/g, '\\\\n')\r\n    .replace(/\\r/g, '\\\\r')\r\n    .replace(/\\t/g, '\\\\t');\r\n}\r\n\r\n/**\r\n * Capitalize first letter\r\n */\r\nfunction capitalize(str) {\r\n  if (!str) return '';\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\n\r\n/**\r\n * Indent code\r\n */\r\nfunction indent(code, spaces) {\r\n  const prefix = ' '.repeat(spaces);\r\n  return code.split('\\n').map(line => prefix + line).join('\\n');\r\n}\r\n\r\nmodule.exports = {\r\n  transpileAsyncFunctionToCSharp,\r\n  transpileExpression,\r\n  transpileStatement,\r\n  transpileBlockStatement\r\n};\r\n","/**\r\n * Server Task Generator\r\n *\r\n * Generates C# async Task methods from useServerTask calls\r\n */\r\n\r\nconst { transpileAsyncFunctionToCSharp } = require('../transpilers/typescriptToCSharp.cjs');\r\n\r\n/**\r\n * Generate C# server task methods\r\n */\r\nfunction generateServerTaskMethods(component) {\r\n  if (!component.useServerTask || component.useServerTask.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  const lines = [];\r\n\r\n  for (let i = 0; i < component.useServerTask.length; i++) {\r\n    const task = component.useServerTask[i];\r\n    const taskId = `serverTask_${i}`;\r\n\r\n    // Generate method\r\n    lines.push('');\r\n    lines.push(`    [ServerTask(\"${taskId}\"${task.isStreaming ? ', Streaming = true' : ''})]`);\r\n\r\n    // Method signature\r\n    const returnType = task.isStreaming\r\n      ? `IAsyncEnumerable<${task.returnType}>`\r\n      : `Task<${task.returnType}>`;\r\n\r\n    const params = [];\r\n\r\n    // Add user parameters\r\n    for (const param of task.parameters) {\r\n      params.push(`${param.type} ${param.name}`);\r\n    }\r\n\r\n    // Add progress parameter (non-streaming only)\r\n    if (!task.isStreaming) {\r\n      params.push('IProgress<double> progress');\r\n    }\r\n\r\n    // Add cancellation token\r\n    if (task.isStreaming) {\r\n      params.push('[EnumeratorCancellation] CancellationToken cancellationToken = default');\r\n    } else {\r\n      params.push('CancellationToken cancellationToken');\r\n    }\r\n\r\n    const methodName = capitalize(taskId);\r\n    const paramsList = params.join(', ');\r\n\r\n    lines.push(`    private async ${returnType} ${methodName}(${paramsList})`);\r\n    lines.push(`    {`);\r\n\r\n    // Transpile function body\r\n    const csharpBody = transpileAsyncFunctionToCSharp(task.asyncFunction);\r\n    const indentedBody = indent(csharpBody, 8);\r\n\r\n    lines.push(indentedBody);\r\n    lines.push(`    }`);\r\n  }\r\n\r\n  return lines;\r\n}\r\n\r\n/**\r\n * Capitalize first letter\r\n */\r\nfunction capitalize(str) {\r\n  if (!str) return '';\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\n\r\n/**\r\n * Indent code\r\n */\r\nfunction indent(code, spaces) {\r\n  const prefix = ' '.repeat(spaces);\r\n  return code.split('\\n').map(line => line ? prefix + line : '').join('\\n');\r\n}\r\n\r\nmodule.exports = {\r\n  generateServerTaskMethods\r\n};\r\n","/**\r\n * Component Generator\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { generateRenderBody } = require('./renderBody.cjs');\r\nconst { generateCSharpExpression, generateCSharpStatement, setCurrentComponent } = require('./expressions.cjs');\r\nconst { generateServerTaskMethods } = require('./serverTask.cjs');\r\n\r\n/**\r\n * Generate C# class for a component\r\n */\r\nfunction generateComponent(component) {\r\n  // Set the current component context for useState setter detection\r\n  setCurrentComponent(component);\r\n\r\n  const lines = [];\r\n\r\n  // Loop template attributes (for predictive rendering)\r\n  if (component.loopTemplates && component.loopTemplates.length > 0) {\r\n    for (const loopTemplate of component.loopTemplates) {\r\n      const templateJson = JSON.stringify(loopTemplate)\r\n        .replace(/\"/g, '\"\"'); // Escape quotes for C# verbatim string\r\n\r\n      lines.push(`[LoopTemplate(\"${loopTemplate.stateKey}\", @\"${templateJson}\")]`);\r\n    }\r\n  }\r\n\r\n  // Class declaration\r\n  lines.push('[Component]');\r\n\r\n  const baseClass = component.useTemplate\r\n    ? component.useTemplate.name\r\n    : 'MinimactComponent';\r\n\r\n  lines.push(`public partial class ${component.name} : ${baseClass}`);\r\n  lines.push('{');\r\n\r\n  // Template properties (from useTemplate)\r\n  if (component.useTemplate && component.useTemplate.props) {\r\n    for (const [propName, propValue] of Object.entries(component.useTemplate.props)) {\r\n      // Capitalize first letter for C# property name\r\n      const csharpPropName = propName.charAt(0).toUpperCase() + propName.slice(1);\r\n      lines.push(`    public override string ${csharpPropName} => \"${propValue}\";`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Prop fields (from function parameters)\r\n  for (const prop of component.props) {\r\n    lines.push(`    [Prop]`);\r\n    lines.push(`    public ${prop.type} ${prop.name} { get; set; }`);\r\n    lines.push('');\r\n  }\r\n\r\n  // State fields (useState)\r\n  for (const state of component.useState) {\r\n    lines.push(`    [State]`);\r\n    lines.push(`    private ${state.type} ${state.name} = ${state.initialValue};`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Ref fields (useRef)\r\n  for (const ref of component.useRef) {\r\n    lines.push(`    [Ref]`);\r\n    lines.push(`    private object ${ref.name} = ${ref.initialValue};`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Markdown fields (useMarkdown)\r\n  for (const md of component.useMarkdown) {\r\n    lines.push(`    [Markdown]`);\r\n    lines.push(`    [State]`);\r\n    lines.push(`    private string ${md.name} = ${md.initialValue};`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Validation fields (useValidation)\r\n  for (const validation of component.useValidation) {\r\n    lines.push(`    [Validation]`);\r\n    lines.push(`    private ValidationField ${validation.name} = new ValidationField`);\r\n    lines.push(`    {`);\r\n    lines.push(`        FieldKey = \"${validation.fieldKey}\",`);\r\n\r\n    // Add validation rules\r\n    if (validation.rules.required) {\r\n      lines.push(`        Required = ${validation.rules.required.toString().toLowerCase()},`);\r\n    }\r\n    if (validation.rules.minLength) {\r\n      lines.push(`        MinLength = ${validation.rules.minLength},`);\r\n    }\r\n    if (validation.rules.maxLength) {\r\n      lines.push(`        MaxLength = ${validation.rules.maxLength},`);\r\n    }\r\n    if (validation.rules.pattern) {\r\n      lines.push(`        Pattern = @\"${validation.rules.pattern}\",`);\r\n    }\r\n    if (validation.rules.message) {\r\n      lines.push(`        Message = \"${validation.rules.message}\"`);\r\n    }\r\n\r\n    lines.push(`    };`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Modal fields (useModal)\r\n  for (const modal of component.useModal) {\r\n    lines.push(`    private ModalState ${modal.name} = new ModalState();`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Toggle fields (useToggle)\r\n  for (const toggle of component.useToggle) {\r\n    lines.push(`    [State]`);\r\n    lines.push(`    private bool ${toggle.name} = ${toggle.initialValue};`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Dropdown fields (useDropdown)\r\n  for (const dropdown of component.useDropdown) {\r\n    lines.push(`    private DropdownState ${dropdown.name} = new DropdownState();`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Pub/Sub fields (usePub)\r\n  if (component.usePub) {\r\n    for (const pub of component.usePub) {\r\n      const channelStr = pub.channel ? `\"${pub.channel}\"` : 'null';\r\n      lines.push(`    // usePub: ${pub.name}`);\r\n      lines.push(`    private string ${pub.name}_channel = ${channelStr};`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Pub/Sub fields (useSub)\r\n  if (component.useSub) {\r\n    for (const sub of component.useSub) {\r\n      const channelStr = sub.channel ? `\"${sub.channel}\"` : 'null';\r\n      lines.push(`    // useSub: ${sub.name}`);\r\n      lines.push(`    private string ${sub.name}_channel = ${channelStr};`);\r\n      lines.push(`    private dynamic ${sub.name}_value = null;`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Task scheduling fields (useMicroTask)\r\n  if (component.useMicroTask) {\r\n    for (let i = 0; i < component.useMicroTask.length; i++) {\r\n      lines.push(`    // useMicroTask ${i}`);\r\n      lines.push(`    private bool _microTaskScheduled_${i} = false;`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Task scheduling fields (useMacroTask)\r\n  if (component.useMacroTask) {\r\n    for (let i = 0; i < component.useMacroTask.length; i++) {\r\n      const task = component.useMacroTask[i];\r\n      lines.push(`    // useMacroTask ${i} (delay: ${task.delay}ms)`);\r\n      lines.push(`    private bool _macroTaskScheduled_${i} = false;`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // SignalR fields (useSignalR)\r\n  if (component.useSignalR) {\r\n    for (const signalR of component.useSignalR) {\r\n      const hubUrlStr = signalR.hubUrl ? `\"${signalR.hubUrl}\"` : 'null';\r\n      lines.push(`    // useSignalR: ${signalR.name}`);\r\n      lines.push(`    private string ${signalR.name}_hubUrl = ${hubUrlStr};`);\r\n      lines.push(`    private bool ${signalR.name}_connected = false;`);\r\n      lines.push(`    private string ${signalR.name}_connectionId = null;`);\r\n      lines.push(`    private string ${signalR.name}_error = null;`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Predict hint fields (usePredictHint)\r\n  if (component.usePredictHint) {\r\n    for (let i = 0; i < component.usePredictHint.length; i++) {\r\n      const hint = component.usePredictHint[i];\r\n      const hintIdStr = hint.hintId ? `\"${hint.hintId}\"` : `\"hint_${i}\"`;\r\n      lines.push(`    // usePredictHint: ${hintIdStr}`);\r\n      lines.push(`    private string _hintId_${i} = ${hintIdStr};`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Client-computed properties (from external libraries)\r\n  const clientComputedVars = component.localVariables.filter(v => v.isClientComputed);\r\n  if (clientComputedVars.length > 0) {\r\n    lines.push('    // Client-computed properties (external libraries)');\r\n    for (const clientVar of clientComputedVars) {\r\n      const csharpType = inferCSharpTypeFromInit(clientVar.init);\r\n      lines.push(`    [ClientComputed(\"${clientVar.name}\")]`);\r\n      lines.push(`    private ${csharpType} ${clientVar.name} => GetClientState<${csharpType}>(\"${clientVar.name}\", default);`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Server Task methods (useServerTask)\r\n  const serverTaskMethods = generateServerTaskMethods(component);\r\n  for (const line of serverTaskMethods) {\r\n    lines.push(line);\r\n  }\r\n\r\n  // Render method (or RenderContent for templates)\r\n  const renderMethodName = component.useTemplate ? 'RenderContent' : 'Render';\r\n  lines.push(`    protected override VNode ${renderMethodName}()`);\r\n  lines.push('    {');\r\n\r\n  // Only add StateManager sync if NOT using a template (templates handle this themselves)\r\n  if (!component.useTemplate) {\r\n    lines.push('        StateManager.SyncMembersToState(this);');\r\n    lines.push('');\r\n  }\r\n\r\n  // Local variables (exclude client-computed ones, they're properties now)\r\n  const regularLocalVars = component.localVariables.filter(v => !v.isClientComputed);\r\n  for (const localVar of regularLocalVars) {\r\n    lines.push(`        ${localVar.type} ${localVar.name} = ${localVar.initialValue};`);\r\n  }\r\n  if (regularLocalVars.length > 0) {\r\n    lines.push('');\r\n  }\r\n\r\n  if (component.renderBody) {\r\n    const renderCode = generateRenderBody(component.renderBody, component, 2);\r\n    lines.push(renderCode);\r\n  } else {\r\n    lines.push('        return new VText(\"\");');\r\n  }\r\n\r\n  lines.push('    }');\r\n\r\n  // Effect methods (useEffect)\r\n  let effectIndex = 0;\r\n  for (const effect of component.useEffect) {\r\n    lines.push('');\r\n\r\n    // Extract dependency names from array\r\n    const deps = [];\r\n    if (effect.dependencies && t.isArrayExpression(effect.dependencies)) {\r\n      for (const dep of effect.dependencies.elements) {\r\n        if (t.isIdentifier(dep)) {\r\n          deps.push(dep.name);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Generate [OnStateChanged] for each dependency\r\n    for (const dep of deps) {\r\n      lines.push(`    [OnStateChanged(\"${dep}\")]`);\r\n    }\r\n\r\n    lines.push(`    private void Effect_${effectIndex}()`);\r\n    lines.push('    {');\r\n\r\n    // Extract and convert effect body\r\n    if (effect.body && t.isArrowFunctionExpression(effect.body)) {\r\n      const body = effect.body.body;\r\n      if (t.isBlockStatement(body)) {\r\n        // Multi-statement effect\r\n        for (const stmt of body.body) {\r\n          lines.push(`        ${generateCSharpStatement(stmt)}`);\r\n        }\r\n      } else {\r\n        // Single expression effect\r\n        lines.push(`        ${generateCSharpExpression(body)};`);\r\n      }\r\n    }\r\n\r\n    lines.push('    }');\r\n    effectIndex++;\r\n  }\r\n\r\n  // Event handlers\r\n  for (const handler of component.eventHandlers) {\r\n    lines.push('');\r\n\r\n    // Generate parameter list\r\n    const params = handler.params || [];\r\n    const paramStr = params.length > 0\r\n      ? params.map(p => t.isIdentifier(p) ? `dynamic ${p.name}` : 'dynamic arg').join(', ')\r\n      : '';\r\n\r\n    lines.push(`    private void ${handler.name}(${paramStr})`);\r\n    lines.push('    {');\r\n\r\n    // Generate method body\r\n    if (handler.body) {\r\n      if (t.isBlockStatement(handler.body)) {\r\n        // Block statement: { ... }\r\n        for (const statement of handler.body.body) {\r\n          const csharpStmt = generateCSharpStatement(statement);\r\n          if (csharpStmt) {\r\n            lines.push(`        ${csharpStmt}`);\r\n          }\r\n        }\r\n      } else {\r\n        // Expression body: () => expression\r\n        const csharpExpr = generateCSharpExpression(handler.body);\r\n        lines.push(`        ${csharpExpr};`);\r\n      }\r\n    }\r\n\r\n    lines.push('    }');\r\n  }\r\n\r\n  // Toggle methods (useToggle)\r\n  for (const toggle of component.useToggle) {\r\n    lines.push('');\r\n    lines.push(`    private void ${toggle.toggleFunc}()`);\r\n    lines.push('    {');\r\n    lines.push(`        ${toggle.name} = !${toggle.name};`);\r\n    lines.push(`        SetState(\"${toggle.name}\", ${toggle.name});`);\r\n    lines.push('    }');\r\n  }\r\n\r\n  // Pub/Sub methods (usePub)\r\n  if (component.usePub) {\r\n    for (const pub of component.usePub) {\r\n      lines.push('');\r\n      lines.push(`    // Publish to ${pub.name}_channel`);\r\n      lines.push(`    private void ${pub.name}(dynamic value, PubSubOptions? options = null)`);\r\n      lines.push('    {');\r\n      lines.push(`        EventAggregator.Instance.Publish(${pub.name}_channel, value, options);`);\r\n      lines.push('    }');\r\n    }\r\n  }\r\n\r\n  // Pub/Sub methods (useSub)\r\n  if (component.useSub) {\r\n    for (const sub of component.useSub) {\r\n      lines.push('');\r\n      lines.push(`    // Subscribe to ${sub.name}_channel`);\r\n      lines.push(`    protected override void OnInitialized()`);\r\n      lines.push('    {');\r\n      lines.push(`        base.OnInitialized();`);\r\n      lines.push(`        `);\r\n      lines.push(`        // Subscribe to ${sub.name}_channel`);\r\n      lines.push(`        EventAggregator.Instance.Subscribe(${sub.name}_channel, (msg) => {`);\r\n      lines.push(`            ${sub.name}_value = msg.Value;`);\r\n      lines.push(`            SetState(\"${sub.name}_value\", ${sub.name}_value);`);\r\n      lines.push(`        });`);\r\n      lines.push('    }');\r\n    }\r\n  }\r\n\r\n  // SignalR methods (useSignalR)\r\n  if (component.useSignalR) {\r\n    for (const signalR of component.useSignalR) {\r\n      lines.push('');\r\n      lines.push(`    // SignalR send method for ${signalR.name}`);\r\n      lines.push(`    // Note: useSignalR is primarily client-side.`);\r\n      lines.push(`    // Server-side SignalR invocation can use HubContext directly if needed.`);\r\n      lines.push(`    private async Task ${signalR.name}_send(string methodName, params object[] args)`);\r\n      lines.push('    {');\r\n      lines.push(`        if (HubContext != null && ConnectionId != null)`);\r\n      lines.push(`        {`);\r\n      lines.push(`            // Send message to specific client connection`);\r\n      lines.push(`            await HubContext.Clients.Client(ConnectionId).SendAsync(methodName, args);`);\r\n      lines.push(`        }`);\r\n      lines.push('    }');\r\n    }\r\n  }\r\n\r\n  lines.push('}');\r\n\r\n  return lines;\r\n}\r\n\r\n/**\r\n * Infer C# type from JavaScript AST node (for client-computed variables)\r\n */\r\nfunction inferCSharpTypeFromInit(node) {\r\n  if (!node) return 'dynamic';\r\n\r\n  // Array types\r\n  if (t.isArrayExpression(node)) {\r\n    return 'List<dynamic>';\r\n  }\r\n\r\n  // Call expressions - try to infer from method name\r\n  if (t.isCallExpression(node)) {\r\n    const callee = node.callee;\r\n\r\n    if (t.isMemberExpression(callee) && t.isIdentifier(callee.property)) {\r\n      const method = callee.property.name;\r\n\r\n      // Common array methods return arrays\r\n      if (['map', 'filter', 'sort', 'sortBy', 'orderBy', 'slice', 'concat'].includes(method)) {\r\n        return 'List<dynamic>';\r\n      }\r\n\r\n      // Aggregation methods return numbers\r\n      if (['reduce', 'sum', 'sumBy', 'mean', 'meanBy', 'average', 'count', 'size'].includes(method)) {\r\n        return 'double';\r\n      }\r\n\r\n      // Find methods return single item\r\n      if (['find', 'minBy', 'maxBy', 'first', 'last'].includes(method)) {\r\n        return 'dynamic';\r\n      }\r\n\r\n      // String methods\r\n      if (['format', 'toString', 'join'].includes(method)) {\r\n        return 'string';\r\n      }\r\n    }\r\n\r\n    // Direct function calls (moment(), _.chain(), etc.)\r\n    return 'dynamic';\r\n  }\r\n\r\n  // String operations\r\n  if (t.isTemplateLiteral(node) || t.isStringLiteral(node)) {\r\n    return 'string';\r\n  }\r\n\r\n  // Numbers\r\n  if (t.isNumericLiteral(node)) {\r\n    return 'double';\r\n  }\r\n\r\n  // Booleans\r\n  if (t.isBooleanLiteral(node)) {\r\n    return 'bool';\r\n  }\r\n\r\n  // Binary expressions - try to infer from operation\r\n  if (t.isBinaryExpression(node)) {\r\n    if (['+', '-', '*', '/', '%'].includes(node.operator)) {\r\n      return 'double';\r\n    }\r\n    if (['==', '===', '!=', '!==', '<', '>', '<=', '>='].includes(node.operator)) {\r\n      return 'bool';\r\n    }\r\n  }\r\n\r\n  // Logical expressions\r\n  if (t.isLogicalExpression(node)) {\r\n    return 'bool';\r\n  }\r\n\r\n  // Default to dynamic\r\n  return 'dynamic';\r\n}\r\n\r\nmodule.exports = {\r\n  generateComponent,\r\n  inferCSharpTypeFromInit\r\n};\r\n","/**\r\n * C# File Generator\r\n */\r\n\r\nconst { generateComponent } = require('./component.cjs');\r\n\r\n/**\r\n * Generate C# file from components\r\n */\r\nfunction generateCSharpFile(components, state) {\r\n  const lines = [];\r\n\r\n  // Usings\r\n  lines.push('using Minimact.AspNetCore.Core;');\r\n  lines.push('using Minimact.AspNetCore.Extensions;');\r\n  lines.push('using MinimactHelpers = Minimact.AspNetCore.Core.Minimact;');\r\n  lines.push('using System.Collections.Generic;');\r\n  lines.push('using System.Linq;');\r\n  lines.push('using System.Threading.Tasks;');\r\n  lines.push('');\r\n\r\n  // Namespace (extract from file path or use default)\r\n  const namespace = state.opts.namespace || 'Minimact.Components';\r\n  lines.push(`namespace ${namespace};`);\r\n  lines.push('');\r\n\r\n  // Generate each component\r\n  for (const component of components) {\r\n    lines.push(...generateComponent(component));\r\n    lines.push('');\r\n  }\r\n\r\n  return lines.join('\\n');\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  generateCSharpFile\r\n};\r\n","/**\r\n * Minimact Babel Plugin - Complete Implementation\r\n *\r\n * Features:\r\n * - Dependency tracking for hybrid rendering\r\n * - Smart span splitting for mixed client/server state\r\n * - All hooks: useState, useEffect, useRef, useClientState, useMarkdown, useTemplate\r\n * - Conditional rendering (ternary, &&)\r\n * - List rendering (.map with key)\r\n * - Fragment support\r\n * - Props support\r\n * - TypeScript interface → C# class conversion\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { traverse } = require('@babel/core');\r\nconst fs = require('fs');\r\nconst nodePath = require('path');\r\n\r\n// Modular imports\r\nconst { processComponent } = require('./src/processComponent.cjs');\r\nconst { generateCSharpFile } = require('./src/generators/csharpFile.cjs');\r\nconst { generateTemplateMapJSON } = require('./src/extractors/templates.cjs');\r\n\r\nmodule.exports = function(babel) {\r\n  return {\r\n    name: 'minimact-full',\r\n\r\n    visitor: {\r\n      Program: {\r\n        exit(path, state) {\r\n          if (state.file.minimactComponents && state.file.minimactComponents.length > 0) {\r\n            const csharpCode = generateCSharpFile(state.file.minimactComponents, state);\r\n\r\n            state.file.metadata = state.file.metadata || {};\r\n            state.file.metadata.minimactCSharp = csharpCode;\r\n\r\n            // Generate .templates.json files for hot reload\r\n            const inputFilePath = state.file.opts.filename;\r\n            if (inputFilePath) {\r\n              for (const component of state.file.minimactComponents) {\r\n                if (component.templates && Object.keys(component.templates).length > 0) {\r\n                  const templateMapJSON = generateTemplateMapJSON(\r\n                    component.name,\r\n                    component.templates,\r\n                    {} // Attribute templates already included in component.templates\r\n                  );\r\n\r\n                  // Write to .templates.json file\r\n                  const outputDir = nodePath.dirname(inputFilePath);\r\n                  const templateFilePath = nodePath.join(outputDir, `${component.name}.templates.json`);\r\n\r\n                  try {\r\n                    fs.writeFileSync(templateFilePath, JSON.stringify(templateMapJSON, null, 2));\r\n                    console.log(`[Minimact Templates] Generated ${templateFilePath}`);\r\n                  } catch (error) {\r\n                    console.error(`[Minimact Templates] Failed to write ${templateFilePath}:`, error);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      FunctionDeclaration(path, state) {\r\n        processComponent(path, state);\r\n      },\r\n\r\n      ArrowFunctionExpression(path, state) {\r\n        if (path.parent.type === 'VariableDeclarator' || path.parent.type === 'ExportNamedDeclaration') {\r\n          processComponent(path, state);\r\n        }\r\n      },\r\n\r\n      FunctionExpression(path, state) {\r\n        if (path.parent.type === 'VariableDeclarator') {\r\n          processComponent(path, state);\r\n        }\r\n      }\r\n    }\r\n  };\r\n};"],"names":["getComponentName","t","tsTypeToCSharpType","inferType","require$$0","require$$1","require$$2","require$$3","require$$4","generateCSharpExpression","extractHook","extractLocalVariables","inferPropTypes","extractTemplates","extractAttributeTemplates","generateTemplateMapJSON","addTemplateMetadata","extractLoopTemplates","extractStructuralTemplates","extractExpressionTemplates","require$$5","require$$6","require$$7","require$$8","processComponent","generateRenderBody","transpileAsyncFunctionToCSharp","indent","capitalize","generateServerTaskMethods","generateComponent","generateCSharpFile"],"mappings":"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"}