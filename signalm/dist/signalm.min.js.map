{"version":3,"file":"signalm.min.js","sources":["../src/types.ts","../src/JsonProtocol.ts","../src/RetryPolicy.ts","../src/EventEmitter.ts","../src/index.ts"],"sourcesContent":["/**\r\n * SignalM Types and Interfaces\r\n *\r\n * TypeScript definitions for SignalM connection and protocol\r\n */\r\n\r\nimport type { IRetryPolicy } from './RetryPolicy';\r\n\r\n/**\r\n * Connection state\r\n */\r\nexport enum ConnectionState {\r\n  Disconnected = 'Disconnected',\r\n  Connecting = 'Connecting',\r\n  Connected = 'Connected',\r\n  Reconnecting = 'Reconnecting'\r\n}\r\n\r\n/**\r\n * SignalM connection options\r\n */\r\nexport interface SignalMOptions {\r\n  /** Custom retry policy for reconnection */\r\n  reconnectPolicy?: IRetryPolicy;\r\n\r\n  /** Enable debug logging */\r\n  debug?: boolean;\r\n\r\n  /** Additional headers to send with connection */\r\n  headers?: Record<string, string>;\r\n\r\n  /** Connection timeout in milliseconds (default: 30000) */\r\n  connectionTimeout?: number;\r\n\r\n  /** Invocation timeout in milliseconds (default: 30000) */\r\n  invocationTimeout?: number;\r\n}\r\n\r\n/**\r\n * Pending invocation tracking\r\n */\r\nexport interface PendingInvocation {\r\n  resolve: (value: any) => void;\r\n  reject: (reason: any) => void;\r\n  timeout: number;\r\n}\r\n\r\n/**\r\n * SignalR message types\r\n * https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md\r\n */\r\nexport enum MessageType {\r\n  /** Invocation message (client → server or server → client) */\r\n  Invocation = 1,\r\n  /** StreamItem message (not supported in SignalM) */\r\n  StreamItem = 2,\r\n  /** Completion message (response to invocation) */\r\n  Completion = 3,\r\n  /** StreamInvocation message (not supported in SignalM) */\r\n  StreamInvocation = 4,\r\n  /** CancelInvocation message (not supported in SignalM) */\r\n  CancelInvocation = 5,\r\n  /** Ping message */\r\n  Ping = 6,\r\n  /** Close message */\r\n  Close = 7\r\n}\r\n\r\n/**\r\n * Invocation message (client → server or server → client RPC call)\r\n */\r\nexport interface InvocationMessage {\r\n  type: MessageType.Invocation;\r\n  invocationId?: string;\r\n  target: string;\r\n  arguments: any[];\r\n  streamIds?: string[];\r\n}\r\n\r\n/**\r\n * Completion message (response to invocation)\r\n */\r\nexport interface CompletionMessage {\r\n  type: MessageType.Completion;\r\n  invocationId: string;\r\n  result?: any;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Ping message (keep-alive)\r\n */\r\nexport interface PingMessage {\r\n  type: MessageType.Ping;\r\n}\r\n\r\n/**\r\n * Close message (connection termination)\r\n */\r\nexport interface CloseMessage {\r\n  type: MessageType.Close;\r\n  error?: string;\r\n  allowReconnect?: boolean;\r\n}\r\n\r\n/**\r\n * Union type of all message types\r\n */\r\nexport type Message = InvocationMessage | CompletionMessage | PingMessage | CloseMessage;\r\n\r\n/**\r\n * Connection event types\r\n */\r\nexport type ConnectionEvent = 'connected' | 'disconnected' | 'reconnecting' | 'reconnected' | 'error';\r\n","/**\r\n * SignalR JSON Protocol Implementation\r\n *\r\n * Implements the SignalR JSON protocol for message serialization.\r\n * Compatible with ASP.NET Core SignalR hubs.\r\n *\r\n * Protocol Spec: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md\r\n */\r\n\r\nimport type {\r\n  Message,\r\n  InvocationMessage,\r\n  CompletionMessage,\r\n  PingMessage,\r\n  CloseMessage,\r\n  MessageType\r\n} from './types';\r\n\r\nexport class JsonProtocol {\r\n  /**\r\n   * Protocol name\r\n   */\r\n  static readonly name = 'json';\r\n\r\n  /**\r\n   * Protocol version\r\n   */\r\n  static readonly version = 1;\r\n\r\n  /**\r\n   * Write invocation message (client → server RPC call)\r\n   */\r\n  static writeInvocation(\r\n    invocationId: string,\r\n    target: string,\r\n    args: any[]\r\n  ): InvocationMessage {\r\n    return {\r\n      type: 1 as MessageType.Invocation,\r\n      invocationId,\r\n      target,\r\n      arguments: args\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Write message without response (fire-and-forget)\r\n   */\r\n  static writeMessage(target: string, args: any[]): InvocationMessage {\r\n    return {\r\n      type: 1 as MessageType.Invocation,\r\n      target,\r\n      arguments: args\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Write ping message (keep-alive)\r\n   */\r\n  static writePing(): PingMessage {\r\n    return {\r\n      type: 6 as MessageType.Ping\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Write close message\r\n   */\r\n  static writeClose(error?: string): CloseMessage {\r\n    return {\r\n      type: 7 as MessageType.Close,\r\n      error\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Parse incoming message\r\n   */\r\n  static parseMessage(data: string): Message {\r\n    try {\r\n      return JSON.parse(data) as Message;\r\n    } catch (error) {\r\n      throw new Error(`Failed to parse message: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Serialize message to JSON string\r\n   */\r\n  static serializeMessage(message: Message): string {\r\n    return JSON.stringify(message);\r\n  }\r\n\r\n  /**\r\n   * Check if message is invocation\r\n   */\r\n  static isInvocation(message: Message): message is InvocationMessage {\r\n    return message.type === 1;\r\n  }\r\n\r\n  /**\r\n   * Check if message is completion\r\n   */\r\n  static isCompletion(message: Message): message is CompletionMessage {\r\n    return message.type === 3;\r\n  }\r\n\r\n  /**\r\n   * Check if message is ping\r\n   */\r\n  static isPing(message: Message): message is PingMessage {\r\n    return message.type === 6;\r\n  }\r\n\r\n  /**\r\n   * Check if message is close\r\n   */\r\n  static isClose(message: Message): message is CloseMessage {\r\n    return message.type === 7;\r\n  }\r\n}\r\n","/**\r\n * Retry Policy Interface and Implementations\r\n *\r\n * Defines reconnection strategies for SignalM connections\r\n */\r\n\r\n/**\r\n * Retry policy interface\r\n */\r\nexport interface IRetryPolicy {\r\n  /**\r\n   * Get next retry delay in milliseconds\r\n   * Returns null if max retries exceeded\r\n   *\r\n   * @param retryAttempt - The retry attempt number (0-indexed)\r\n   * @returns Delay in milliseconds, or null to stop retrying\r\n   */\r\n  nextRetryDelay(retryAttempt: number): number | null;\r\n}\r\n\r\n/**\r\n * Exponential backoff retry policy\r\n *\r\n * Retry delays: 0ms, 2s, 10s, 30s, then 60s max\r\n * Allows infinite retries with capped delay\r\n */\r\nexport class ExponentialBackoffRetryPolicy implements IRetryPolicy {\r\n  private delays = [0, 2000, 10000, 30000];\r\n  private maxDelay = 60000; // 60 seconds\r\n\r\n  nextRetryDelay(retryAttempt: number): number | null {\r\n    // Allow infinite retries, but cap delay at maxDelay\r\n    if (retryAttempt < this.delays.length) {\r\n      return this.delays[retryAttempt];\r\n    }\r\n    return this.maxDelay;\r\n  }\r\n}\r\n\r\n/**\r\n * Fixed interval retry policy\r\n *\r\n * Retries at fixed intervals with a maximum retry count\r\n */\r\nexport class FixedRetryPolicy implements IRetryPolicy {\r\n  private interval: number;\r\n  private maxRetries: number;\r\n\r\n  /**\r\n   * Create a fixed retry policy\r\n   *\r\n   * @param interval - Retry interval in milliseconds (default: 5000)\r\n   * @param maxRetries - Maximum number of retries (default: 10)\r\n   */\r\n  constructor(interval: number = 5000, maxRetries: number = 10) {\r\n    this.interval = interval;\r\n    this.maxRetries = maxRetries;\r\n  }\r\n\r\n  nextRetryDelay(retryAttempt: number): number | null {\r\n    if (retryAttempt >= this.maxRetries) {\r\n      return null; // Max retries exceeded\r\n    }\r\n    return this.interval;\r\n  }\r\n}\r\n\r\n/**\r\n * No retry policy\r\n *\r\n * Fails immediately without retrying\r\n */\r\nexport class NoRetryPolicy implements IRetryPolicy {\r\n  nextRetryDelay(): null {\r\n    return null; // Never retry\r\n  }\r\n}\r\n\r\n/**\r\n * Custom retry policy with configurable delays\r\n *\r\n * Allows specifying exact retry delays\r\n */\r\nexport class CustomRetryPolicy implements IRetryPolicy {\r\n  private delays: number[];\r\n  private repeatLast: boolean;\r\n\r\n  /**\r\n   * Create a custom retry policy\r\n   *\r\n   * @param delays - Array of retry delays in milliseconds\r\n   * @param repeatLast - If true, repeat the last delay infinitely (default: false)\r\n   */\r\n  constructor(delays: number[], repeatLast: boolean = false) {\r\n    if (delays.length === 0) {\r\n      throw new Error('Delays array cannot be empty');\r\n    }\r\n    this.delays = delays;\r\n    this.repeatLast = repeatLast;\r\n  }\r\n\r\n  nextRetryDelay(retryAttempt: number): number | null {\r\n    if (retryAttempt < this.delays.length) {\r\n      return this.delays[retryAttempt];\r\n    }\r\n\r\n    if (this.repeatLast) {\r\n      return this.delays[this.delays.length - 1];\r\n    }\r\n\r\n    return null; // No more retries\r\n  }\r\n}\r\n","/**\r\n * Simple Event Emitter\r\n *\r\n * Lightweight event handling for SignalM connections\r\n */\r\n\r\nexport class EventEmitter {\r\n  private events = new Map<string, Function[]>();\r\n\r\n  /**\r\n   * Register an event handler\r\n   *\r\n   * @param event - Event name\r\n   * @param handler - Event handler function\r\n   */\r\n  on(event: string, handler: Function): void {\r\n    if (!this.events.has(event)) {\r\n      this.events.set(event, []);\r\n    }\r\n    this.events.get(event)!.push(handler);\r\n  }\r\n\r\n  /**\r\n   * Unregister an event handler\r\n   *\r\n   * @param event - Event name\r\n   * @param handler - Event handler function to remove\r\n   */\r\n  off(event: string, handler: Function): void {\r\n    const handlers = this.events.get(event);\r\n    if (handlers) {\r\n      const index = handlers.indexOf(handler);\r\n      if (index !== -1) {\r\n        handlers.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register a one-time event handler\r\n   *\r\n   * @param event - Event name\r\n   * @param handler - Event handler function (will be called once)\r\n   */\r\n  once(event: string, handler: Function): void {\r\n    const onceHandler = (...args: any[]) => {\r\n      handler(...args);\r\n      this.off(event, onceHandler);\r\n    };\r\n    this.on(event, onceHandler);\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   *\r\n   * @param event - Event name\r\n   * @param args - Event arguments\r\n   */\r\n  emit(event: string, ...args: any[]): void {\r\n    const handlers = this.events.get(event);\r\n    if (handlers) {\r\n      // Create a copy to avoid issues if handlers are removed during iteration\r\n      const handlersCopy = [...handlers];\r\n      handlersCopy.forEach(handler => {\r\n        try {\r\n          handler(...args);\r\n        } catch (error) {\r\n          console.error(`[SignalM] Error in event handler for '${event}':`, error);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove all event handlers for a specific event\r\n   *\r\n   * @param event - Event name (if not provided, clears all events)\r\n   */\r\n  removeAllListeners(event?: string): void {\r\n    if (event) {\r\n      this.events.delete(event);\r\n    } else {\r\n      this.events.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the number of listeners for an event\r\n   *\r\n   * @param event - Event name\r\n   * @returns Number of listeners\r\n   */\r\n  listenerCount(event: string): number {\r\n    const handlers = this.events.get(event);\r\n    return handlers ? handlers.length : 0;\r\n  }\r\n\r\n  /**\r\n   * Get all event names with listeners\r\n   *\r\n   * @returns Array of event names\r\n   */\r\n  eventNames(): string[] {\r\n    return Array.from(this.events.keys());\r\n  }\r\n}\r\n","/**\r\n * SignalM - Lightweight real-time for modern browsers\r\n *\r\n * Compatible with ASP.NET Core SignalR hubs\r\n * WebSocket + JSON only, ~2-3 KB gzipped\r\n *\r\n * @packageDocumentation\r\n */\r\n\r\n// Export types\r\nexport { ConnectionState } from './types';\r\nexport type {\r\n  SignalMOptions,\r\n  Message,\r\n  InvocationMessage,\r\n  CompletionMessage,\r\n  PingMessage,\r\n  CloseMessage,\r\n  MessageType,\r\n  ConnectionEvent\r\n} from './types';\r\n\r\n// Export retry policies\r\nexport {\r\n  ExponentialBackoffRetryPolicy,\r\n  FixedRetryPolicy,\r\n  NoRetryPolicy,\r\n  CustomRetryPolicy\r\n} from './RetryPolicy';\r\nexport type { IRetryPolicy } from './RetryPolicy';\r\n\r\n// Export protocol\r\nexport { JsonProtocol } from './JsonProtocol';\r\n\r\n// Export event emitter\r\nexport { EventEmitter } from './EventEmitter';\r\n\r\n// Version\r\nexport const VERSION = '0.1.0';\r\n\r\n// Note: SignalMConnection will be exported here once implemented\r\n// export { SignalMConnection } from './SignalMConnection';\r\n"],"names":["ConnectionState","MessageType","JsonProtocol","writeInvocation","invocationId","target","args","type","arguments","writeMessage","writePing","writeClose","error","parseMessage","data","JSON","parse","Error","serializeMessage","message","stringify","isInvocation","isCompletion","isPing","isClose","name","version","constructor","delays","repeatLast","length","this","nextRetryDelay","retryAttempt","events","Map","on","event","handler","has","set","get","push","off","handlers","index","indexOf","splice","once","onceHandler","emit","forEach","console","removeAllListeners","delete","clear","listenerCount","eventNames","Array","from","keys","maxDelay","interval","maxRetries"],"mappings":"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"}