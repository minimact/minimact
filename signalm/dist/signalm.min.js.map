{"version":3,"file":"signalm.min.js","sources":["../src/types.ts","../src/RetryPolicy.ts","../src/JsonProtocol.ts","../src/EventEmitter.ts","../node_modules/tslib/tslib.es6.js","../src/SignalMConnection.ts","../src/index.ts"],"sourcesContent":["/**\r\n * SignalM Types and Interfaces\r\n *\r\n * TypeScript definitions for SignalM connection and protocol\r\n */\r\n\r\nimport type { IRetryPolicy } from './RetryPolicy';\r\n\r\n/**\r\n * Connection state\r\n */\r\nexport enum ConnectionState {\r\n  Disconnected = 'Disconnected',\r\n  Connecting = 'Connecting',\r\n  Connected = 'Connected',\r\n  Reconnecting = 'Reconnecting'\r\n}\r\n\r\n/**\r\n * SignalM connection options\r\n */\r\nexport interface SignalMOptions {\r\n  /** Custom retry policy for reconnection */\r\n  reconnectPolicy?: IRetryPolicy;\r\n\r\n  /** Enable debug logging */\r\n  debug?: boolean;\r\n\r\n  /** Additional headers to send with connection */\r\n  headers?: Record<string, string>;\r\n\r\n  /** Connection timeout in milliseconds (default: 30000) */\r\n  connectionTimeout?: number;\r\n\r\n  /** Invocation timeout in milliseconds (default: 30000) */\r\n  invocationTimeout?: number;\r\n}\r\n\r\n/**\r\n * Pending invocation tracking\r\n */\r\nexport interface PendingInvocation {\r\n  resolve: (value: any) => void;\r\n  reject: (reason: any) => void;\r\n  timeout: number;\r\n}\r\n\r\n/**\r\n * SignalR message types\r\n * https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md\r\n */\r\nexport enum MessageType {\r\n  /** Invocation message (client → server or server → client) */\r\n  Invocation = 1,\r\n  /** StreamItem message (not supported in SignalM) */\r\n  StreamItem = 2,\r\n  /** Completion message (response to invocation) */\r\n  Completion = 3,\r\n  /** StreamInvocation message (not supported in SignalM) */\r\n  StreamInvocation = 4,\r\n  /** CancelInvocation message (not supported in SignalM) */\r\n  CancelInvocation = 5,\r\n  /** Ping message */\r\n  Ping = 6,\r\n  /** Close message */\r\n  Close = 7\r\n}\r\n\r\n/**\r\n * Invocation message (client → server or server → client RPC call)\r\n */\r\nexport interface InvocationMessage {\r\n  type: MessageType.Invocation;\r\n  invocationId?: string;\r\n  target: string;\r\n  arguments: any[];\r\n  streamIds?: string[];\r\n}\r\n\r\n/**\r\n * Completion message (response to invocation)\r\n */\r\nexport interface CompletionMessage {\r\n  type: MessageType.Completion;\r\n  invocationId: string;\r\n  result?: any;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Ping message (keep-alive)\r\n */\r\nexport interface PingMessage {\r\n  type: MessageType.Ping;\r\n}\r\n\r\n/**\r\n * Close message (connection termination)\r\n */\r\nexport interface CloseMessage {\r\n  type: MessageType.Close;\r\n  error?: string;\r\n  allowReconnect?: boolean;\r\n}\r\n\r\n/**\r\n * Union type of all message types\r\n */\r\nexport type Message = InvocationMessage | CompletionMessage | PingMessage | CloseMessage;\r\n\r\n/**\r\n * Connection event types\r\n */\r\nexport type ConnectionEvent = 'connected' | 'disconnected' | 'reconnecting' | 'reconnected' | 'error';\r\n","/**\r\n * Retry Policy Interface and Implementations\r\n *\r\n * Defines reconnection strategies for SignalM connections\r\n */\r\n\r\n/**\r\n * Retry policy interface\r\n */\r\nexport interface IRetryPolicy {\r\n  /**\r\n   * Get next retry delay in milliseconds\r\n   * Returns null if max retries exceeded\r\n   *\r\n   * @param retryAttempt - The retry attempt number (0-indexed)\r\n   * @returns Delay in milliseconds, or null to stop retrying\r\n   */\r\n  nextRetryDelay(retryAttempt: number): number | null;\r\n}\r\n\r\n/**\r\n * Exponential backoff retry policy\r\n *\r\n * Retry delays: 0ms, 2s, 10s, 30s, then 60s max\r\n * Allows infinite retries with capped delay\r\n */\r\nexport class ExponentialBackoffRetryPolicy implements IRetryPolicy {\r\n  private delays = [0, 2000, 10000, 30000];\r\n  private maxDelay = 60000; // 60 seconds\r\n\r\n  nextRetryDelay(retryAttempt: number): number | null {\r\n    // Allow infinite retries, but cap delay at maxDelay\r\n    if (retryAttempt < this.delays.length) {\r\n      return this.delays[retryAttempt];\r\n    }\r\n    return this.maxDelay;\r\n  }\r\n}\r\n\r\n/**\r\n * Fixed interval retry policy\r\n *\r\n * Retries at fixed intervals with a maximum retry count\r\n */\r\nexport class FixedRetryPolicy implements IRetryPolicy {\r\n  private interval: number;\r\n  private maxRetries: number;\r\n\r\n  /**\r\n   * Create a fixed retry policy\r\n   *\r\n   * @param interval - Retry interval in milliseconds (default: 5000)\r\n   * @param maxRetries - Maximum number of retries (default: 10)\r\n   */\r\n  constructor(interval: number = 5000, maxRetries: number = 10) {\r\n    this.interval = interval;\r\n    this.maxRetries = maxRetries;\r\n  }\r\n\r\n  nextRetryDelay(retryAttempt: number): number | null {\r\n    if (retryAttempt >= this.maxRetries) {\r\n      return null; // Max retries exceeded\r\n    }\r\n    return this.interval;\r\n  }\r\n}\r\n\r\n/**\r\n * No retry policy\r\n *\r\n * Fails immediately without retrying\r\n */\r\nexport class NoRetryPolicy implements IRetryPolicy {\r\n  nextRetryDelay(): null {\r\n    return null; // Never retry\r\n  }\r\n}\r\n\r\n/**\r\n * Custom retry policy with configurable delays\r\n *\r\n * Allows specifying exact retry delays\r\n */\r\nexport class CustomRetryPolicy implements IRetryPolicy {\r\n  private delays: number[];\r\n  private repeatLast: boolean;\r\n\r\n  /**\r\n   * Create a custom retry policy\r\n   *\r\n   * @param delays - Array of retry delays in milliseconds\r\n   * @param repeatLast - If true, repeat the last delay infinitely (default: false)\r\n   */\r\n  constructor(delays: number[], repeatLast: boolean = false) {\r\n    if (delays.length === 0) {\r\n      throw new Error('Delays array cannot be empty');\r\n    }\r\n    this.delays = delays;\r\n    this.repeatLast = repeatLast;\r\n  }\r\n\r\n  nextRetryDelay(retryAttempt: number): number | null {\r\n    if (retryAttempt < this.delays.length) {\r\n      return this.delays[retryAttempt];\r\n    }\r\n\r\n    if (this.repeatLast) {\r\n      return this.delays[this.delays.length - 1];\r\n    }\r\n\r\n    return null; // No more retries\r\n  }\r\n}\r\n","/**\r\n * SignalR JSON Protocol Implementation\r\n *\r\n * Implements the SignalR JSON protocol for message serialization.\r\n * Compatible with ASP.NET Core SignalR hubs.\r\n *\r\n * Protocol Spec: https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md\r\n */\r\n\r\nimport type {\r\n  Message,\r\n  InvocationMessage,\r\n  CompletionMessage,\r\n  PingMessage,\r\n  CloseMessage,\r\n  MessageType\r\n} from './types';\r\n\r\nexport class JsonProtocol {\r\n  /**\r\n   * Protocol name\r\n   */\r\n  static readonly protocolName = 'json';\r\n\r\n  /**\r\n   * Protocol version\r\n   */\r\n  static readonly protocolVersion = 1;\r\n\r\n  /**\r\n   * Write invocation message (client → server RPC call)\r\n   */\r\n  static writeInvocation(\r\n    invocationId: string,\r\n    target: string,\r\n    args: any[]\r\n  ): InvocationMessage {\r\n    return {\r\n      type: 1 as MessageType.Invocation,\r\n      invocationId,\r\n      target,\r\n      arguments: args\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Write message without response (fire-and-forget)\r\n   */\r\n  static writeMessage(target: string, args: any[]): InvocationMessage {\r\n    return {\r\n      type: 1 as MessageType.Invocation,\r\n      target,\r\n      arguments: args\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Write ping message (keep-alive)\r\n   */\r\n  static writePing(): PingMessage {\r\n    return {\r\n      type: 6 as MessageType.Ping\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Write close message\r\n   */\r\n  static writeClose(error?: string): CloseMessage {\r\n    return {\r\n      type: 7 as MessageType.Close,\r\n      error\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Parse incoming message\r\n   */\r\n  static parseMessage(data: string): Message {\r\n    try {\r\n      return JSON.parse(data) as Message;\r\n    } catch (error) {\r\n      throw new Error(`Failed to parse message: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Serialize message to JSON string\r\n   */\r\n  static serializeMessage(message: Message): string {\r\n    return JSON.stringify(message);\r\n  }\r\n\r\n  /**\r\n   * Check if message is invocation\r\n   */\r\n  static isInvocation(message: Message): message is InvocationMessage {\r\n    return message.type === 1;\r\n  }\r\n\r\n  /**\r\n   * Check if message is completion\r\n   */\r\n  static isCompletion(message: Message): message is CompletionMessage {\r\n    return message.type === 3;\r\n  }\r\n\r\n  /**\r\n   * Check if message is ping\r\n   */\r\n  static isPing(message: Message): message is PingMessage {\r\n    return message.type === 6;\r\n  }\r\n\r\n  /**\r\n   * Check if message is close\r\n   */\r\n  static isClose(message: Message): message is CloseMessage {\r\n    return message.type === 7;\r\n  }\r\n}\r\n","/**\r\n * Simple Event Emitter\r\n *\r\n * Lightweight event handling for SignalM connections\r\n */\r\n\r\nexport class EventEmitter {\r\n  private events = new Map<string, Function[]>();\r\n\r\n  /**\r\n   * Register an event handler\r\n   *\r\n   * @param event - Event name\r\n   * @param handler - Event handler function\r\n   */\r\n  on(event: string, handler: Function): void {\r\n    if (!this.events.has(event)) {\r\n      this.events.set(event, []);\r\n    }\r\n    this.events.get(event)!.push(handler);\r\n  }\r\n\r\n  /**\r\n   * Unregister an event handler\r\n   *\r\n   * @param event - Event name\r\n   * @param handler - Event handler function to remove\r\n   */\r\n  off(event: string, handler: Function): void {\r\n    const handlers = this.events.get(event);\r\n    if (handlers) {\r\n      const index = handlers.indexOf(handler);\r\n      if (index !== -1) {\r\n        handlers.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register a one-time event handler\r\n   *\r\n   * @param event - Event name\r\n   * @param handler - Event handler function (will be called once)\r\n   */\r\n  once(event: string, handler: Function): void {\r\n    const onceHandler = (...args: any[]) => {\r\n      handler(...args);\r\n      this.off(event, onceHandler);\r\n    };\r\n    this.on(event, onceHandler);\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   *\r\n   * @param event - Event name\r\n   * @param args - Event arguments\r\n   */\r\n  emit(event: string, ...args: any[]): void {\r\n    const handlers = this.events.get(event);\r\n    if (handlers) {\r\n      // Create a copy to avoid issues if handlers are removed during iteration\r\n      const handlersCopy = [...handlers];\r\n      handlersCopy.forEach(handler => {\r\n        try {\r\n          handler(...args);\r\n        } catch (error) {\r\n          console.error(`[SignalM] Error in event handler for '${event}':`, error);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove all event handlers for a specific event\r\n   *\r\n   * @param event - Event name (if not provided, clears all events)\r\n   */\r\n  removeAllListeners(event?: string): void {\r\n    if (event) {\r\n      this.events.delete(event);\r\n    } else {\r\n      this.events.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the number of listeners for an event\r\n   *\r\n   * @param event - Event name\r\n   * @returns Number of listeners\r\n   */\r\n  listenerCount(event: string): number {\r\n    const handlers = this.events.get(event);\r\n    return handlers ? handlers.length : 0;\r\n  }\r\n\r\n  /**\r\n   * Get all event names with listeners\r\n   *\r\n   * @returns Array of event names\r\n   */\r\n  eventNames(): string[] {\r\n    return Array.from(this.events.keys());\r\n  }\r\n}\r\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","/**\r\n * SignalM Connection\r\n *\r\n * Lightweight WebSocket-based connection compatible with SignalR hubs.\r\n * Supports method invocation, event handling, and automatic reconnection.\r\n */\r\n\r\nimport { EventEmitter } from './EventEmitter';\r\nimport { JsonProtocol } from './JsonProtocol';\r\nimport { ExponentialBackoffRetryPolicy, type IRetryPolicy } from './RetryPolicy';\r\nimport {\r\n  ConnectionState,\r\n  type SignalMOptions,\r\n  type PendingInvocation\r\n} from './types';\r\n\r\nexport class SignalMConnection {\r\n  private ws: WebSocket | null = null;\r\n  private url: string;\r\n  private handlers = new Map<string, Function[]>();\r\n  private pendingInvocations = new Map<string, PendingInvocation>();\r\n  private invocationId = 0;\r\n  private reconnectPolicy: IRetryPolicy;\r\n  private state: ConnectionState = ConnectionState.Disconnected;\r\n  private reconnectAttempts = 0;\r\n  private eventEmitter: EventEmitter;\r\n  private debugLogging: boolean;\r\n  private connectionTimeout: number;\r\n  private invocationTimeout: number;\r\n  private reconnectTimeoutId: number | null = null;\r\n\r\n  constructor(url: string, options: SignalMOptions = {}) {\r\n    this.url = url;\r\n    this.reconnectPolicy = options.reconnectPolicy || new ExponentialBackoffRetryPolicy();\r\n    this.debugLogging = options.debug || false;\r\n    this.connectionTimeout = options.connectionTimeout || 30000;\r\n    this.invocationTimeout = options.invocationTimeout || 30000;\r\n    this.eventEmitter = new EventEmitter();\r\n  }\r\n\r\n  /**\r\n   * Start the connection\r\n   */\r\n  async start(): Promise<void> {\r\n    if (this.state !== ConnectionState.Disconnected) {\r\n      throw new Error('Connection is already started');\r\n    }\r\n\r\n    this.state = ConnectionState.Connecting;\r\n    this.log('Starting connection...');\r\n    return this.connect();\r\n  }\r\n\r\n  /**\r\n   * Stop the connection\r\n   */\r\n  async stop(): Promise<void> {\r\n    this.log('Stopping connection...');\r\n\r\n    // Clear any pending reconnect\r\n    if (this.reconnectTimeoutId !== null) {\r\n      clearTimeout(this.reconnectTimeoutId);\r\n      this.reconnectTimeoutId = null;\r\n    }\r\n\r\n    if (this.ws) {\r\n      this.ws.close(1000, 'Normal closure');\r\n      this.ws = null;\r\n    }\r\n\r\n    this.state = ConnectionState.Disconnected;\r\n    this.eventEmitter.emit('disconnected');\r\n  }\r\n\r\n  /**\r\n   * Invoke a server method and wait for result\r\n   */\r\n  async invoke<T = any>(methodName: string, ...args: any[]): Promise<T> {\r\n    if (this.state !== ConnectionState.Connected) {\r\n      throw new Error(`Connection is not in Connected state (current: ${this.state})`);\r\n    }\r\n\r\n    const invocationId = this.generateInvocationId();\r\n    const message = JsonProtocol.writeInvocation(invocationId, methodName, args);\r\n\r\n    return new Promise<T>((resolve, reject) => {\r\n      const timeout = setTimeout(() => {\r\n        this.pendingInvocations.delete(invocationId);\r\n        reject(new Error(`Invocation '${methodName}' timed out after ${this.invocationTimeout}ms`));\r\n      }, this.invocationTimeout);\r\n\r\n      this.pendingInvocations.set(invocationId, {\r\n        resolve,\r\n        reject,\r\n        timeout: timeout as unknown as number\r\n      });\r\n\r\n      const serialized = JsonProtocol.serializeMessage(message);\r\n      this.log(`Invoking '${methodName}' (id: ${invocationId})`, args);\r\n      this.ws!.send(serialized);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Send a message without expecting a response (fire-and-forget)\r\n   */\r\n  send(methodName: string, ...args: any[]): void {\r\n    if (this.state !== ConnectionState.Connected) {\r\n      throw new Error(`Connection is not in Connected state (current: ${this.state})`);\r\n    }\r\n\r\n    const message = JsonProtocol.writeMessage(methodName, args);\r\n    const serialized = JsonProtocol.serializeMessage(message);\r\n    this.log(`Sending '${methodName}' (fire-and-forget)`, args);\r\n    this.ws!.send(serialized);\r\n  }\r\n\r\n  /**\r\n   * Register a handler for server-to-client method calls\r\n   */\r\n  on(methodName: string, handler: (...args: any[]) => void): void {\r\n    if (!this.handlers.has(methodName)) {\r\n      this.handlers.set(methodName, []);\r\n    }\r\n    this.handlers.get(methodName)!.push(handler);\r\n    this.log(`Registered handler for '${methodName}'`);\r\n  }\r\n\r\n  /**\r\n   * Remove a handler\r\n   */\r\n  off(methodName: string, handler: (...args: any[]) => void): void {\r\n    const handlers = this.handlers.get(methodName);\r\n    if (handlers) {\r\n      const index = handlers.indexOf(handler);\r\n      if (index !== -1) {\r\n        handlers.splice(index, 1);\r\n        this.log(`Removed handler for '${methodName}'`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register event listener for connection lifecycle events\r\n   */\r\n  onConnected(handler: () => void): void {\r\n    this.eventEmitter.on('connected', handler);\r\n  }\r\n\r\n  onDisconnected(handler: () => void): void {\r\n    this.eventEmitter.on('disconnected', handler);\r\n  }\r\n\r\n  onReconnecting(handler: () => void): void {\r\n    this.eventEmitter.on('reconnecting', handler);\r\n  }\r\n\r\n  onReconnected(handler: () => void): void {\r\n    this.eventEmitter.on('reconnected', handler);\r\n  }\r\n\r\n  onError(handler: (error: Error) => void): void {\r\n    this.eventEmitter.on('error', handler);\r\n  }\r\n\r\n  /**\r\n   * Get current connection state\r\n   */\r\n  get connectionState(): ConnectionState {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Internal: Connect to WebSocket\r\n   */\r\n  private async connect(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      const wsUrl = this.buildWebSocketUrl();\r\n      this.log(`Connecting to ${wsUrl}...`);\r\n\r\n      try {\r\n        this.ws = new WebSocket(wsUrl);\r\n      } catch (error) {\r\n        reject(error);\r\n        return;\r\n      }\r\n\r\n      // Connection timeout\r\n      const connectionTimeout = setTimeout(() => {\r\n        if (this.state === ConnectionState.Connecting) {\r\n          this.log('Connection timeout');\r\n          this.ws?.close();\r\n          reject(new Error(`Connection timeout after ${this.connectionTimeout}ms`));\r\n        }\r\n      }, this.connectionTimeout);\r\n\r\n      this.ws.onopen = () => {\r\n        clearTimeout(connectionTimeout);\r\n        this.state = ConnectionState.Connected;\r\n        this.reconnectAttempts = 0;\r\n        this.log('Connected ✓');\r\n        this.eventEmitter.emit('connected');\r\n        resolve();\r\n      };\r\n\r\n      this.ws.onmessage = (event) => {\r\n        this.handleMessage(event.data);\r\n      };\r\n\r\n      this.ws.onerror = (error) => {\r\n        this.log('WebSocket error', error);\r\n        this.eventEmitter.emit('error', new Error('WebSocket error'));\r\n      };\r\n\r\n      this.ws.onclose = (event) => {\r\n        clearTimeout(connectionTimeout);\r\n        this.handleClose(event);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Internal: Handle incoming messages\r\n   */\r\n  private handleMessage(data: string): void {\r\n    try {\r\n      const message = JsonProtocol.parseMessage(data);\r\n      this.log(`Received message (type: ${message.type})`, message);\r\n\r\n      if (JsonProtocol.isInvocation(message)) {\r\n        // Server calling client method\r\n        this.handleInvocation(message);\r\n      } else if (JsonProtocol.isCompletion(message)) {\r\n        // Response to client invoke()\r\n        this.handleCompletion(message);\r\n      } else if (JsonProtocol.isPing(message)) {\r\n        // Server ping (respond with pong)\r\n        this.handlePing();\r\n      } else if (JsonProtocol.isClose(message)) {\r\n        // Server requested close\r\n        this.log('Server requested close', message.error);\r\n        this.ws?.close(1000, 'Server closed connection');\r\n      }\r\n    } catch (error) {\r\n      this.log('Error parsing message', error);\r\n      console.error('[SignalM] Error parsing message:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal: Handle server-to-client invocation\r\n   */\r\n  private handleInvocation(message: any): void {\r\n    const handlers = this.handlers.get(message.target);\r\n    if (handlers) {\r\n      this.log(`Calling ${handlers.length} handler(s) for '${message.target}'`);\r\n      handlers.forEach(handler => {\r\n        try {\r\n          handler(...(message.arguments || []));\r\n        } catch (error) {\r\n          console.error(`[SignalM] Error in handler for '${message.target}':`, error);\r\n        }\r\n      });\r\n    } else {\r\n      this.log(`No handler registered for '${message.target}'`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal: Handle completion (response to invoke)\r\n   */\r\n  private handleCompletion(message: any): void {\r\n    const pending = this.pendingInvocations.get(message.invocationId);\r\n    if (pending) {\r\n      clearTimeout(pending.timeout);\r\n      this.pendingInvocations.delete(message.invocationId);\r\n\r\n      if (message.error) {\r\n        this.log(`Invocation ${message.invocationId} failed: ${message.error}`);\r\n        pending.reject(new Error(message.error));\r\n      } else {\r\n        this.log(`Invocation ${message.invocationId} completed`, message.result);\r\n        pending.resolve(message.result);\r\n      }\r\n    } else {\r\n      this.log(`Received completion for unknown invocation ${message.invocationId}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal: Handle ping (send pong)\r\n   */\r\n  private handlePing(): void {\r\n    const pongMessage = JsonProtocol.writePing(); // Pong uses same message type\r\n    const serialized = JsonProtocol.serializeMessage(pongMessage);\r\n    this.log('Received ping, sending pong');\r\n    this.ws?.send(serialized);\r\n  }\r\n\r\n  /**\r\n   * Internal: Handle connection close\r\n   */\r\n  private handleClose(event: CloseEvent): void {\r\n    this.log(`Connection closed (code: ${event.code}, reason: ${event.reason})`);\r\n    this.state = ConnectionState.Disconnected;\r\n    this.ws = null;\r\n\r\n    // Reject all pending invocations\r\n    this.pendingInvocations.forEach((pending) => {\r\n      clearTimeout(pending.timeout);\r\n      pending.reject(new Error('Connection closed'));\r\n    });\r\n    this.pendingInvocations.clear();\r\n\r\n    // Attempt reconnection if not normal closure (1000) or going away (1001)\r\n    if (event.code !== 1000 && event.code !== 1001) {\r\n      this.attemptReconnect();\r\n    } else {\r\n      this.eventEmitter.emit('disconnected');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal: Attempt to reconnect\r\n   */\r\n  private async attemptReconnect(): Promise<void> {\r\n    const delay = this.reconnectPolicy.nextRetryDelay(this.reconnectAttempts);\r\n\r\n    if (delay === null) {\r\n      // Max retries exceeded\r\n      this.log('Max reconnection attempts exceeded');\r\n      this.eventEmitter.emit('disconnected');\r\n      return;\r\n    }\r\n\r\n    this.reconnectAttempts++;\r\n    this.state = ConnectionState.Reconnecting;\r\n    this.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})...`);\r\n    this.eventEmitter.emit('reconnecting');\r\n\r\n    this.reconnectTimeoutId = setTimeout(async () => {\r\n      this.reconnectTimeoutId = null;\r\n      try {\r\n        await this.connect();\r\n        this.log('Reconnected ✓');\r\n        this.eventEmitter.emit('reconnected');\r\n      } catch (error) {\r\n        this.log('Reconnection failed', error);\r\n        this.attemptReconnect();\r\n      }\r\n    }, delay) as unknown as number;\r\n  }\r\n\r\n  /**\r\n   * Internal: Build WebSocket URL\r\n   */\r\n  private buildWebSocketUrl(): string {\r\n    // If URL is absolute, use it as-is\r\n    if (this.url.startsWith('ws://') || this.url.startsWith('wss://')) {\r\n      return this.url;\r\n    }\r\n\r\n    // Otherwise, construct from current page location\r\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\r\n    const baseUrl = this.url.startsWith('/')\r\n      ? `${protocol}//${window.location.host}${this.url}`\r\n      : `${protocol}//${window.location.host}/${this.url}`;\r\n\r\n    return baseUrl;\r\n  }\r\n\r\n  /**\r\n   * Internal: Generate unique invocation ID\r\n   */\r\n  private generateInvocationId(): string {\r\n    return (++this.invocationId).toString();\r\n  }\r\n\r\n  /**\r\n   * Internal: Debug logging\r\n   */\r\n  private log(message: string, data?: any): void {\r\n    if (this.debugLogging) {\r\n      if (data !== undefined) {\r\n        console.log(`[SignalM] ${message}`, data);\r\n      } else {\r\n        console.log(`[SignalM] ${message}`);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * SignalM - Lightweight real-time for modern browsers\r\n *\r\n * Compatible with ASP.NET Core SignalR hubs\r\n * WebSocket + JSON only, ~2-3 KB gzipped\r\n *\r\n * @packageDocumentation\r\n */\r\n\r\n// Export types\r\nexport { ConnectionState } from './types';\r\nexport type {\r\n  SignalMOptions,\r\n  Message,\r\n  InvocationMessage,\r\n  CompletionMessage,\r\n  PingMessage,\r\n  CloseMessage,\r\n  MessageType,\r\n  ConnectionEvent\r\n} from './types';\r\n\r\n// Export retry policies\r\nexport {\r\n  ExponentialBackoffRetryPolicy,\r\n  FixedRetryPolicy,\r\n  NoRetryPolicy,\r\n  CustomRetryPolicy\r\n} from './RetryPolicy';\r\nexport type { IRetryPolicy } from './RetryPolicy';\r\n\r\n// Export protocol\r\nexport { JsonProtocol } from './JsonProtocol';\r\n\r\n// Export event emitter\r\nexport { EventEmitter } from './EventEmitter';\r\n\r\n// Export main connection class\r\nexport { SignalMConnection } from './SignalMConnection';\r\n\r\n// Version\r\nexport const VERSION = '0.1.0';\r\n"],"names":["ConnectionState","MessageType","ExponentialBackoffRetryPolicy","constructor","this","delays","maxDelay","nextRetryDelay","retryAttempt","length","JsonProtocol","writeInvocation","invocationId","target","args","type","arguments","writeMessage","writePing","writeClose","error","parseMessage","data","JSON","parse","Error","serializeMessage","message","stringify","isInvocation","isCompletion","isPing","isClose","protocolName","protocolVersion","EventEmitter","events","Map","on","event","handler","has","set","get","push","off","handlers","index","indexOf","splice","once","onceHandler","emit","forEach","console","removeAllListeners","delete","clear","listenerCount","eventNames","Array","from","keys","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","SuppressedError","repeatLast","interval","maxRetries","url","options","ws","pendingInvocations","state","Disconnected","reconnectAttempts","reconnectTimeoutId","reconnectPolicy","debugLogging","debug","connectionTimeout","invocationTimeout","eventEmitter","start","Connecting","log","connect","stop","clearTimeout","close","invoke","methodName","Connected","generateInvocationId","timeout","setTimeout","serialized","send","onConnected","onDisconnected","onReconnecting","onReconnected","onError","connectionState","wsUrl","buildWebSocketUrl","WebSocket","_a","onopen","onmessage","handleMessage","onerror","onclose","handleClose","handleInvocation","handleCompletion","handlePing","pending","pongMessage","code","reason","attemptReconnect","delay","Reconnecting","startsWith","protocol","window","location","host","undefined"],"mappings":"8OAWA,IAAYA,EAwCAC,EAxCAD,EAAAA,qBAAAA,GAAAA,EAAAA,EAAAA,kBAAAA,kBAAe,CAAA,IACzB,aAAA,eACAA,EAAA,WAAA,aACAA,EAAA,UAAA,YACAA,EAAA,aAAA,eAoCF,SAAYC,GAEVA,EAAAA,EAAA,WAAA,GAAA,aAEAA,EAAAA,EAAA,WAAA,GAAA,aAEAA,EAAAA,EAAA,WAAA,GAAA,aAEAA,EAAAA,EAAA,iBAAA,GAAA,mBAEAA,EAAAA,EAAA,iBAAA,GAAA,mBAEAA,EAAAA,EAAA,KAAA,GAAA,OAEAA,EAAAA,EAAA,MAAA,GAAA,OACD,CAfD,CAAYA,IAAAA,EAAW,CAAA,UCzBVC,EAAb,WAAAC,GACUC,KAAAC,OAAS,CAAC,EAAG,IAAM,IAAO,KAC1BD,KAAAE,SAAW,GASrB,CAPE,cAAAC,CAAeC,GAEb,OAAmBJ,KAAKC,OAAOI,OAA3BD,EACKJ,KAAKC,OAAOG,GAEdJ,KAAKE,QACd,QClBWI,EAcX,sBAAOC,CACLC,EACAC,EACAC,GAEA,MAAO,CACLC,KAAM,EACNH,eACAC,SACAG,UAAWF,EAEf,CAKA,mBAAOG,CAAaJ,EAAgBC,GAClC,MAAO,CACLC,KAAM,EACNF,SACAG,UAAWF,EAEf,CAKA,gBAAOI,GACL,MAAO,CACLH,KAAM,EAEV,CAKA,iBAAOI,CAAWC,GAChB,MAAO,CACLL,KAAM,EACNK,QAEJ,CAKA,mBAAOC,CAAaC,GAClB,IACE,OAAOC,KAAKC,MAAMF,EACpB,CAAE,MAAOF,GACP,MAAUK,MAAM,4BAA4BL,EAC9C,CACF,CAKA,uBAAOM,CAAiBC,GACtB,OAAOJ,KAAKK,UAAUD,EACxB,CAKA,mBAAOE,CAAaF,GAClB,OAAwB,IAAjBA,EAAQZ,IACjB,CAKA,mBAAOe,CAAaH,GAClB,OAAwB,IAAjBA,EAAQZ,IACjB,CAKA,aAAOgB,CAAOJ,GACZ,OAAwB,IAAjBA,EAAQZ,IACjB,CAKA,cAAOiB,CAAQL,GACb,OAAwB,IAAjBA,EAAQZ,IACjB,EAjGgBL,EAAAuB,aAAe,OAKfvB,EAAAwB,gBAAkB,QCrBvBC,EAAb,WAAAhC,GACUC,KAAAgC,OAAS,IAAIC,GAkGvB,CA1FE,EAAAC,CAAGC,EAAeC,GACXpC,KAAKgC,OAAOK,IAAIF,IACnBnC,KAAKgC,OAAOM,IAAIH,EAAO,IAEzBnC,KAAKgC,OAAOO,IAAIJ,GAAQK,KAAKJ,EAC/B,CAQA,GAAAK,CAAIN,EAAeC,GACjB,MAAMM,EAAW1C,KAAKgC,OAAOO,IAAIJ,GACjC,GAAIO,EAAU,CACZ,MAAMC,EAAQD,EAASE,QAAQR,IACjB,IAAVO,GACFD,EAASG,OAAOF,EAAO,EAE3B,CACF,CAQA,IAAAG,CAAKX,EAAeC,GAClB,MAAMW,EAAc,IAAIrC,KACtB0B,KAAW1B,GACXV,KAAKyC,IAAIN,EAAOY,IAElB/C,KAAKkC,GAAGC,EAAOY,EACjB,CAQA,IAAAC,CAAKb,KAAkBzB,GACrB,MAAMgC,EAAW1C,KAAKgC,OAAOO,IAAIJ,GAC7BO,GAEmB,IAAIA,GACZO,QAAQb,IACnB,IACEA,KAAW1B,EACb,CAAE,MAAOM,GACPkC,QAAQlC,MAAM,yCAAyCmB,MAAWnB,EACpE,GAGN,CAOA,kBAAAmC,CAAmBhB,GACbA,EACFnC,KAAKgC,OAAOoB,OAAOjB,GAEnBnC,KAAKgC,OAAOqB,OAEhB,CAQA,aAAAC,CAAcnB,GACZ,MAAMO,EAAW1C,KAAKgC,OAAOO,IAAIJ,GACjC,OAAOO,EAAWA,EAASrC,OAAS,CACtC,CAOA,UAAAkD,GACE,OAAOC,MAAMC,KAAKzD,KAAKgC,OAAO0B,OAChC,ECUK,SAASC,EAAUC,EAASC,EAAYC,EAAGC,GAE9C,OAAO,IAAKD,IAAMA,EAAIE,UAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,GAAS,CAAE,MAAOG,GAAKL,EAAOK,EAAI,CAAE,CAC1F,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,GAAS,CAAE,MAAOG,GAAKL,EAAOK,EAAI,CAAE,CAC7F,SAASF,EAAKI,GAJlB,IAAeL,EAIaK,EAAOC,KAAOT,EAAQQ,EAAOL,QAJ1CA,EAIyDK,EAAOL,MAJhDA,aAAiBN,EAAIM,EAAQ,IAAIN,EAAE,SAAUG,GAAWA,EAAQG,EAAQ,IAIjBO,KAAKR,EAAWK,EAAW,CAC7GH,GAAMN,EAAYA,EAAUa,MAAMhB,EAASC,GAAc,KAAKS,OAClE,EACJ,CA8MkD,mBAApBO,iBAAiCA,0CH3O7D,WAAA9E,CAAYE,EAAkB6E,GAAsB,GAClD,GAAsB,IAAlB7E,EAAOI,OACT,MAAUgB,MAAM,gCAElBrB,KAAKC,OAASA,EACdD,KAAK8E,WAAaA,CACpB,CAEA,cAAA3E,CAAeC,GACb,OAAmBJ,KAAKC,OAAOI,OAA3BD,EACKJ,KAAKC,OAAOG,GAGjBJ,KAAK8E,WACA9E,KAAKC,OAAOD,KAAKC,OAAOI,OAAS,GAGnC,IACT,+EAzDA,WAAAN,CAAYgF,EAAmB,IAAMC,EAAqB,IACxDhF,KAAK+E,SAAWA,EAChB/E,KAAKgF,WAAaA,CACpB,CAEA,cAAA7E,CAAeC,GACb,OAAoBJ,KAAKgF,WAArB5E,EAGGJ,KAAK+E,SAFH,IAGX,0CASA,cAAA5E,GACE,OAAO,IACT,6BI5CA,WAAAJ,CAAYkF,EAAaC,EAA0B,IAd3ClF,KAAAmF,GAAuB,KAEvBnF,KAAA0C,SAAW,IAAIT,IACfjC,KAAAoF,mBAAqB,IAAInD,IACzBjC,KAAAQ,aAAe,EAEfR,KAAAqF,MAAyBzF,EAAAA,gBAAgB0F,aACzCtF,KAAAuF,kBAAoB,EAKpBvF,KAAAwF,mBAAoC,KAG1CxF,KAAKiF,IAAMA,EACXjF,KAAKyF,gBAAkBP,EAAQO,iBAAmB,IAAI3F,EACtDE,KAAK0F,aAAeR,EAAQS,QAAS,EACrC3F,KAAK4F,kBAAoBV,EAAQU,mBAAqB,IACtD5F,KAAK6F,kBAAoBX,EAAQW,mBAAqB,IACtD7F,KAAK8F,aAAe,IAAI/D,CAC1B,CAKM,KAAAgE,2CACJ,GAAI/F,KAAKqF,QAAUzF,EAAAA,gBAAgB0F,aACjC,MAAUjE,MAAM,iCAKlB,OAFArB,KAAKqF,MAAQzF,EAAAA,gBAAgBoG,WAC7BhG,KAAKiG,IAAI,0BACFjG,KAAKkG,SACd,EAAC,CAKK,IAAAC,2CACJnG,KAAKiG,IAAI,0BAGuB,OAA5BjG,KAAKwF,qBACPY,aAAapG,KAAKwF,oBAClBxF,KAAKwF,mBAAqB,MAGxBxF,KAAKmF,KACPnF,KAAKmF,GAAGkB,MAAM,IAAM,kBACpBrG,KAAKmF,GAAK,MAGZnF,KAAKqF,MAAQzF,EAAAA,gBAAgB0F,aAC7BtF,KAAK8F,aAAa9C,KAAK,eACzB,EAAC,CAKK,MAAAsD,CAAgBC,KAAuB7F,2CAC3C,GAAIV,KAAKqF,QAAUzF,EAAAA,gBAAgB4G,UACjC,MAAUnF,MAAM,kDAAkDrB,KAAKqF,UAGzE,MAAM7E,EAAeR,KAAKyG,uBACpBlF,EAAUjB,EAAaC,gBAAgBC,EAAc+F,EAAY7F,GAEvE,OAAO,IAAIsD,QAAW,CAACC,EAASC,KAC9B,MAAMwC,EAAUC,WAAW,KACzB3G,KAAKoF,mBAAmBhC,OAAO5C,GAC/B0D,EAAW7C,MAAM,eAAekF,sBAA+BvG,KAAK6F,yBACnE7F,KAAK6F,mBAER7F,KAAKoF,mBAAmB9C,IAAI9B,EAAc,CACxCyD,UACAC,SACAwC,QAASA,IAGX,MAAME,EAAatG,EAAagB,iBAAiBC,GACjDvB,KAAKiG,IAAI,aAAaM,WAAoB/F,KAAiBE,GAC3DV,KAAKmF,GAAI0B,KAAKD,IAElB,EAAC,CAKD,IAAAC,CAAKN,KAAuB7F,GAC1B,GAAIV,KAAKqF,QAAUzF,EAAAA,gBAAgB4G,UACjC,MAAUnF,MAAM,kDAAkDrB,KAAKqF,UAGzE,MAAM9D,EAAUjB,EAAaO,aAAa0F,EAAY7F,GAChDkG,EAAatG,EAAagB,iBAAiBC,GACjDvB,KAAKiG,IAAI,YAAYM,uBAAiC7F,GACtDV,KAAKmF,GAAI0B,KAAKD,EAChB,CAKA,EAAA1E,CAAGqE,EAAoBnE,GAChBpC,KAAK0C,SAASL,IAAIkE,IACrBvG,KAAK0C,SAASJ,IAAIiE,EAAY,IAEhCvG,KAAK0C,SAASH,IAAIgE,GAAa/D,KAAKJ,GACpCpC,KAAKiG,IAAI,2BAA2BM,KACtC,CAKA,GAAA9D,CAAI8D,EAAoBnE,GACtB,MAAMM,EAAW1C,KAAK0C,SAASH,IAAIgE,GACnC,GAAI7D,EAAU,CACZ,MAAMC,EAAQD,EAASE,QAAQR,IACjB,IAAVO,IACFD,EAASG,OAAOF,EAAO,GACvB3C,KAAKiG,IAAI,wBAAwBM,MAErC,CACF,CAKA,WAAAO,CAAY1E,GACVpC,KAAK8F,aAAa5D,GAAG,YAAaE,EACpC,CAEA,cAAA2E,CAAe3E,GACbpC,KAAK8F,aAAa5D,GAAG,eAAgBE,EACvC,CAEA,cAAA4E,CAAe5E,GACbpC,KAAK8F,aAAa5D,GAAG,eAAgBE,EACvC,CAEA,aAAA6E,CAAc7E,GACZpC,KAAK8F,aAAa5D,GAAG,cAAeE,EACtC,CAEA,OAAA8E,CAAQ9E,GACNpC,KAAK8F,aAAa5D,GAAG,QAASE,EAChC,CAKA,mBAAI+E,GACF,OAAOnH,KAAKqF,KACd,CAKc,OAAAa,2CACZ,OAAO,IAAIlC,QAAQ,CAACC,EAASC,KAC3B,MAAMkD,EAAQpH,KAAKqH,oBACnBrH,KAAKiG,IAAI,iBAAiBmB,QAE1B,IACEpH,KAAKmF,GAAK,IAAImC,UAAUF,EAC1B,CAAE,MAAOpG,GAEP,YADAkD,EAAOlD,EAET,CAGA,MAAM4E,EAAoBe,WAAW,WAC/B3G,KAAKqF,QAAUzF,EAAAA,gBAAgBoG,aACjChG,KAAKiG,IAAI,sBACF,QAAPsB,EAAAvH,KAAKmF,UAAE,IAAAoC,GAAAA,EAAElB,QACTnC,EAAW7C,MAAM,4BAA4BrB,KAAK4F,0BAEnD5F,KAAK4F,mBAER5F,KAAKmF,GAAGqC,OAAS,KACfpB,aAAaR,GACb5F,KAAKqF,MAAQzF,EAAAA,gBAAgB4G,UAC7BxG,KAAKuF,kBAAoB,EACzBvF,KAAKiG,IAAI,eACTjG,KAAK8F,aAAa9C,KAAK,aACvBiB,KAGFjE,KAAKmF,GAAGsC,UAAatF,IACnBnC,KAAK0H,cAAcvF,EAAMjB,OAG3BlB,KAAKmF,GAAGwC,QAAW3G,IACjBhB,KAAKiG,IAAI,kBAAmBjF,GAC5BhB,KAAK8F,aAAa9C,KAAK,QAAa3B,MAAM,qBAG5CrB,KAAKmF,GAAGyC,QAAWzF,IACjBiE,aAAaR,GACb5F,KAAK6H,YAAY1F,KAGvB,EAAC,CAKO,aAAAuF,CAAcxG,SACpB,IACE,MAAMK,EAAUjB,EAAaW,aAAaC,GAC1ClB,KAAKiG,IAAI,2BAA2B1E,EAAQZ,QAASY,GAEjDjB,EAAamB,aAAaF,GAE5BvB,KAAK8H,iBAAiBvG,GACbjB,EAAaoB,aAAaH,GAEnCvB,KAAK+H,iBAAiBxG,GACbjB,EAAaqB,OAAOJ,GAE7BvB,KAAKgI,aACI1H,EAAasB,QAAQL,KAE9BvB,KAAKiG,IAAI,yBAA0B1E,EAAQP,OACpC,QAAPuG,EAAAvH,KAAKmF,UAAE,IAAAoC,GAAAA,EAAElB,MAAM,IAAM,4BAEzB,CAAE,MAAOrF,GACPhB,KAAKiG,IAAI,wBAAyBjF,GAClCkC,QAAQlC,MAAM,mCAAoCA,EACpD,CACF,CAKQ,gBAAA8G,CAAiBvG,GACvB,MAAMmB,EAAW1C,KAAK0C,SAASH,IAAIhB,EAAQd,QACvCiC,GACF1C,KAAKiG,IAAI,WAAWvD,EAASrC,0BAA0BkB,EAAQd,WAC/DiC,EAASO,QAAQb,IACf,IACEA,KAAYb,EAAQX,WAAa,GACnC,CAAE,MAAOI,GACPkC,QAAQlC,MAAM,mCAAmCO,EAAQd,WAAYO,EACvE,KAGFhB,KAAKiG,IAAI,8BAA8B1E,EAAQd,UAEnD,CAKQ,gBAAAsH,CAAiBxG,GACvB,MAAM0G,EAAUjI,KAAKoF,mBAAmB7C,IAAIhB,EAAQf,cAChDyH,GACF7B,aAAa6B,EAAQvB,SACrB1G,KAAKoF,mBAAmBhC,OAAO7B,EAAQf,cAEnCe,EAAQP,OACVhB,KAAKiG,IAAI,cAAc1E,EAAQf,wBAAwBe,EAAQP,SAC/DiH,EAAQ/D,OAAW7C,MAAME,EAAQP,UAEjChB,KAAKiG,IAAI,cAAc1E,EAAQf,yBAA0Be,EAAQkD,QACjEwD,EAAQhE,QAAQ1C,EAAQkD,UAG1BzE,KAAKiG,IAAI,8CAA8C1E,EAAQf,aAEnE,CAKQ,UAAAwH,SACN,MAAME,EAAc5H,EAAaQ,YAC3B8F,EAAatG,EAAagB,iBAAiB4G,GACjDlI,KAAKiG,IAAI,+BACF,QAAPsB,EAAAvH,KAAKmF,UAAE,IAAAoC,GAAAA,EAAEV,KAAKD,EAChB,CAKQ,WAAAiB,CAAY1F,GAClBnC,KAAKiG,IAAI,4BAA4B9D,EAAMgG,iBAAiBhG,EAAMiG,WAClEpI,KAAKqF,MAAQzF,EAAAA,gBAAgB0F,aAC7BtF,KAAKmF,GAAK,KAGVnF,KAAKoF,mBAAmBnC,QAASgF,IAC/B7B,aAAa6B,EAAQvB,SACrBuB,EAAQ/D,OAAW7C,MAAM,wBAE3BrB,KAAKoF,mBAAmB/B,QAGL,MAAflB,EAAMgG,MAAgC,OAAfhG,EAAMgG,KAC/BnI,KAAKqI,mBAELrI,KAAK8F,aAAa9C,KAAK,eAE3B,CAKc,gBAAAqF,2CACZ,MAAMC,EAAQtI,KAAKyF,gBAAgBtF,eAAeH,KAAKuF,mBAEvD,GAAc,OAAV+C,EAIF,OAFAtI,KAAKiG,IAAI,2CACTjG,KAAK8F,aAAa9C,KAAK,gBAIzBhD,KAAKuF,oBACLvF,KAAKqF,MAAQzF,EAAAA,gBAAgB2I,aAC7BvI,KAAKiG,IAAI,mBAAmBqC,gBAAoBtI,KAAKuF,yBACrDvF,KAAK8F,aAAa9C,KAAK,gBAEvBhD,KAAKwF,mBAAqBmB,WAAW,IAAWhD,EAAA3D,UAAA,OAAA,EAAA,YAC9CA,KAAKwF,mBAAqB,KAC1B,UACQxF,KAAKkG,UACXlG,KAAKiG,IAAI,iBACTjG,KAAK8F,aAAa9C,KAAK,cACzB,CAAE,MAAOhC,GACPhB,KAAKiG,IAAI,sBAAuBjF,GAChChB,KAAKqI,kBACP,CACF,GAAGC,EACL,EAAC,CAKO,iBAAAjB,GAEN,GAAIrH,KAAKiF,IAAIuD,WAAW,UAAYxI,KAAKiF,IAAIuD,WAAW,UACtD,OAAOxI,KAAKiF,IAId,MAAMwD,EAAwC,WAA7BC,OAAOC,SAASF,SAAwB,OAAS,MAKlE,OAJgBzI,KAAKiF,IAAIuD,WAAW,KAChC,GAAGC,MAAaC,OAAOC,SAASC,OAAO5I,KAAKiF,MAC5C,GAAGwD,MAAaC,OAAOC,SAASC,QAAQ5I,KAAKiF,KAGnD,CAKQ,oBAAAwB,GACN,MAAO,MAAGzG,KAAKQ,YACjB,CAKQ,GAAAyF,CAAI1E,EAAiBL,GACvBlB,KAAK0F,oBACMmD,IAAT3H,EACFgC,QAAQ+C,IAAI,aAAa1E,EAAWL,GAEpCgC,QAAQ+C,IAAI,aAAa1E,GAG/B,aC5VqB","x_google_ignoreList":[4]}