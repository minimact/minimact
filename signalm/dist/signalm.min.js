!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).SignalM={})}(this,function(t){"use strict";var e,i;t.ConnectionState=void 0,(e=t.ConnectionState||(t.ConnectionState={})).Disconnected="Disconnected",e.Connecting="Connecting",e.Connected="Connected",e.Reconnecting="Reconnecting",function(t){t[t.Invocation=1]="Invocation",t[t.StreamItem=2]="StreamItem",t[t.Completion=3]="Completion",t[t.StreamInvocation=4]="StreamInvocation",t[t.CancelInvocation=5]="CancelInvocation",t[t.Ping=6]="Ping",t[t.Close=7]="Close"}(i||(i={}));class n{constructor(){this.delays=[0,2e3,1e4,3e4],this.maxDelay=6e4}nextRetryDelay(t){return this.delays.length>t?this.delays[t]:this.maxDelay}}class s{static writeInvocation(t,e,i){return{type:1,invocationId:t,target:e,arguments:i}}static writeMessage(t,e){return{type:1,target:t,arguments:e}}static writePing(){return{type:6}}static writeClose(t){return{type:7,error:t}}static parseMessage(t){try{return JSON.parse(t)}catch(t){throw Error("Failed to parse message: "+t)}}static serializeMessage(t){return JSON.stringify(t)}static isInvocation(t){return 1===t.type}static isCompletion(t){return 3===t.type}static isPing(t){return 6===t.type}static isClose(t){return 7===t.type}}s.protocolName="json",s.protocolVersion=1;class o{constructor(){this.events=new Map}on(t,e){this.events.has(t)||this.events.set(t,[]),this.events.get(t).push(e)}off(t,e){const i=this.events.get(t);if(i){const t=i.indexOf(e);-1!==t&&i.splice(t,1)}}once(t,e){const i=(...n)=>{e(...n),this.off(t,i)};this.on(t,i)}emit(t,...e){const i=this.events.get(t);i&&[...i].forEach(i=>{try{i(...e)}catch(e){console.error(`[SignalM] Error in event handler for '${t}':`,e)}})}removeAllListeners(t){t?this.events.delete(t):this.events.clear()}listenerCount(t){const e=this.events.get(t);return e?e.length:0}eventNames(){return Array.from(this.events.keys())}}function r(t,e,i,n){return new(i||(i=Promise))(function(s,o){function r(t){try{h(n.next(t))}catch(t){o(t)}}function c(t){try{h(n.throw(t))}catch(t){o(t)}}function h(t){var e;t.done?s(t.value):(e=t.value,e instanceof i?e:new i(function(t){t(e)})).then(r,c)}h((n=n.apply(t,e||[])).next())})}"function"==typeof SuppressedError&&SuppressedError,t.CustomRetryPolicy=class{constructor(t,e=!1){if(0===t.length)throw Error("Delays array cannot be empty");this.delays=t,this.repeatLast=e}nextRetryDelay(t){return this.delays.length>t?this.delays[t]:this.repeatLast?this.delays[this.delays.length-1]:null}},t.EventEmitter=o,t.ExponentialBackoffRetryPolicy=n,t.FixedRetryPolicy=class{constructor(t=5e3,e=10){this.interval=t,this.maxRetries=e}nextRetryDelay(t){return this.maxRetries>t?this.interval:null}},t.JsonProtocol=s,t.NoRetryPolicy=class{nextRetryDelay(){return null}},t.SignalMConnection=class{constructor(e,i={}){this.ws=null,this.handlers=new Map,this.pendingInvocations=new Map,this.invocationId=0,this.state=t.ConnectionState.Disconnected,this.reconnectAttempts=0,this.reconnectTimeoutId=null,this.url=e,this.reconnectPolicy=i.reconnectPolicy||new n,this.debugLogging=i.debug||!1,this.connectionTimeout=i.connectionTimeout||3e4,this.invocationTimeout=i.invocationTimeout||3e4,this.eventEmitter=new o}start(){return r(this,void 0,void 0,function*(){if(this.state!==t.ConnectionState.Disconnected)throw Error("Connection is already started");return this.state=t.ConnectionState.Connecting,this.log("Starting connection..."),this.connect()})}stop(){return r(this,void 0,void 0,function*(){this.log("Stopping connection..."),null!==this.reconnectTimeoutId&&(clearTimeout(this.reconnectTimeoutId),this.reconnectTimeoutId=null),this.ws&&(this.ws.close(1e3,"Normal closure"),this.ws=null),this.state=t.ConnectionState.Disconnected,this.eventEmitter.emit("disconnected")})}invoke(e,...i){return r(this,void 0,void 0,function*(){if(this.state!==t.ConnectionState.Connected)throw Error(`Connection is not in Connected state (current: ${this.state})`);const n=this.generateInvocationId(),o=s.writeInvocation(n,e,i);return new Promise((t,r)=>{const c=setTimeout(()=>{this.pendingInvocations.delete(n),r(Error(`Invocation '${e}' timed out after ${this.invocationTimeout}ms`))},this.invocationTimeout);this.pendingInvocations.set(n,{resolve:t,reject:r,timeout:c});const h=s.serializeMessage(o);this.log(`Invoking '${e}' (id: ${n})`,i),this.ws.send(h)})})}send(e,...i){if(this.state!==t.ConnectionState.Connected)throw Error(`Connection is not in Connected state (current: ${this.state})`);const n=s.writeMessage(e,i),o=s.serializeMessage(n);this.log(`Sending '${e}' (fire-and-forget)`,i),this.ws.send(o)}on(t,e){this.handlers.has(t)||this.handlers.set(t,[]),this.handlers.get(t).push(e),this.log(`Registered handler for '${t}'`)}off(t,e){const i=this.handlers.get(t);if(i){const n=i.indexOf(e);-1!==n&&(i.splice(n,1),this.log(`Removed handler for '${t}'`))}}onConnected(t){this.eventEmitter.on("connected",t)}onDisconnected(t){this.eventEmitter.on("disconnected",t)}onReconnecting(t){this.eventEmitter.on("reconnecting",t)}onReconnected(t){this.eventEmitter.on("reconnected",t)}onError(t){this.eventEmitter.on("error",t)}get connectionState(){return this.state}connect(){return r(this,void 0,void 0,function*(){return new Promise((e,i)=>{const n=this.buildWebSocketUrl();this.log(`Connecting to ${n}...`);try{this.ws=new WebSocket(n)}catch(t){return void i(t)}const s=setTimeout(()=>{var e;this.state===t.ConnectionState.Connecting&&(this.log("Connection timeout"),null===(e=this.ws)||void 0===e||e.close(),i(Error(`Connection timeout after ${this.connectionTimeout}ms`)))},this.connectionTimeout);this.ws.onopen=()=>{clearTimeout(s),this.state=t.ConnectionState.Connected,this.reconnectAttempts=0,this.log("Connected ✓"),this.eventEmitter.emit("connected"),e()},this.ws.onmessage=t=>{this.handleMessage(t.data)},this.ws.onerror=t=>{this.log("WebSocket error",t),this.eventEmitter.emit("error",Error("WebSocket error"))},this.ws.onclose=t=>{clearTimeout(s),this.handleClose(t)}})})}handleMessage(t){var e;try{const i=s.parseMessage(t);this.log(`Received message (type: ${i.type})`,i),s.isInvocation(i)?this.handleInvocation(i):s.isCompletion(i)?this.handleCompletion(i):s.isPing(i)?this.handlePing():s.isClose(i)&&(this.log("Server requested close",i.error),null===(e=this.ws)||void 0===e||e.close(1e3,"Server closed connection"))}catch(t){this.log("Error parsing message",t),console.error("[SignalM] Error parsing message:",t)}}handleInvocation(t){const e=this.handlers.get(t.target);e?(this.log(`Calling ${e.length} handler(s) for '${t.target}'`),e.forEach(e=>{try{e(...t.arguments||[])}catch(e){console.error(`[SignalM] Error in handler for '${t.target}':`,e)}})):this.log(`No handler registered for '${t.target}'`)}handleCompletion(t){const e=this.pendingInvocations.get(t.invocationId);e?(clearTimeout(e.timeout),this.pendingInvocations.delete(t.invocationId),t.error?(this.log(`Invocation ${t.invocationId} failed: ${t.error}`),e.reject(Error(t.error))):(this.log(`Invocation ${t.invocationId} completed`,t.result),e.resolve(t.result))):this.log("Received completion for unknown invocation "+t.invocationId)}handlePing(){var t;const e=s.writePing(),i=s.serializeMessage(e);this.log("Received ping, sending pong"),null===(t=this.ws)||void 0===t||t.send(i)}handleClose(e){this.log(`Connection closed (code: ${e.code}, reason: ${e.reason})`),this.state=t.ConnectionState.Disconnected,this.ws=null,this.pendingInvocations.forEach(t=>{clearTimeout(t.timeout),t.reject(Error("Connection closed"))}),this.pendingInvocations.clear(),1e3!==e.code&&1001!==e.code?this.attemptReconnect():this.eventEmitter.emit("disconnected")}attemptReconnect(){return r(this,void 0,void 0,function*(){const e=this.reconnectPolicy.nextRetryDelay(this.reconnectAttempts);if(null===e)return this.log("Max reconnection attempts exceeded"),void this.eventEmitter.emit("disconnected");this.reconnectAttempts++,this.state=t.ConnectionState.Reconnecting,this.log(`Reconnecting in ${e}ms (attempt ${this.reconnectAttempts})...`),this.eventEmitter.emit("reconnecting"),this.reconnectTimeoutId=setTimeout(()=>r(this,void 0,void 0,function*(){this.reconnectTimeoutId=null;try{yield this.connect(),this.log("Reconnected ✓"),this.eventEmitter.emit("reconnected")}catch(t){this.log("Reconnection failed",t),this.attemptReconnect()}}),e)})}buildWebSocketUrl(){if(this.url.startsWith("ws://")||this.url.startsWith("wss://"))return this.url;const t="https:"===window.location.protocol?"wss:":"ws:";return this.url.startsWith("/")?`${t}//${window.location.host}${this.url}`:`${t}//${window.location.host}/${this.url}`}generateInvocationId(){return""+ ++this.invocationId}log(t,e){this.debugLogging&&(void 0!==e?console.log("[SignalM] "+t,e):console.log("[SignalM] "+t))}},t.VERSION="0.1.0"});
//# sourceMappingURL=signalm.min.js.map
