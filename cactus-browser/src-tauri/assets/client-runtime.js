!function(t){var e,n;(t=>{t.Disconnected="Disconnected",t.Connecting="Connecting",t.Connected="Connected",t.Reconnecting="Reconnecting"})(e||(e={})),(t=>{t[t.Invocation=1]="Invocation",t[t.StreamItem=2]="StreamItem",t[t.Completion=3]="Completion",t[t.StreamInvocation=4]="StreamInvocation",t[t.CancelInvocation=5]="CancelInvocation",t[t.Ping=6]="Ping",t[t.Close=7]="Close"})(n||(n={}));class s{constructor(){this.delays=[0,2e3,1e4,3e4],this.maxDelay=6e4}nextRetryDelay(t){return this.delays.length>t?this.delays[t]:this.maxDelay}}class i{static writeHandshake(){return JSON.stringify({protocol:this.protocolName,version:this.protocolVersion})+this.RECORD_SEPARATOR}static parseHandshake(t){try{const e=t.endsWith(this.RECORD_SEPARATOR)?t.slice(0,-1):t;return JSON.parse(e)}catch(t){throw Error("Failed to parse handshake: "+t)}}static writeInvocation(t,e,n){return{type:1,invocationId:t,target:e,arguments:n}}static writeMessage(t,e){return{type:1,target:t,arguments:e}}static writePing(){return{type:6}}static writeClose(t){return{type:7,error:t}}static parseMessage(t){try{const e=t.endsWith(this.RECORD_SEPARATOR)?t.slice(0,-1):t;return JSON.parse(e)}catch(t){throw Error("Failed to parse message: "+t)}}static serializeMessage(t){return JSON.stringify(t)+this.RECORD_SEPARATOR}static isInvocation(t){return 1===t.type}static isCompletion(t){return 3===t.type}static isPing(t){return 6===t.type}static isClose(t){return 7===t.type}}i.protocolName="json",i.protocolVersion=1,i.RECORD_SEPARATOR="";class o{constructor(){this.events=new Map}on(t,e){this.events.has(t)||this.events.set(t,[]),this.events.get(t).push(e)}off(t,e){const n=this.events.get(t);if(n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}once(t,e){const n=(...s)=>{e(...s),this.off(t,n)};this.on(t,n)}emit(t,...e){const n=this.events.get(t);n&&[...n].forEach(t=>{try{t(...e)}catch(t){}})}removeAllListeners(t){t?this.events.delete(t):this.events.clear()}listenerCount(t){const e=this.events.get(t);return e?e.length:0}eventNames(){return Array.from(this.events.keys())}}class r{constructor(t,n={}){this.ws=null,this.handlers=new Map,this.pendingInvocations=new Map,this.invocationId=0,this.state=e.Disconnected,this.reconnectAttempts=0,this.reconnectTimeoutId=null,this.url=t,this.reconnectPolicy=n.reconnectPolicy||new s,this.debugLogging=n.debug||0,this.connectionTimeout=n.connectionTimeout||3e4,this.invocationTimeout=n.invocationTimeout||3e4,this.eventEmitter=new o}async start(){if(this.state!==e.Disconnected)throw Error("Connection is already started");return this.state=e.Connecting,this.log("Starting connection..."),this.connect()}async stop(){this.log("Stopping connection..."),null!==this.reconnectTimeoutId&&(clearTimeout(this.reconnectTimeoutId),this.reconnectTimeoutId=null),this.ws&&(this.ws.close(1e3,"Normal closure"),this.ws=null),this.state=e.Disconnected,this.eventEmitter.emit("disconnected")}async invoke(t,...n){if(this.state!==e.Connected)throw Error(`Connection is not in Connected state (current: ${this.state})`);const s=this.generateInvocationId(),o=i.writeInvocation(s,t,n);return new Promise((e,r)=>{const a=setTimeout(()=>{this.pendingInvocations.delete(s),r(Error(`Invocation '${t}' timed out after ${this.invocationTimeout}ms`))},this.invocationTimeout);this.pendingInvocations.set(s,{resolve:e,reject:r,timeout:a});const c=i.serializeMessage(o);this.log(`Invoking '${t}' (id: ${s})`,n),this.ws.send(c)})}send(t,...n){if(this.state!==e.Connected)throw Error(`Connection is not in Connected state (current: ${this.state})`);const s=i.writeMessage(t,n),o=i.serializeMessage(s);this.log(`Sending '${t}' (fire-and-forget)`,n),this.ws.send(o)}on(t,e){this.handlers.has(t)||this.handlers.set(t,[]),this.handlers.get(t).push(e),this.log(`Registered handler for '${t}'`)}off(t,e){const n=this.handlers.get(t);if(n){const s=n.indexOf(e);-1!==s&&(n.splice(s,1),this.log(`Removed handler for '${t}'`))}}onConnected(t){this.eventEmitter.on("connected",t)}onDisconnected(t){this.eventEmitter.on("disconnected",t)}onReconnecting(t){this.eventEmitter.on("reconnecting",t)}onReconnected(t){this.eventEmitter.on("reconnected",t)}onError(t){this.eventEmitter.on("error",t)}get connectionState(){return this.state}async connect(){return new Promise((t,n)=>{const s=this.buildWebSocketUrl();this.log(`Connecting to ${s}...`);try{this.ws=new WebSocket(s)}catch(t){return void n(t)}const o=setTimeout(()=>{this.state===e.Connecting&&(this.log("Connection timeout"),this.ws?.close(),n(Error(`Connection timeout after ${this.connectionTimeout}ms`)))},this.connectionTimeout);let r=0;this.ws.onopen=()=>{const t=i.writeHandshake();this.log("Sending handshake",t),this.ws.send(t)},this.ws.onmessage=s=>{if(r)this.handleMessage(s.data);else try{const a=i.parseHandshake(s.data);if(a.error)return clearTimeout(o),this.log("Handshake failed",a.error),this.ws?.close(),void n(Error("Handshake failed: "+a.error));r=1,clearTimeout(o),this.state=e.Connected,this.reconnectAttempts=0,this.log("Handshake complete âœ“"),this.log("Connected âœ“"),this.eventEmitter.emit("connected"),t()}catch(t){clearTimeout(o),this.log("Handshake parse error",t),this.ws?.close(),n(Error("Handshake error: "+t))}},this.ws.onerror=t=>{this.log("WebSocket error",t),this.eventEmitter.emit("error",Error("WebSocket error"))},this.ws.onclose=t=>{clearTimeout(o),this.handleClose(t)}})}handleMessage(t){const e=t.split("").filter(t=>t.length>0);for(const t of e)try{const e=JSON.parse(t);this.log(`Received message (type: ${e.type})`,e),i.isInvocation(e)?this.handleInvocation(e):i.isCompletion(e)?this.handleCompletion(e):i.isPing(e)?this.handlePing():i.isClose(e)&&(this.log("Server requested close",e.error),this.ws?.close(1e3,"Server closed connection"))}catch(t){this.log("Error parsing message",t)}}handleInvocation(t){const e=this.handlers.get(t.target);e?(this.log(`Calling ${e.length} handler(s) for '${t.target}'`),e.forEach(e=>{try{e(...t.arguments||[])}catch(t){}})):this.log(`No handler registered for '${t.target}'`)}handleCompletion(t){const e=this.pendingInvocations.get(t.invocationId);e?(clearTimeout(e.timeout),this.pendingInvocations.delete(t.invocationId),t.error?(this.log(`Invocation ${t.invocationId} failed: ${t.error}`),e.reject(Error(t.error))):(this.log(`Invocation ${t.invocationId} completed`,t.result),e.resolve(t.result))):this.log("Received completion for unknown invocation "+t.invocationId)}handlePing(){const t=i.writePing(),e=i.serializeMessage(t);this.log("Received ping, sending pong"),this.ws?.send(e)}handleClose(t){this.log(`Connection closed (code: ${t.code}, reason: ${t.reason})`),this.state=e.Disconnected,this.ws=null,this.pendingInvocations.forEach(t=>{clearTimeout(t.timeout),t.reject(Error("Connection closed"))}),this.pendingInvocations.clear(),1e3!==t.code&&1001!==t.code?this.attemptReconnect():this.eventEmitter.emit("disconnected")}async attemptReconnect(){const t=this.reconnectPolicy.nextRetryDelay(this.reconnectAttempts);if(null===t)return this.log("Max reconnection attempts exceeded"),void this.eventEmitter.emit("disconnected");this.reconnectAttempts++,this.state=e.Reconnecting,this.log(`Reconnecting in ${t}ms (attempt ${this.reconnectAttempts})...`),this.eventEmitter.emit("reconnecting"),this.reconnectTimeoutId=setTimeout(async()=>{this.reconnectTimeoutId=null;try{await this.connect(),this.log("Reconnected âœ“"),this.eventEmitter.emit("reconnected")}catch(t){this.log("Reconnection failed",t),this.attemptReconnect()}},t)}buildWebSocketUrl(){if(this.url.startsWith("ws://")||this.url.startsWith("wss://"))return this.url;const t="https:"===window.location.protocol?"wss:":"ws:";return this.url.startsWith("/")?`${t}//${window.location.host}${this.url}`:`${t}//${window.location.host}/${this.url}`}generateInvocationId(){return""+ ++this.invocationId}log(t,e){}}class a{constructor(t,e){this.connection=new r(t,e||{})}async connect(){await this.connection.start()}async disconnect(){await this.connection.stop()}isConnected(){return"Connected"===this.connection.connectionState}async send(t,...e){return await this.connection.invoke(t,...e)}on(t,e){this.connection.on(t,e)}off(t,e){this.connection.off(t,e)}onReconnecting(t){this.connection.onReconnecting(t)}onReconnected(t){this.connection.onReconnected(t)}onClose(t){this.connection.onDisconnected(t)}onConnected(t){this.connection.onConnected(t)}getConnection(){return this.connection}}class c{constructor(t,e={}){this.transport=t,this.debugLogging=e.debugLogging||0,this.eventHandlers=new Map,this.setupEventHandlers()}static createDefault(t="/minimact",e={}){return new c(new a(t,{debug:e.debugLogging}),e)}static createWebTransport(t,e={}){return new c(new a(t,{debug:e.debugLogging}),e)}static createAuto(t,e={}){if("undefined"!=typeof window&&window.__TAURI__){if(!e.tauriTransport)throw Error("[SignalMÂ²] Tauri environment detected but no TauriTransport provided. Import TauriTransport and pass it via options.tauriTransport");return new c(new e.tauriTransport,e)}return c.createWebTransport(t||"/minimact",e)}setupEventHandlers(){this.transport.on("UpdateComponent",(t,e)=>{this.log("UpdateComponent",{componentId:t,html:e}),this.emit("updateComponent",{componentId:t,html:e})}),this.transport.on("ApplyPatches",(t,e)=>{this.log("ApplyPatches",{componentId:t,patches:e}),this.emit("applyPatches",{componentId:t,patches:e})}),this.transport.on("ApplyPrediction",t=>{this.log(`ApplyPrediction (${(100*t.confidence).toFixed(0)}% confident)`,{componentId:t.componentId,patches:t.patches}),this.emit("applyPrediction",{componentId:t.componentId,patches:t.patches,confidence:t.confidence})}),this.transport.on("ApplyCorrection",t=>{this.log("ApplyCorrection (prediction was incorrect)",{componentId:t.componentId,patches:t.patches}),this.emit("applyCorrection",{componentId:t.componentId,patches:t.patches})}),this.transport.on("QueueHint",t=>{this.log(`QueueHint '${t.hintId}' (${(100*t.confidence).toFixed(0)}% confident)`,{componentId:t.componentId,patches:t.patches}),this.emit("queueHint",t)}),this.transport.on("Error",t=>{this.emit("error",{message:t})}),this.transport.on("HotReload:TemplateMap",t=>{this.log("HotReload:TemplateMap",t),this.emit("HotReload:TemplateMap",t)}),this.transport.on("HotReload:TemplatePatch",t=>{this.log("HotReload:TemplatePatch",t),this.emit("HotReload:TemplatePatch",t)}),this.transport.on("HotReload:FileChange",t=>{this.log("HotReload:FileChange",t),this.emit("HotReload:FileChange",t)}),this.transport.on("HotReload:Error",t=>{this.emit("HotReload:Error",t)}),this.transport.onReconnecting&&this.transport.onReconnecting(()=>{this.log("Reconnecting..."),this.emit("reconnecting",{})}),this.transport.onReconnected&&this.transport.onReconnected(()=>{this.log("Reconnected"),this.emit("reconnected",{connectionId:null})}),this.transport.onClose&&this.transport.onClose(()=>{this.log("Connection closed"),this.emit("closed",{})}),this.transport.onConnected&&this.transport.onConnected(()=>{this.log("Connected to Minimact hub"),this.emit("connected",{connectionId:null})})}async start(){try{await this.transport.connect()}catch(t){throw t}}async stop(){await this.transport.disconnect(),this.log("Disconnected from Minimact hub")}async registerComponent(t){try{await this.transport.send("RegisterComponent",t),this.log("Registered component",{componentId:t})}catch(t){throw t}}async invokeComponentMethod(t,e,n={}){try{const s=JSON.stringify(n);await this.transport.send("InvokeComponentMethod",t,e,s),this.log("Invoked method",{componentId:t,methodName:e,args:n})}catch(t){throw t}}async updateClientState(t,e,n){try{const s=JSON.stringify(n);await this.transport.send("UpdateClientState",t,e,s),this.log("Updated client state",{componentId:t,key:e,value:n})}catch(t){}}async updateClientComputedState(t,e){try{await this.transport.send("UpdateClientComputedState",t,e),this.log("Updated client-computed state",{componentId:t,computedValues:e})}catch(t){throw t}}async updateComponentState(t,e,n){try{await this.transport.send("UpdateComponentState",t,e,n),this.log("Updated component state",{componentId:t,stateKey:e,value:n})}catch(t){throw t}}async updateDomElementState(t,e,n){try{await this.transport.send("UpdateDomElementState",t,e,n),this.log("Updated DOM element state",{componentId:t,stateKey:e,snapshot:n})}catch(t){throw t}}async updateComponentStateWithOperation(t,e,n,s){try{await this.transport.send("UpdateComponentStateWithOperation",t,e,n,s),this.log("Updated component state with operation",{componentId:t,stateKey:e,operation:s,newValue:n})}catch(t){throw t}}async updateQueryResults(t,e,n){try{await this.transport.send("UpdateQueryResults",t,e,n),this.log("Updated query results",{componentId:t,queryKey:e,resultCount:n.length})}catch(t){throw t}}async invoke(t,...e){try{await this.transport.send(t,...e),this.log("Invoked "+t,{args:e})}catch(t){throw t}}async debug(t,e,n){}on(t,e){this.eventHandlers.has(t)||this.eventHandlers.set(t,new Set),this.eventHandlers.get(t).add(e)}off(t,e){const n=this.eventHandlers.get(t);n&&n.delete(e)}emit(t,e){const n=this.eventHandlers.get(t);n&&n.forEach(t=>t(e))}log(t,e){}get state(){return this.transport.isConnected()?"Connected":"Disconnected"}get connectionId(){return null}}class h{constructor(t={}){this.debugLogging=t.debugLogging||0,this.signalR=t.signalR}applyPatches(t,e){this.log("Applying patches",{count:e.length,patches:e});for(const n of e)try{this.applyPatch(t,n)}catch(t){this.signalR?.debug("patches","Failed to apply patch",{patch:n,error:t instanceof Error?t.message:t+"",stack:t instanceof Error?t.stack:void 0})}}applyPatch(t,e){const n=this.getElementByPath(t,e.path);if(n||"Create"===e.type)switch(e.type){case"Create":this.patchCreate(t,e.path,e.node);break;case"Remove":this.patchRemove(n);break;case"Replace":this.patchReplace(n,e.node);break;case"UpdateText":this.patchUpdateText(n,e.content);break;case"UpdateProps":this.patchUpdateProps(n,e.props);break;case"ReorderChildren":this.patchReorderChildren(n,e.order)}else this.signalR?.debug("patches","Target element not found",{patchType:e.type,path:e.path,patch:e})}patchCreate(t,e,n){const s=this.createElementFromVNode(n),i=n.path;if(!i)return;const o=i.split(".").map(t=>parseInt(t,10));if(0===o.length)return;if(1===o.length&&0===o[0])return t.innerHTML="",t.appendChild(s),void this.log("Created root node",{node:n});const r=o.slice(0,-1),a=o[o.length-1],c=this.getElementByPath(t,r);c&&(c.childNodes.length>a?c.insertBefore(s,c.childNodes[a]):c.appendChild(s),this.log("Created node",{path:i,node:n}))}patchRemove(t){t.parentNode&&(t.parentNode.removeChild(t),this.log("Removed node",{element:t}))}patchReplace(t,e){const n=this.createElementFromVNode(e);t.parentNode&&(t.parentNode.replaceChild(n,t),this.log("Replaced node",{oldElement:t,newNode:e}))}patchUpdateText(t,e){t.textContent=(Node,e),this.log("Updated text",{element:t,content:e})}patchUpdateProps(t,e){const n=Array.from(t.attributes);for(const s of n)s.name in e||s.name.startsWith("data-minimact-")||t.removeAttribute(s.name);for(const[n,s]of Object.entries(e))if("style"===n)t.setAttribute("style",s);else if("class"===n||"className"===n)t.className=s;else{if(n.startsWith("on"))continue;t.setAttribute(n,s)}this.log("Updated props",{element:t,props:e})}patchReorderChildren(t,e){const n=new Map;for(const e of Array.from(t.childNodes))if(e instanceof HTMLElement){const t=e.getAttribute("data-key")||e.getAttribute("key");t&&n.set(t,e)}for(let s=0;e.length>s;s++){const i=n.get(e[s]);if(i){const e=t.childNodes[s];e!==i&&t.insertBefore(i,e)}}this.log("Reordered children",{element:t,order:e})}getElementByPath(t,e){if(!e||Array.isArray(e)&&0===e.length)return t;const n=Array.isArray(e)?e:[];let s=t;for(const t of n){if(t>=s.childNodes.length)return null;s=s.childNodes[t]}return s}createElementFromVNode(t){switch(t.type){case"Text":return document.createTextNode(t.content);case"Element":{const e=t,n=document.createElement(e.tag);for(const[t,s]of Object.entries(e.props||{}))"className"===t||"class"===t?n.className=s:t.startsWith("on")?n.setAttribute("data-"+t.toLowerCase(),s):n.setAttribute(t,s);e.key&&n.setAttribute("data-key",e.key);for(const t of e.children||[])n.appendChild(this.createElementFromVNode(t));return n}case"Fragment":{const e=document.createDocumentFragment(),n=t;for(const t of n.children||[])e.appendChild(this.createElementFromVNode(t));return e}case"RawHtml":{const e=document.createElement("div");return e.innerHTML=t.html,e}default:return document.createTextNode("")}}replaceHTML(t,e){t.innerHTML=e,this.log("Replaced entire HTML",{html:e})}log(t,e){this.signalR?.debug("dom-patcher",t,e)}}class d{constructor(t={}){this.states=new Map,this.subscribers=new Map,this.debugLogging=t.debugLogging||0}initializeComponent(t,e={}){this.states.set(t,{...e}),this.subscribers.set(t,new Map),this.log("Initialized component state",{componentId:t,initialState:e})}getState(t,e){const n=this.states.get(t);return n?n[e]:void 0}setState(t,e,n){const s=this.states.get(t);if(!s)return;const i=s[e];s[e]=n,this.log("State updated",{componentId:t,key:e,oldValue:i,newValue:n}),this.notifySubscribers(t,e,n,i)}subscribe(t,e,n){const s=this.subscribers.get(t);return s?(s.has(e)||s.set(e,new Set),s.get(e).add(n),this.log("Subscribed to state",{componentId:t,key:e}),()=>{s.get(e)?.delete(n),this.log("Unsubscribed from state",{componentId:t,key:e})}):()=>{}}notifySubscribers(t,e,n,s){const i=this.subscribers.get(t);if(!i)return;const o=i.get(e);o&&o.forEach(t=>{try{t(n,s)}catch(t){}})}getComponentState(t){return this.states.get(t)}updateState(t,e){for(const[n,s]of Object.entries(e))this.setState(t,n,s)}clearComponent(t){this.states.delete(t),this.subscribers.delete(t),this.log("Cleared component state",{componentId:t})}bindToElement(t,e,n,s="textContent"){const i=this.getState(t,e);return void 0!==i&&this.updateElement(n,s,i),this.subscribe(t,e,t=>{this.updateElement(n,s,t)})}updateElement(t,e,n){switch(e){case"value":(t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement||t instanceof HTMLSelectElement)&&(t.value=n+"");break;case"textContent":t.textContent=n+"";break;case"innerHTML":t.innerHTML=n+""}}bindInput(t,e,n){const s=this.getState(t,e);void 0!==s&&(n.value=s+"");const i=n=>{this.setState(t,e,n.target.value)};n.addEventListener("input",i);const o=this.subscribe(t,e,t=>{n.value!==t+""&&(n.value=t+"")});return()=>{n.removeEventListener("input",i),o()}}log(t,e){}}class l{constructor(t,e,n={}){this.rootElement=t,this.componentMethodInvoker=e,this.debugLogging=n.debugLogging||0,this.hintQueue=n.hintQueue,this.domPatcher=n.domPatcher,this.playgroundBridge=n.playgroundBridge,this.signalR=n.signalR,this.eventListeners=new Map,this.setupEventDelegation()}setupEventDelegation(){const t=["click","dblclick","input","change","submit","focus","blur","keydown","keyup","keypress","mouseenter","mouseleave","mouseover","mouseout"];for(const e of t){const t=this.createEventListener(e);this.eventListeners.set(e,t),this.rootElement.addEventListener(e,t,1)}this.log("Event delegation setup complete",{eventTypes:t})}createEventListener(t){return async e=>{const n=e.target,s=this.findHandlerElement(n,t);if(!s)return;const i=this.getEventHandler(s,t);i&&("submit"===t&&e.preventDefault(),this.log("Event triggered",{eventType:t,handler:i,target:n}),await this.executeHandler(i,e,s))}}findHandlerElement(t,e){let n=t;for(;n&&n!==this.rootElement;){const t="on"+e;if(n.hasAttribute("data-on"+e)||n.hasAttribute(t))return n;n=n.parentElement}return null}getEventHandler(t,e){const n="on"+e,s=t.getAttribute("data-on"+e)||t.getAttribute(n);if(!s)return null;const i=s.split(":"),o=i[0],r=i.slice(1),a=this.findComponentId(t);return a?{componentId:a,methodName:o,args:r}:null}findComponentId(t){let e=t;for(;e&&e!==this.rootElement;){const t=e.getAttribute("data-minimact-component-id");if(t)return t;e=e.parentElement}return this.rootElement.getAttribute("data-minimact-component-id")}async executeHandler(t,e,n){const s=performance.now();try{const n={};t.args.length>0&&(n.args=t.args.map(t=>{try{return JSON.parse(t)}catch{return t}})),e instanceof MouseEvent&&(n.mouse={clientX:e.clientX,clientY:e.clientY,button:e.button}),e instanceof KeyboardEvent&&(n.keyboard={key:e.key,code:e.code,ctrlKey:e.ctrlKey,shiftKey:e.shiftKey,altKey:e.altKey}),("input"===e.type||"change"===e.type)&&(n.value=e.target.value);const i=[];if(void 0!==n.value&&i.push(n.value),n.args&&Array.isArray(n.args)&&i.push(...n.args),this.hintQueue&&this.domPatcher){const e=this.tryMatchHint(t.componentId,t.methodName);if(e){const n=this.findComponentElement(t.componentId);if(n){this.domPatcher.applyPatches(n,e.patches);const o=performance.now()-s;return this.playgroundBridge&&this.playgroundBridge.cacheHit({componentId:t.componentId,hintId:e.hintId,latency:o,confidence:e.confidence,patchCount:e.patches.length}),this.log(`ðŸŸ¢ CACHE HIT! Applied ${e.patches.length} patches in ${o.toFixed(2)}ms`,{handler:t,confidence:(100*e.confidence).toFixed(0)+"%"}),void this.componentMethodInvoker(t.componentId,t.methodName,i).catch(t=>{})}}}await this.componentMethodInvoker(t.componentId,t.methodName,i);const o=performance.now()-s;this.playgroundBridge&&this.playgroundBridge.cacheMiss({componentId:t.componentId,methodName:t.methodName,latency:o,patchCount:0}),this.log(`ðŸ”´ CACHE MISS - Server latency: ${o.toFixed(2)}ms`,{handler:t,argsObj:n})}catch(t){}}tryMatchHint(t,e){return null}findComponentElement(t){return this.rootElement.querySelector(`[data-minimact-component-id="${t}"]`)}destroy(){for(const[t,e]of this.eventListeners.entries())this.rootElement.removeEventListener(t,e,1);this.eventListeners.clear(),this.log("Event delegation destroyed")}log(t,e){this.signalR?.debug("event-delegation",t,e)}}class p{constructor(t,e={}){this.clientState=t,this.components=new Map,this.debugLogging=e.debugLogging||0}hydrateComponent(t,e,n){if(this.log("Hydrating component",{componentId:t,componentType:n}),!e.firstElementChild)return;const s={componentId:t,type:n,element:e,clientState:{},serverState:{}};this.components.set(t,s),e.setAttribute("data-minimact-component-id",t),this.clientState.initializeComponent(t),this.hydrateClientZones(t,e),this.bindStateElements(t,e),this.log("Component hydrated",{componentId:t,metadata:s})}hydrateClientZones(t,e){const n=e.querySelectorAll("[data-minimact-client-scope]");this.log("Found client zones",{count:n.length}),n.forEach(e=>{const n=e,s=n.getAttribute("data-state");if(s){const e=this.getInitialValue(n);this.clientState.setState(t,s,e),(n instanceof HTMLInputElement||n instanceof HTMLTextAreaElement||n instanceof HTMLSelectElement)&&this.clientState.bindInput(t,s,n),this.log("Hydrated client zone",{element:n,stateName:s,initialValue:e})}})}bindStateElements(t,e){const n=e.querySelectorAll("[data-bind]");this.log("Found bound elements",{count:n.length}),n.forEach(e=>{const n=e,s=n.getAttribute("data-bind");if(!s)return;const i=this.isInClientScope(n),o=this.determineBindProperty(n);i?(this.clientState.bindToElement(t,s,n,o),this.log("Bound to client state",{element:n,bindKey:s,bindProperty:o})):this.log("Server-bound element (patch-controlled)",{element:n,bindKey:s})})}isInClientScope(t){let e=t;for(;e;){if(e.hasAttribute("data-minimact-client-scope"))return 1;if(e.hasAttribute("data-minimact-server-scope"))return 0;e=e.parentElement}return 0}determineBindProperty(t){return t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement||t instanceof HTMLSelectElement?"value":t.hasAttribute("data-bind-html")?"innerHTML":"textContent"}getInitialValue(t){return t instanceof HTMLInputElement?"checkbox"===t.type?t.checked:"number"===t.type?t.valueAsNumber||0:t.value:t instanceof HTMLTextAreaElement||t instanceof HTMLSelectElement?t.value:t.textContent||""}dehydrateComponent(t){this.components.get(t)&&(this.clientState.clearComponent(t),this.components.delete(t),this.log("Component dehydrated",{componentId:t}))}getComponent(t){return this.components.get(t)}updateServerState(t,e,n){const s=this.components.get(t);s&&(s.serverState[e]=n,this.log("Updated server state",{componentId:t,key:e,value:n}))}hydrateAll(){const t=document.querySelectorAll("[data-minimact-component]");this.log("Hydrating all components",{count:t.length}),t.forEach(t=>{const e=t.getAttribute("data-minimact-component");e&&this.hydrateComponent(e,t)})}log(t,e){}}class u{static renderTemplate(t,e){let n=t;return e.forEach((t,e)=>{const s=`{${e}}`,i=this.formatValue(t);n=n.replace(s,i)}),n}static renderTemplatePatch(t,e){if(t.conditionalTemplates&&void 0!==t.conditionalBindingIndex){const n=t.bindings[t.conditionalBindingIndex],s=t.conditionalTemplates[e["object"==typeof n&&"stateKey"in n?n.stateKey:n]+""];if(void 0!==s){if(!s.includes("{"))return s;const n=t.bindings.map(t=>{if("object"==typeof t&&"stateKey"in t){const n=e[t.stateKey];return t.transform?this.applyTransform(n,t.transform):n}return e[t]});return this.renderTemplate(s,n)}}const n=t.bindings.map((t,n)=>{if("object"==typeof t&&"stateKey"in t){const n=e[t.stateKey];return t.transform?this.applyTransform(n,t.transform):n}return e[t]});return this.renderTemplate(t.template,n)}static materializePatch(t,e){switch(t.type){case"UpdateTextTemplate":{const n=this.renderTemplatePatch(t.templatePatch,e);return{type:"UpdateText",path:t.path,content:n}}case"UpdatePropsTemplate":{const n=this.renderTemplatePatch(t.templatePatch,e);return{type:"UpdateProps",path:t.path,props:{[t.propName]:n}}}case"UpdateListTemplate":{const n=this.renderLoopTemplate(t.loopTemplate,e);return this.convertLoopToPatches(t.path,n)}case"UpdateAttributeStatic":return{type:"UpdateProps",path:t.path,props:{[t.attrName]:t.value}};case"UpdateAttributeDynamic":{const n=this.renderTemplatePatch(t.templatePatch,e);return{type:"UpdateProps",path:t.path,props:{[t.attrName]:n}}}default:return t}}static materializePatches(t,e){const n=[];for(const s of t){const t=this.materializePatch(s,e);Array.isArray(t)?n.push(...t):n.push(t)}return n}static applyTransform(t,e){if(e.startsWith("toFixed(")){const n=parseInt(e.match(/\d+/)?.[0]||"0");return(+t).toFixed(n)}return e.startsWith("* ")?+t*parseFloat(e.substring(2)):e.startsWith("/ ")?+t/parseFloat(e.substring(2)):e.startsWith("+ ")?+t+parseFloat(e.substring(2)):e.startsWith("- ")?+t-parseFloat(e.substring(2)):"toUpperCase()"===e||"toUpperCase"===e?(t+"").toUpperCase():"toLowerCase()"===e||"toLowerCase"===e?(t+"").toLowerCase():"trim()"===e||"trim"===e?(t+"").trim():"!"===e?!t:t}static formatValue(t){return null==t?"":"string"==typeof t?t:"number"==typeof t||"boolean"==typeof t?t+"":Array.isArray(t)?t.map(t=>this.formatValue(t)).join(", "):"object"==typeof t?JSON.stringify(t):t+""}static isTemplatePatch(t){return"UpdateTextTemplate"===t.type||"UpdatePropsTemplate"===t.type||"UpdateListTemplate"===t.type||"UpdateAttributeStatic"===t.type||"UpdateAttributeDynamic"===t.type}static extractBindings(t){return"UpdateTextTemplate"===t.type||"UpdatePropsTemplate"===t.type||"UpdateAttributeDynamic"===t.type?t.templatePatch.bindings.map(t=>"object"==typeof t&&"stateKey"in t?t.stateKey:t):[]}static validateBindings(t,e){return t.bindings.every(t=>("object"==typeof t&&"stateKey"in t?t.stateKey:t)in e)}static getMissingBindings(t,e){return t.bindings.filter(t=>!(("object"==typeof t&&"stateKey"in t?t.stateKey:t)in e)).map(t=>"object"==typeof t&&"stateKey"in t?t.stateKey:t)}static renderLoopTemplate(t,e){const n=e[t.array_binding];return Array.isArray(n)?n.map((n,s)=>{const i={...e,item:n,index:s,...t.index_var?{[t.index_var]:s}:{}},o=this.flattenItemState(i,n);return this.renderItemTemplate(t.item_template,o)}):[]}static flattenItemState(t,e){const n={...t};if("object"==typeof e&&null!==e&&!Array.isArray(e))for(const t in e)n["item."+t]=e[t];return n}static renderItemTemplate(t,e){switch(t.type){case"Text":return{type:"Text",content:this.renderTemplatePatch(t.template_patch,e)};case"Element":{const n={};if(t.props_templates)for(const[s,i]of Object.entries(t.props_templates))n[s]=this.renderTemplatePatch(i,e);const s=(t.children_templates||[]).map(t=>this.renderItemTemplate(t,e));return{type:"Element",tag:t.tag,props:n,children:s,key:t.key_binding?e[t.key_binding]+"":void 0}}default:throw Error("Unknown item template type: "+t.type)}}static convertLoopToPatches(t,e){return e.map((e,n)=>{const s=n.toString(16).padStart(8,"0");return{type:"Create",path:t?`${t}.${s}`:s,node:e}})}}class m{constructor(t={}){this.hints=new Map,this.maxHintAge=5e3,this.debugLogging=t.debugLogging||0}queueHint(t){const e=`${t.componentId}:${t.hintId}`,n=t.patches.some(t=>u.isTemplatePatch(t));this.hints.set(e,{...t,queuedAt:Date.now(),isTemplate:n}),this.log(`${n?"ðŸ“ TEMPLATE":"ðŸ“„ CONCRETE"} hint '${t.hintId}' queued for ${t.componentId}`,t),this.cleanupStaleHints()}matchHint(t,e){const n=Array.from(this.hints.entries()).filter(([e])=>e.startsWith(t+":")).map(([,t])=>t);for(const s of n)if(this.stateMatches(s.predictedState,e)){this.log(`${s.isTemplate?"ðŸ“ TEMPLATE":"ðŸ“„ CONCRETE"} hint '${s.hintId}' matched!`,{hint:s,stateChanges:e}),this.hints.delete(`${t}:${s.hintId}`);const n=u.materializePatches(s.patches,e);return{hintId:s.hintId,patches:n,confidence:s.confidence}}return null}stateMatches(t,e){for(const[n,s]of Object.entries(t)){if(!(n in e))return 0;if(JSON.stringify(e[n])!==JSON.stringify(s))return 0}return 1}cleanupStaleHints(){const t=Date.now(),e=[];for(const[n,s]of this.hints.entries())t-s.queuedAt>this.maxHintAge&&e.push(n);if(e.length>0){this.log(`Removing ${e.length} stale hint(s)`,e);for(const t of e)this.hints.delete(t)}}clearComponent(t){const e=Array.from(this.hints.keys()).filter(e=>e.startsWith(t+":"));for(const t of e)this.hints.delete(t);e.length>0&&this.log(`Cleared ${e.length} hint(s) for component ${t}`)}clearAll(){this.hints.clear(),this.log("Cleared all hints")}getStats(){const t=Array.from(this.hints.values()),e=t.filter(t=>t.isTemplate),n=t.filter(t=>!t.isTemplate);return{totalHints:this.hints.size,templateHints:e.length,concreteHints:n.length,templatePercentage:this.hints.size>0?Math.round(e.length/this.hints.size*100):0,hintsByComponent:t.reduce((t,e)=>(t[e.componentId]=(t[e.componentId]||0)+1,t),{})}}log(t,...e){}}class f{constructor(){this.typeToInstances=new Map,this.instanceToMeta=new Map}register(t){const{type:e,instanceId:n}=t;this.instanceToMeta.set(n,t),this.typeToInstances.has(e)||this.typeToInstances.set(e,new Set),this.typeToInstances.get(e).add(t)}unregister(t){const e=this.instanceToMeta.get(t);if(!e)return;this.instanceToMeta.delete(t);const n=this.typeToInstances.get(e.type);n&&(n.delete(e),0===n.size&&this.typeToInstances.delete(e.type))}getByType(t){const e=this.typeToInstances.get(t);return e?Array.from(e):[]}getByInstanceId(t){return this.instanceToMeta.get(t)}getTypes(){return Array.from(this.typeToInstances.keys())}getInstanceCount(){return this.instanceToMeta.size}getStats(){const t={};for(const[e,n]of this.typeToInstances.entries())t[e]=n.size;return{types:this.typeToInstances.size,instances:this.instanceToMeta.size,typeBreakdown:t}}clear(){this.typeToInstances.clear(),this.instanceToMeta.clear()}}class y{constructor(){this.renderedElements=new Map}registerRenderedElement(t,e){this.renderedElements.set(t,e)}unregisterRenderedElement(t){this.renderedElements.delete(t)}getRenderedElement(t){return this.renderedElements.get(t)}evaluateCondition(t,e,n){try{const s={};if(e)for(const[t,i]of Object.entries(e))s[t]=this.resolveBinding(n,i);return this.evaluateSafeExpression(t,s)}catch(t){return 0}}resolveBinding(t,e){const n=e.split(".");let s=t;for(const t of n){if(null==s)return;s=s[t]}return s}evaluateSafeExpression(t,e){const n=t.trim();if(n.startsWith("!")&&!n.includes(" ")){const t=n.slice(1);return!e[t]}if(n.includes("&&"))return n.split("&&").map(t=>t.trim()).every(t=>this.evaluateSafeExpression(t,e));if(n.includes("||"))return n.split("||").map(t=>t.trim()).some(t=>this.evaluateSafeExpression(t,e));const s=["===","!==","==","!=","<=",">=","<",">"];for(const t of s)if(n.includes(t)){const[s,i]=n.split(t).map(t=>t.trim()),o=this.resolveValue(s,e),r=this.resolveValue(i,e);switch(t){case"===":return o===r;case"!==":return o!==r;case"==":return o==r;case"!=":return o!=r;case"<":return r>o;case">":return o>r;case"<=":return r>=o;case">=":return o>=r}}return e.hasOwnProperty(n)?!!e[n]:0}resolveValue(t,e){return t.startsWith('"')||t.startsWith("'")?t.slice(1,-1):/^-?\d+(\.\d+)?$/.test(t)?parseFloat(t):"true"===t?1:"false"===t?0:"null"===t?null:"undefined"!==t&&e.hasOwnProperty(t)?e[t]:void 0}buildElement(t,e){if("fragment"===t.type){const n=document.createDocumentFragment();for(const s of t.children||[])n.appendChild("tag"in s||"fragment"===s.type||"element"===s.type?this.buildElement(s,e):this.buildTextNode(s,e));return n}const n=document.createElement(t.tag);if(t.attributes)for(const[s,i]of Object.entries(t.attributes))if("string"==typeof i)n.setAttribute(s,i);else if(i&&"object"==typeof i&&"binding"in i){const t=this.resolveBinding(e,i.binding);null!=t&&n.setAttribute(s,t+"")}if(t.children)for(const s of t.children)n.appendChild("tag"in s||"fragment"===s.type||"element"===s.type?this.buildElement(s,e):this.buildTextNode(s,e));return n}buildTextNode(t,e){if(void 0!==t.value)return document.createTextNode(t.value);if(t.binding){const n=this.resolveBinding(e,t.binding);return document.createTextNode(null!=n?n+"":"")}return document.createTextNode("")}render(t,e,n,s,i){const o=e.evaluable?this.evaluateCondition(e.conditionExpression,e.conditionMapping,n):0;if(!e.evaluable)return null;const r=o?e.branches.true:e.branches.false;if(!r){const e=s.childNodes[i];return e&&s.removeChild(e),this.unregisterRenderedElement(t),null}const a=this.buildElement(r,n),c=s.childNodes[i];return c?s.replaceChild(a,c):s.childNodes.length>i?s.insertBefore(a,s.childNodes[i]):s.appendChild(a),a instanceof HTMLElement?(this.registerRenderedElement(t,a),a):null}}class g{constructor(){this.templates=new Map,this.conditionalElements=new Map,this.componentStates=new Map}loadTemplateMap(t,e){for(const[n,s]of Object.entries(e.templates))this.templates.set(`${t}:${n}`,{template:s.templateString||s.template,bindings:s.bindings,slots:s.slots,path:s.path,type:s.type});if(e.conditionalElements)for(const[n,s]of Object.entries(e.conditionalElements))this.conditionalElements.set(`${t}:${n}`,s);this.componentStates.has(t)||this.componentStates.set(t,new Map)}registerTemplate(t,e,n){this.templates.set(`${t}:${e}`,n)}getTemplate(t,e){return this.templates.get(`${t}:${e}`)}getComponentTemplates(t){const e=new Map;for(const[n,s]of this.templates.entries())if(n.startsWith(t+":")){const i=n.substring(t.length+1);e.set(i,s)}return e}getTemplatesBoundTo(t,e){const n=[];for(const[s,i]of this.templates.entries())s.startsWith(t+":")&&i.bindings.includes(e)&&n.push(i);return n}getConditionalElementsBoundTo(t,e){const n=[];for(const[s,i]of this.conditionalElements.entries())if(s.startsWith(t+":")&&i.conditionBindings.includes(e)){const e=s.substring(t.length+1);n.push({pathKey:e,template:i})}return n}getAllComponentState(t){const e=this.componentStates.get(t);if(!e)return{};const n={};for(const[t,s]of e.entries())n[t]=s;return n}updateState(t,e,n){let s=this.componentStates.get(t);s||(s=new Map,this.componentStates.set(t,s)),s.set(e,n)}getStateValue(t,e){return this.componentStates.get(t)?.get(e)}render(t,e){const n=this.getTemplate(t,e);if(!n)return null;const s=n.bindings.map(e=>this.getStateValue(t,e));return this.renderWithParams(n.template,s)}renderWithParams(t,e){let n=t;return e.forEach((t,e)=>{n=n.replace(`{${e}}`,null!=t?t+"":"")}),n}applyTemplatePatch(t){const{componentId:e,path:n,template:s,params:i,bindings:o,slots:r,attribute:a}=t,c=[];for(const t of o){const n=this.getStateValue(e,t);c.push(void 0!==n?n:i[c.length])}const h=this.renderWithParams(s,c),d=`${e}:${this.buildNodePathKey(n)}`,l=this.templates.get(d);return l?(l.template=s,l.bindings=o,l.slots=r,a&&(l.attribute=a)):this.templates.set(d,{template:s,bindings:o,slots:r,path:n.join("."),type:a?"attribute":"dynamic",attribute:a}),{text:h,path:n}}buildNodePathKey(t){return t.join("_")}clearComponent(t){const e=[];for(const n of this.templates.keys())n.startsWith(t+":")&&e.push(n);for(const t of e)this.templates.delete(t);this.componentStates.delete(t)}clear(){this.templates.clear(),this.componentStates.clear()}getStats(){const t=this.componentStates.size,e=this.templates.size;let n=0;for(const t of this.templates.values())n+=2*(t.template?.length||0),n+=20*(t.bindings?.length||0),n+=4*(t.slots?.length||0),n+=2*(t.path?.length||0);return{componentCount:t,templateCount:e,memoryKB:Math.round(n/1024),avgTemplatesPerComponent:e/Math.max(t,1)}}}const w=new g;let C=null,b=0,T=0,I=0;function v(t,e){if(""===e||"."===e)return t;let n=t;const s=e.split(".").map(t=>parseInt(t,16));for(const t of s){if(!n||!n.childNodes)return null;n=n.childNodes[t]||null}return n}function E(t,e){return t.map(t=>`${t}:${!!e[t]}`).sort().join(",")}function S(t){if(!C)throw Error("useState must be called within a component render");const e=C,n="state_"+b++;e.state.has(n)||e.state.set(n,t);const s=e.state.get(n),i=t=>{const s=performance.now(),i="function"==typeof t?t(e.state.get(n)):t;e.signalR?.debug("state","useState called",{componentId:e.componentId,stateKey:n,oldValue:e.state.get(n),newValue:i});const o={[n]:i},r=e.hintQueue.matchHint(e.componentId,o);if(r){const t=performance.now()-s;e.domPatcher.applyPatches(e.element,r.patches),e.signalR?.debug("templates","Template matched",{componentId:e.componentId,hintId:r.hintId,stateChanges:o,patchCount:r.patches.length,latency:t,confidence:r.confidence}),e.playgroundBridge&&e.playgroundBridge.cacheHit({componentId:e.componentId,hintId:r.hintId,latency:t,confidence:r.confidence,patchCount:r.patches.length})}else{const t=performance.now()-s;e.signalR?.debug("templates","Template match failed",{componentId:e.componentId,stateChanges:o,latency:t}),e.playgroundBridge&&e.playgroundBridge.cacheMiss({componentId:e.componentId,methodName:`setState(${n})`,latency:t,patchCount:0})}e.state.set(n,i),w.updateState(e.componentId,n,i);const a=w.getTemplatesBoundTo(e.componentId,n);for(const t of a){const n=t.path.replace(/\./g,"_"),s=w.render(e.componentId,n);if(null!==s){const n=v(e.element,t.path);n&&(n.nodeType===Node.TEXT_NODE?n.textContent=s:n instanceof HTMLElement&&(t.attribute?n.setAttribute(t.attribute,s):n.textContent=s))}}const c=w.getConditionalElementsBoundTo(e.componentId,n);if(c.length>0){const t=w.getAllComponentState(e.componentId);for(const{template:n}of c)if(n.evaluable)try{let s;if(n.pathVariants){const e=E(n.conditionBindings||[],t);if(s=n.pathVariants[e]??void 0,!s)continue}else{if(!n.domPath)continue;s=n.domPath}let i=e.element;for(let t=0;s.length-1>t;t++)i=i.childNodes[s[t]];e.conditionalRenderer.render(n,t,i,s[s.length-1])}catch(t){}}e.signalR.updateComponentState(e.componentId,n,i).catch(t=>{})};return Array.isArray(s)?[s,M(i,s,n,e)]:[s,i]}function M(t,e,n,s){const i=t;return i.append=t=>{const i=[...e,t];s.state.set(n,i),w.updateState(s.componentId,n,i),s.signalR.updateComponentStateWithOperation(s.componentId,n,i,{type:"Append",item:t}).catch(t=>{})},i.prepend=t=>{const i=[t,...e];s.state.set(n,i),w.updateState(s.componentId,n,i),s.signalR.updateComponentStateWithOperation(s.componentId,n,i,{type:"Prepend",item:t}).catch(t=>{})},i.insertAt=(t,i)=>{const o=[...e];o.splice(t,0,i),s.state.set(n,o),w.updateState(s.componentId,n,o),s.signalR.updateComponentStateWithOperation(s.componentId,n,o,{type:"InsertAt",index:t,item:i}).catch(t=>{})},i.removeAt=t=>{const i=e.filter((e,n)=>n!==t);s.state.set(n,i),w.updateState(s.componentId,n,i),s.signalR.updateComponentStateWithOperation(s.componentId,n,i,{type:"RemoveAt",index:t}).catch(t=>{})},i.updateAt=(t,i)=>{const o=[...e];o[t]="function"==typeof i?i(e[t]):{...e[t],...i},s.state.set(n,o),w.updateState(s.componentId,n,o),s.signalR.updateComponentStateWithOperation(s.componentId,n,o,{type:"UpdateAt",index:t,item:o[t]}).catch(t=>{})},i.clear=()=>{t([])},i.removeWhere=n=>{const s=e.filter(t=>!n(t));t(s)},i.updateWhere=(n,s)=>{const i=e.map(t=>n(t)?{...t,...s}:t);t(i)},i.appendMany=n=>{const s=[...e,...n];t(s)},i.removeMany=n=>{const s=e.filter((t,e)=>!n.includes(e));t(s)},i}const $=new Proxy({},{get(t,e){throw Error(`[Minimact] 'state' is a compile-time construct and should not execute at runtime.\nKey accessed: "${e+""}"\n\nThis error means:\n1. The Babel plugin (babel-plugin-minimact) is not configured correctly\n2. You're trying to use 'state' in a non-component context\n3. The file was not transpiled through the Minimact build pipeline\n\nSolution: Ensure babel-plugin-minimact is properly configured in your build.`)},set(t,e,n){throw Error(`[Minimact] Cannot set state directly using 'state.${e+""} = value'.\nUse setState('${e+""}', value) instead.`)},has(t,e){throw Error(`[Minimact] 'state' proxy should not be used with 'in' operator at runtime.\nKey checked: "${e+""}"\nUse hasState('${e+""}') method instead.`)}});class H{constructor(t=document.body,e={}){if(this.eventDelegation=null,"string"==typeof t){const e=document.querySelector(t);if(!e)throw Error("[Minimact] Root element not found: "+t);this.rootElement=e}else this.rootElement=t;this.options={hubUrl:e.hubUrl||"/minimact",enableDebugLogging:e.enableDebugLogging||0,reconnectInterval:e.reconnectInterval||5e3,enableHotReload:0,hotReloadWsUrl:e.hotReloadWsUrl},this.signalR=c.createDefault(this.options.hubUrl,{debugLogging:this.options.enableDebugLogging}),this.domPatcher=new h({debugLogging:this.options.enableDebugLogging}),this.clientState=new d({debugLogging:this.options.enableDebugLogging}),this.hydration=new p(this.clientState,{debugLogging:this.options.enableDebugLogging}),this.hintQueue=new m({debugLogging:this.options.enableDebugLogging}),this.componentRegistry=new f,this.conditionalRenderer=new y,this.log("Minimact initialized (CORE ONLY)",{rootElement:this.rootElement,options:this.options})}async start(){this.setupSignalRHandlers(),await this.signalR.start(),this.hydration.hydrateAll(),this.registerHydratedComponents(),this.eventDelegation=new l(this.rootElement,(t,e,n)=>this.signalR.invokeComponentMethod(t,e,n),{debugLogging:this.options.enableDebugLogging}),await this.registerAllComponents(),this.log("Minimact started")}async stop(){this.eventDelegation&&(this.eventDelegation.destroy(),this.eventDelegation=null),await this.signalR.stop(),this.log("Minimact stopped")}setupSignalRHandlers(){this.signalR.on("updateComponent",({componentId:t,html:e})=>{const n=this.hydration.getComponent(t);n&&(this.domPatcher.replaceHTML(n.element,e),this.log("Component HTML updated",{componentId:t}))}),this.signalR.on("applyPatches",({componentId:t,patches:e})=>{const n=this.hydration.getComponent(t);n&&(this.domPatcher.applyPatches(n.element,e),this.log("Patches applied",{componentId:t,patchCount:e.length}))}),this.signalR.on("applyPrediction",({componentId:t,patches:e,confidence:n})=>{const s=this.hydration.getComponent(t);s&&(this.domPatcher.applyPatches(s.element,e),this.log(`Prediction applied (${(100*n).toFixed(0)}% confident)`,{componentId:t,patchCount:e.length}))}),this.signalR.on("applyCorrection",({componentId:t,patches:e})=>{const n=this.hydration.getComponent(t);n&&(this.domPatcher.applyPatches(n.element,e),this.log("Correction applied (prediction was incorrect)",{componentId:t,patchCount:e.length}))}),this.signalR.on("queueHint",t=>{this.hintQueue.queueHint(t),this.log(`Hint '${t.hintId}' queued for component ${t.componentId}`,{patchCount:t.patches.length,confidence:(100*t.confidence).toFixed(0)+"%"})}),this.signalR.on("reconnected",async()=>{this.log("Reconnected - re-registering components"),await this.registerAllComponents()}),this.signalR.on("error",({})=>{})}async registerAllComponents(){const t=document.querySelectorAll("[data-minimact-component]");for(const e of Array.from(t)){const t=e.getAttribute("data-minimact-component");if(t)try{await this.signalR.registerComponent(t),this.log("Registered component",{componentId:t})}catch(t){}}}hydrateComponent(t,e){this.hydration.hydrateComponent(t,e)}getComponent(t){return this.hydration.getComponent(t)}registerHydratedComponents(){const t=window.__MINIMACT_VIEWMODEL__;if(!t||!t.t||!t.i)return;const e=t.t,n=t.i,s=document.querySelector(`[data-minimact-component-id="${n}"]`);if(!s)return;const i=this.hydration.getComponent(n);i&&(i.type=e,this.componentRegistry.register({type:e,instanceId:n,element:s,context:i.context}))}getClientState(t,e){return this.clientState.getState(t,e)}setClientState(t,e,n){this.clientState.setState(t,e,n)}subscribeToState(t,e,n){return this.clientState.subscribe(t,e,n)}get connectionState(){return""+this.signalR.state}get connectionId(){return this.signalR.connectionId}log(t,e){}}if("undefined"!=typeof window)if("loading"===document.readyState)document.addEventListener("DOMContentLoaded",()=>{if(document.body.hasAttribute("data-minimact-auto-init")){const t=new H(document.body,{enableDebugLogging:document.body.hasAttribute("data-minimact-debug"),enableHotReload:0});t.start().catch(console.error),window.minimact=t}});else if(document.body.hasAttribute("data-minimact-auto-init")){const t=new H(document.body,{enableDebugLogging:document.body.hasAttribute("data-minimact-debug"),enableHotReload:0});t.start().catch(console.error),window.minimact=t}"undefined"!=typeof window&&(window.Minimact=H),t.ClientStateManager=d,t.ConditionalElementRenderer=y,t.DOMPatcher=h,t.EventDelegation=l,t.HintQueue=m,t.HydrationManager=p,t.Minimact=H,t.MinimactComponentRegistry=f,t.SignalMManager=c,t.TemplateRenderer=u,t.TemplateStateManager=g,t.clearComponentContext=()=>{C=null},t.default=H,t.setComponentContext=t=>{C=t,b=0,T=0,I=0},t.setState=(t,e)=>{throw Error(`[Minimact] 'setState' is a compile-time construct and should not execute at runtime.\nKey: "${t}", Value: ${JSON.stringify(e)}\n\nThis error means:\n1. The Babel plugin (babel-plugin-minimact) is not configured correctly\n2. You're trying to use 'setState' in a non-component context\n3. The file was not transpiled through the Minimact build pipeline\n\nSolution: Ensure babel-plugin-minimact is properly configured in your build.`)},t.state=$,t.templateState=w,t.useEffect=(t,e)=>{if(!C)throw Error("useEffect must be called within a component render");const n=C,s=T++;if(n.effects[s]){const i=n.effects[s];(!e||!i.deps||e.length!==i.deps.length||e.some((t,e)=>t!==i.deps[e]))&&(i.cleanup&&i.cleanup(),i.callback=t,i.deps=e,queueMicrotask(()=>{const e=t();"function"==typeof e&&(i.cleanup=e)}))}else n.effects[s]={callback:t,deps:e,cleanup:void 0},queueMicrotask(()=>{const e=t();"function"==typeof e&&(n.effects[s].cleanup=e)})},t.useProtectedState=t=>S(t),t.useRef=t=>{if(!C)throw Error("useRef must be called within a component render");const e=C,n="ref_"+I++;return e.refs.has(n)||e.refs.set(n,{current:t}),e.refs.get(n)},t.useState=S,Object.defineProperty(t,"o",{value:1})}({});
//# sourceMappingURL=core.min.js.map
